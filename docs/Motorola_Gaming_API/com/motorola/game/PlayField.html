<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Frameset//EN""http://www.w3.org/TR/REC-html40/frameset.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc on Wed Oct 03 11:51:45 CDT 2001 -->
<TITLE>
: Class  PlayField
</TITLE>
<LINK REL ="stylesheet" TYPE="text/css" HREF="../../../stylesheet.css" TITLE="Style">
</HEAD>
<BODY BGCOLOR="white">

<!-- ========== START OF NAVBAR ========== -->
<A NAME="navbar_top"><!-- --></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../com/motorola/game/PaletteImage.html"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../../../com/motorola/game/SoundEffect.html"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../index.html" TARGET="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="PlayField.html" TARGET="_top"><B>NO FRAMES</B></A></FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY: &nbsp;INNER&nbsp;|&nbsp;FIELD&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL: &nbsp;FIELD&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<!-- =========== END OF NAVBAR =========== -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
com.motorola.game</FONT>
<BR>
Class  PlayField</H2>
<PRE>
java.lang.Object
  |
  +--<B>com.motorola.game.PlayField</B>
</PRE>
<HR>
<DL>
<DT>public class <B>PlayField</B><DT>extends java.lang.Object</DL>

<P>
A PlayField is a rectangular grid of cells with a set of available tiles
 to place in those cells and a set of associated Sprites.<p>

 <h3>Cells</h3>
 The PlayField grid is made up of (rows * columns) cells, where rows and
 columns are
 defined by parameters to the constructor.  The cells are
 equally sized.  The size of the cells is defined by the size of the
 tiles, or if the PlayField has no tiles, by arguments to the constructor.
 Each cell is either empty or contains a single tile whose image will
 be drawn in that cell.  An empty cell is fully transparent - Nothing
 will be drawn in that area by the PlayField.

 <h3>Tiles</h3>
 The tiles used to fill the PlayField cells can be either static tiles or
 animated tiles.  Tiles are referred to using index numbers.  Tile 0
 (tile with index 0)
 refers to the special empty tile. Any cell assigned the tile 0 will
 be considered empty and will be effectively transparent.<p>

 The static tile indices are positive (>=0) and the animated tiles indices
 are negative (<0).<p>

 NOTE: <i>Throughout this section we will use the following shorthand to
 refer to particular tiles: Tile X refers to the tile with index X.
 If X < 0, then
 it is an animated tile.  If X >= 0, it is a static tile.</i>

 <ul>
 <li>Static Tiles<p>

 Static tiles are called static because their image does not often change,
 i.e. Any cell that contains the static Tile 1 will always be drawn
 as the unchanging image of Tile 1.<p>

 The set of static tiles is created when the PlayField instance is
 constructed. If necessary, the entire static tile set can be
 be replaced with the <A HREF="../../../com/motorola/game/PlayField.html#setStaticTileSet(javax.microedition.lcdui.Image, int, int)"><CODE>setStaticTileSet(Image, int, int)</CODE></A> method.
 Furthermore, individual tile images can be change with the
 <A HREF="../../../com/motorola/game/PlayField.html#setStaticTileImage(int, javax.microedition.lcdui.Image, int, int)"><CODE>setStaticTileImage(int, Image, int, int)</CODE></A> method.<p>

 Tile 0 is a special static tile.  It represents
 an empty cell. Any cell containing tile 0 will will be transparent, it will
 not have a tile image drawn in it.<p>

 <li>Animated Tiles<p>

 Animated tiles are called animated because their appearance changes easily
 over time.  At any given time, each animated tile is associated with a
 particular static tile.  Use <A HREF="../../../com/motorola/game/PlayField.html#createAnimatedTile(int)"><CODE>createAnimatedTile(int)</CODE></A> to create a new
 animated Tile.<p>

 When a cell containing an animated tile is drawn, the image of the static
 tile currently referenced by that animated tile will be drawn in that
 cell.<p>

 In effect, the animated tiles provide indirect references to the set of
 static tiles, and therefore allow many cells to be animated simultaneously.
 For example, cells (0,0) and (0,1) both contain animated Tile -2.
 Animated Tile -2 currently references static Tile 1. Cells (0,0) and
 (0,1) will then be drawn with the image of static Tile 1.  If animated
 Tile -2 is subsequently set to reference static Tile 2 by calling
 <code>setAnimatedTileImage(-2, 2);</code>, cells (0,0) and
 (0,1) will then be drawn with the image of static Tile 2.<p>

 Note that the effect of using animated tiles can be accomplished by using
 only static tiles and the <A HREF="../../../com/motorola/game/PlayField.html#setStaticTileImage(int, javax.microedition.lcdui.Image, int, int)"><CODE>setStaticTileImage(int, Image, int, int)</CODE></A>
 and <A HREF="../../../com/motorola/game/PlayField.html#setStaticTileSet(javax.microedition.lcdui.Image, int, int)"><CODE>setStaticTileSet(Image, int, int)</CODE></A> methods.  This is discouraged
 because these methods consume significantly more memory and time.
 </ul>

 <h3>Sprites</h3>
 In addition to being a grid of cells, a Playfield can have a set of
 associated Sprites (see <A HREF="../../../com/motorola/game/Sprite.html"><CODE>Sprite</CODE></A>).<p>

 When the PlayField is drawn, the grid is considered to have depth 0.
 Therefore, Sprites below the grid (Sprites with <code>Sprite.getDepth()
 < 0</code>) are drawn first.
 Then all cells in the grid are drawn.  Then all the Sprites above the grid
 (<code>Sprite.getDepth() >= 0</code>) are drawn. The Sprites are drawn
 according to their location
 and visibility status as defined in the Sprite class.  The locations of
 Sprites is relative to the top-left corner of the PlayField.<p>


 <h3>View Window</h3>
 A view window onto the PlayField can be defined using the method
 <A HREF="../../../com/motorola/game/PlayField.html#setViewWindow(int, int, int, int)"><CODE>setViewWindow(int, int, int, int)</CODE></A>.  This defines the area of the
 PlayField that will be drawn by the <A HREF="../../../com/motorola/game/PlayField.html#draw(javax.microedition.lcdui.Graphics, int, int)"><CODE>draw(Graphics, int, int)</CODE></A>
 method.  The default
 viewing window onto a PlayField (at construction time) is the entire
 area of the PlayField.  See the methods mentioned for further details.<br>

 <hr>

 This document and the information contained in it are <b>CONFIDENTIAL
 AND PROPRIETARY INFORMATION of Motorola, Inc. </b>and shall not be
 used, published, disclosed, or disseminated outside of Motorola in
 whole or in part without Motorola's consent. This document contains
 trade secrets of Motorola. Reverse engineering of any or all of the
 information in this document in prohibited.
 <p>

 <b>© Copyright 2001 Motorola, Inc.  All Rights Reserved.</b>
 This notice does not imply publication
 <hr>
<P>
<HR>

<P>
<!-- ======== INNER CLASS SUMMARY ======== -->


<!-- =========== FIELD SUMMARY =========== -->


<!-- ======== CONSTRUCTOR SUMMARY ======== -->

<A NAME="constructor_summary"><!-- --></A>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=2><FONT SIZE="+2">
<B>Constructor Summary</B></FONT></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../../com/motorola/game/PlayField.html#PlayField(int, int, javax.microedition.lcdui.Image, int, int)">PlayField</A></B>(int&nbsp;columns,
          int&nbsp;rows,
          javax.microedition.lcdui.Image&nbsp;img,
          int&nbsp;tWidth,
          int&nbsp;tHeight)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Creates a new PlayField with a tile set.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../../com/motorola/game/PlayField.html#PlayField(int, int, int, int)">PlayField</A></B>(int&nbsp;columns,
          int&nbsp;rows,
          int&nbsp;cellWidth,
          int&nbsp;cellHeight)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Creates a new PlayField without a tile set.</TD>
</TR>
</TABLE>
&nbsp;
<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=2><FONT SIZE="+2">
<B>Method Summary</B></FONT></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/motorola/game/PlayField.html#addSprite(com.motorola.game.Sprite)">addSprite</A></B>(<A HREF="../../../com/motorola/game/Sprite.html">Sprite</A>&nbsp;s)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Add a Sprite to the PlayField.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/motorola/game/PlayField.html#anyCollisions()">anyCollisions</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Check for any collisions on the PlayField.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/motorola/game/PlayField.html#collidesWithAnyTile(com.motorola.game.Sprite)">collidesWithAnyTile</A></B>(<A HREF="../../../com/motorola/game/Sprite.html">Sprite</A>&nbsp;s)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Check for Sprite collision with PlayField tiles.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/motorola/game/PlayField.html#collidesWithSprites(com.motorola.game.Sprite)">collidesWithSprites</A></B>(<A HREF="../../../com/motorola/game/Sprite.html">Sprite</A>&nbsp;s)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Check for Sprite collision with any other Sprites on the
 PlayField.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/motorola/game/PlayField.html#collidesWithTiles(int, int, int, int, com.motorola.game.Sprite, boolean)">collidesWithTiles</A></B>(int&nbsp;col,
                  int&nbsp;row,
                  int&nbsp;width,
                  int&nbsp;height,
                  <A HREF="../../../com/motorola/game/Sprite.html">Sprite</A>&nbsp;s,
                  boolean&nbsp;pixelLevel)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Check for Sprite collision with a region of PlayField tiles.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/motorola/game/PlayField.html#createAnimatedTile(int)">createAnimatedTile</A></B>(int&nbsp;staticTileIdx)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Create a new animated tile.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/motorola/game/PlayField.html#draw(javax.microedition.lcdui.Graphics, int, int)">draw</A></B>(javax.microedition.lcdui.Graphics&nbsp;g,
     int&nbsp;x,
     int&nbsp;y)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Draw the PlayField.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/motorola/game/PlayField.html#fillCells(int, int, int, int, int)">fillCells</A></B>(int&nbsp;col,
          int&nbsp;row,
          int&nbsp;width,
          int&nbsp;height,
          int&nbsp;tileIdx)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Fill an area of cells with a particular tile.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/motorola/game/PlayField.html#getAnimatedTileImage(int)">getAnimatedTileImage</A></B>(int&nbsp;animTileIdx)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Get the static tile referenced by an animated tile.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/motorola/game/PlayField.html#getCell(int, int)">getCell</A></B>(int&nbsp;col,
        int&nbsp;row)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Gets the tile currently displayed in a cell.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/motorola/game/PlayField.html#getCellHeight()">getCellHeight</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Get height of a cell, in pixels</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/motorola/game/PlayField.html#getCellWidth()">getCellWidth</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Get width of a cell, in pixels</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/motorola/game/PlayField.html#getGridHeight()">getGridHeight</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Get height of the PlayField grid, in cells</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/motorola/game/PlayField.html#getGridWidth()">getGridWidth</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Get width of the PlayField grid, in cells</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/motorola/game/PlayField.html#moveTiles(int, int, int, int, int, int)">moveTiles</A></B>(int&nbsp;dstCol,
          int&nbsp;dstRow,
          int&nbsp;srcCol,
          int&nbsp;srcRow,
          int&nbsp;width,
          int&nbsp;height)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Move a set of tiles.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/motorola/game/PlayField.html#removeAllSprites()">removeAllSprites</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Remove all Sprites from PlayField.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/motorola/game/PlayField.html#removeSprite(com.motorola.game.Sprite)">removeSprite</A></B>(<A HREF="../../../com/motorola/game/Sprite.html">Sprite</A>&nbsp;s)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Remove a Sprite from PlayField.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/motorola/game/PlayField.html#setAnimatedTileImage(int, int)">setAnimatedTileImage</A></B>(int&nbsp;animTileIdx,
                     int&nbsp;staticTileIdx)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Set the static tile image referenced by an animated tile.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/motorola/game/PlayField.html#setCell(int, int, int)">setCell</A></B>(int&nbsp;col,
        int&nbsp;row,
        int&nbsp;tileIdx)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the tile to be displayed in a cell.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/motorola/game/PlayField.html#setStaticTileImage(int, javax.microedition.lcdui.Image, int, int)">setStaticTileImage</A></B>(int&nbsp;staticTileIdx,
                   javax.microedition.lcdui.Image&nbsp;img,
                   int&nbsp;x,
                   int&nbsp;y)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Modify the image associated with a static tile.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/motorola/game/PlayField.html#setStaticTileSet(javax.microedition.lcdui.Image, int, int)">setStaticTileSet</A></B>(javax.microedition.lcdui.Image&nbsp;img,
                 int&nbsp;tWidth,
                 int&nbsp;tHeight)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Change the static tile set.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/motorola/game/PlayField.html#setViewWindow(int, int, int, int)">setViewWindow</A></B>(int&nbsp;x,
              int&nbsp;y,
              int&nbsp;width,
              int&nbsp;height)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Set the view on the PlayField.</TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.lang.Object"><!-- --></A>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TD><B>Methods inherited from class java.lang.Object</B></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE>clone, equals, finalize, getClass, hashCode, notify, notifyAll, toString, wait, wait, wait</CODE></TD>
</TR>
</TABLE>
&nbsp;
<P>

<!-- ============ FIELD DETAIL =========== -->


<!-- ========= CONSTRUCTOR DETAIL ======== -->

<A NAME="constructor_detail"><!-- --></A>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=1><FONT SIZE="+2">
<B>Constructor Detail</B></FONT></TD>
</TR>
</TABLE>

<A NAME="PlayField(int, int, javax.microedition.lcdui.Image, int, int)"><!-- --></A><H3>
PlayField</H3>
<PRE>
public <B>PlayField</B>(int&nbsp;columns,
                 int&nbsp;rows,
                 javax.microedition.lcdui.Image&nbsp;img,
                 int&nbsp;tWidth,
                 int&nbsp;tHeight)
          throws java.lang.NullPointerException,
                 java.lang.IllegalArgumentException</PRE>
<DL>
<DD>Creates a new PlayField with a tile set.  <p>

 Creates a new PlayField, <code>rows</code> cells high and
 <code>columns</code> cells wide. The static tile set for the
 PlayField will be created from subsections
 of the image passed in.  The PlayField grid is initially filled
 with empty cells (tile 0) and laying out tiles must be accomplished
 through the use of other methods in the class.<p>

 The creation of the static tile set follows these standards:<p>

 Tiles must be equally sized, all being of the tile width
 (<code>tWidth</code>) and height (<code>tHeight</code>) defined in the
 constructor parameters.  They may be
 laid out in the image horizontally, vertically, or as a grid.  The
 width of the source image must be an integer multiple of
 the tile width.  The height of the source image must be an integer
 multiple of the tile height.<p>

 The tiles in the source image will have indices as follows:<br>
 The static tiles are indexed like words are read on a page;
 left-to-right, then top-to-bottom.  The top-left tile is assigned index
 1. If there is a tile to its
 right, this tile is assigned index 2, and so on, across the first row
 of tiles.
 If there is a second row of tiles, the index of the left-most tile in
 this
 row is one greater than the right-most tile in the preceding row.
 Below is
 is a diagrammatic depiction:<br>
 <pre>
 --------------------------------------------------------------
 |     1     |     2     |   .................   |      n     |
 |-----------|-----------|-----------------------|------------|
 |   n + 1   |   n + 2   |   .................   |    2 * n   |
 |-----------|-----------|-----------------------|------------|
 | 2 * n + 1 | 2 * n + 2 |   .................   |    3 * n   |
 |-----------|-----------|-----------------------|------------|
 |    ...................................................     |
 |    ...................................................     |
 |-----------|-----------|-----------------------|------------|
 |(m-1)*n + 1|(m-1)*n + 2|   .................   |    m * n   |
 --------------------------------------------------------------
 </pre>
 So the total number of tiles is m * n, where:
 <ul>
 <li>n = (image width) / (tile width)
 <li>m = (image height) / (tile height)
 </ul>
 <p>
 The indices for the static tile set will be positive (>=0) and the
 indices for animated tiles will be negative (<0).  The index sets do
 not overlap and therefore indices for static and
 animated tiles can be used interchangeably in the methods that set or
 move the contents of the PlayField cells.<p>

 The static Tile set shall behave as if the image used in creation were
 cached.  If a
 mutable image is used to create the tiles, the tiles' appearances
 should not reflect changes to the mutable source image.<p>

 The appearance of
 individual static tiles can be changed with
 <A HREF="../../../com/motorola/game/PlayField.html#setStaticTileImage(int, javax.microedition.lcdui.Image, int, int)"><CODE>setStaticTileImage(int, Image, int, int)</CODE></A>.  The entire static
 tile set can be changed using <A HREF="../../../com/motorola/game/PlayField.html#setStaticTileSet(javax.microedition.lcdui.Image, int, int)"><CODE>setStaticTileSet(Image, int, int)</CODE></A>.
 These methods should be used sparingly since they are both memory and
 time consuming.  Where possible, animated tiles should be used instead
 to animate tile appearance.<p>

 <i>Note:</i> Tile 0 is a reserved tile and represents an empty
 square.<p>

 <i>Note:</i> The on-screen pixel dimensions of a cell in the PlayField
 grid is the same as the pixel dimensions of the tiles<DD><DL>
<DT><B>Parameters:</B><DD><CODE>columns</CODE> - Width of the PlayField in number of columns<DD><CODE>rows</CODE> - Height of the PlayField in number of rows<DD><CODE>img</CODE> - Image to use for creating tiles<DD><CODE>tWidth</CODE> - width, in pixels, of the individual tiles<DD><CODE>tHeight</CODE> - height, in pixels, of the individual tiles<DT><B>Throws:</B><DD><CODE>java.lang.NullPointerException</CODE> - if img is null<DD><CODE>java.lang.IllegalArgumentException</CODE> - if <code>rows < 1 || columns < 1 ||
         tWidth < 1 || tHeight < 1 ||
         img.getWidth() % tWidth != 0 || img.getHeight() % tHeight != 0
         </code></DL>
</DD>
</DL>
<HR>

<A NAME="PlayField(int, int, int, int)"><!-- --></A><H3>
PlayField</H3>
<PRE>
public <B>PlayField</B>(int&nbsp;columns,
                 int&nbsp;rows,
                 int&nbsp;cellWidth,
                 int&nbsp;cellHeight)
          throws java.lang.IllegalArgumentException</PRE>
<DL>
<DD>Creates a new PlayField without a tile set.  <p>

 Creates a new PlayField, <code>rows</code> cells high and
 <code>columns</code> cells wide. A PlayField created with this
 constructor will not have any tiles (animated or static)
 associated with it.
 The primary use of a PlayField without tiles is expected to be as a
 container for managing Sprites.<p>

 The on-screen pixel dimensions of cells is defined by the parameters
 <code>cellWidth</code> and <code>cellHeight</code>.<p>

 The cells in the PlayField are all empty (tile 0).<p>

 A tile set can later be added using
 <A HREF="../../../com/motorola/game/PlayField.html#setStaticTileSet(javax.microedition.lcdui.Image, int, int)"><CODE>setStaticTileSet(Image, int, int)</CODE></A>.<p>

 Since there are no static tiles, no animated tiles can be
 created unless a static tile set is added first.<p><DD><DL>
<DT><B>Parameters:</B><DD><CODE>columns</CODE> - Width of the PlayField in number of cells<DD><CODE>rows</CODE> - Height of the PlayField in number of cells<DD><CODE>cellWidth</CODE> - Pixel width of each cell<DD><CODE>cellHeight</CODE> - Pixel height of each cell<DT><B>Throws:</B><DD><CODE>java.lang.IllegalArgumentException</CODE> - if <code>rows < 1 || columns < 1 ||
         cellWidth < 1 || cellHeight < 1</code></DL>
</DD>
</DL>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=1><FONT SIZE="+2">
<B>Method Detail</B></FONT></TD>
</TR>
</TABLE>

<A NAME="addSprite(com.motorola.game.Sprite)"><!-- --></A><H3>
addSprite</H3>
<PRE>
public void <B>addSprite</B>(<A HREF="../../../com/motorola/game/Sprite.html">Sprite</A>&nbsp;s)
               throws java.lang.NullPointerException</PRE>
<DL>
<DD>Add a Sprite to the PlayField. <p>

 Silently ignores the request if the Sprite is already associated with
 the PlayField.<DD><DL>
<DT><B>Parameters:</B><DD><CODE>s</CODE> - Sprite to add to the PlayField<DT><B>Throws:</B><DD><CODE>java.lang.NullPointerException</CODE> - if s is null</DL>
</DD>
</DL>
<HR>

<A NAME="removeSprite(com.motorola.game.Sprite)"><!-- --></A><H3>
removeSprite</H3>
<PRE>
public void <B>removeSprite</B>(<A HREF="../../../com/motorola/game/Sprite.html">Sprite</A>&nbsp;s)
                  throws java.lang.RuntimeException,
                         java.lang.NullPointerException</PRE>
<DL>
<DD>Remove a Sprite from PlayField.  <p><DD><DL>
<DT><B>Parameters:</B><DD><CODE>s</CODE> - Sprite to remove from PlayField<DT><B>Throws:</B><DD><CODE>java.lang.NullPointerException</CODE> - if s is null<DD><CODE>java.lang.RuntimeException</CODE> - if Sprite s is not associated with the
         PlayField</DL>
</DD>
</DL>
<HR>

<A NAME="removeAllSprites()"><!-- --></A><H3>
removeAllSprites</H3>
<PRE>
public void <B>removeAllSprites</B>()</PRE>
<DL>
<DD>Remove all Sprites from PlayField.  <p>

 If there are no Sprites associated with the PlayField, the request is
 silently ignored.</DL>
<HR>

<A NAME="createAnimatedTile(int)"><!-- --></A><H3>
createAnimatedTile</H3>
<PRE>
public int <B>createAnimatedTile</B>(int&nbsp;staticTileIdx)
                       throws java.lang.IndexOutOfBoundsException</PRE>
<DL>
<DD>Create a new animated tile.  <p>

 Creates a new animated tile and initializes it with a static tile.<p>

 Returns the index to use when referring to this animated tile.  The
 indices for animated tiles will be negative (<0) and
 the indices for the static tile set will be positive (>=0).
 The index sets do not overlap and therefore indices for static and
 animated tiles can be used interchangeably in the methods that set or
 move the contents of the PlayField cells.<p>

 The first animated tile shall have the index -1, the second, -2, etc.<DD><DL>
<DT><B>Parameters:</B><DD><CODE>staticTileIdx</CODE> - Index of tile from the static tile set<DT><B>Returns:</B><DD>Index of newly created animated tile<DT><B>Throws:</B><DD><CODE>java.lang.IndexOutOfBoundsException</CODE> - if there is no static tile with
         index <code>staticTileIdx</code></DL>
</DD>
</DL>
<HR>

<A NAME="setAnimatedTileImage(int, int)"><!-- --></A><H3>
setAnimatedTileImage</H3>
<PRE>
public void <B>setAnimatedTileImage</B>(int&nbsp;animTileIdx,
                                 int&nbsp;staticTileIdx)
                          throws java.lang.IndexOutOfBoundsException</PRE>
<DL>
<DD>Set the static tile image referenced by an animated tile.  <p>

 Sets the static tile that will be displayed in any cell that contains
 the animated tile.<DD><DL>
<DT><B>Parameters:</B><DD><CODE>animTileIdx</CODE> - Index of the animated tile<DD><CODE>staticTileIdx</CODE> - Index of a static tile to be referenced by the
        animated tile<DT><B>Throws:</B><DD><CODE>java.lang.IndexOutOfBoundsException</CODE> - if there is no static tile with
         index <code>staticTileIdx</code> or no animated tile with
         index <code>animTileIdx</code></DL>
</DD>
</DL>
<HR>

<A NAME="getAnimatedTileImage(int)"><!-- --></A><H3>
getAnimatedTileImage</H3>
<PRE>
public int <B>getAnimatedTileImage</B>(int&nbsp;animTileIdx)
                         throws java.lang.IndexOutOfBoundsException</PRE>
<DL>
<DD>Get the static tile referenced by an animated tile.  <p>

 Returns the index of the static tile that is currently referenced by
 an animated tile.<DD><DL>
<DT><B>Parameters:</B><DD><CODE>animTileIdx</CODE> - Index of the animated tile to check<DT><B>Returns:</B><DD>Index of the static tile reference by this animated tile<DT><B>Throws:</B><DD><CODE>java.lang.IndexOutOfBoundsException</CODE> - if there is no animated tile with
         index <code>animTileIdx</code></DL>
</DD>
</DL>
<HR>

<A NAME="setCell(int, int, int)"><!-- --></A><H3>
setCell</H3>
<PRE>
public void <B>setCell</B>(int&nbsp;col,
                    int&nbsp;row,
                    int&nbsp;tileIdx)
             throws java.lang.IndexOutOfBoundsException,
                    java.lang.ArrayIndexOutOfBoundsException</PRE>
<DL>
<DD>Sets the tile to be displayed in a cell.  <P>

 The tile can be either a static or an animated tile.<DD><DL>
<DT><B>Parameters:</B><DD><CODE>col</CODE> - Column of cell to set<DD><CODE>row</CODE> - Row of cell to set<DD><CODE>tileIdx</CODE> - Index of tile to place in cell<DT><B>Throws:</B><DD><CODE>java.lang.IndexOutOfBoundsException</CODE> - if there is no tile with index
         <code>tileIdx</code><DD><CODE>java.lang.ArrayIndexOutOfBoundsException</CODE> - if <code>row</code> or
         <code>col</code> is outside the bounds of the PlayField grid</DL>
</DD>
</DL>
<HR>

<A NAME="getCell(int, int)"><!-- --></A><H3>
getCell</H3>
<PRE>
public int <B>getCell</B>(int&nbsp;col,
                   int&nbsp;row)
            throws java.lang.ArrayIndexOutOfBoundsException</PRE>
<DL>
<DD>Gets the tile currently displayed in a cell.  <p>

 Gets the index of the static or animated tile currently displayed in
 a cell<DD><DL>
<DT><B>Parameters:</B><DD><CODE>col</CODE> - Column of cell to check<DD><CODE>row</CODE> - Row of cell to check<DT><B>Returns:</B><DD>Index of tile in cell<DT><B>Throws:</B><DD><CODE>java.lang.ArrayIndexOutOfBoundsException</CODE> - if <code>row</code> or
         <code>col</code> is outside the bounds of the PlayField grid</DL>
</DD>
</DL>
<HR>

<A NAME="moveTiles(int, int, int, int, int, int)"><!-- --></A><H3>
moveTiles</H3>
<PRE>
public void <B>moveTiles</B>(int&nbsp;dstCol,
                      int&nbsp;dstRow,
                      int&nbsp;srcCol,
                      int&nbsp;srcRow,
                      int&nbsp;width,
                      int&nbsp;height)
               throws java.lang.ArrayIndexOutOfBoundsException</PRE>
<DL>
<DD>Move a set of tiles.  <p>

 Move a rectangular set of tiles from a source location to a
 destination location.  Source cells are left empty.  If the source and 
 destination cells overlap, the method shall behave as if the source cells
 are first copied to a separate array, the source cells are cleared, 
 and the tiles are then copied back to the destination cells.<DD><DL>
<DT><B>Parameters:</B><DD><CODE>dstCol</CODE> - Column of top-left destination cell<DD><CODE>dstRow</CODE> - Row of top-left destination cell<DD><CODE>srcCol</CODE> - Column of top-left source cell<DD><CODE>srcRow</CODE> - Row of top-left source cell<DD><CODE>width</CODE> - Width, in rows, of area of tiles to move<DD><CODE>height</CODE> - Height, in rows, of area of tiles to move<DT><B>Throws:</B><DD><CODE>java.lang.ArrayIndexOutOfBoundsException</CODE> - if either of the rectangular
         regions defined by the parameters extends beyond the bounds of
         the PlayField grid</DL>
</DD>
</DL>
<HR>

<A NAME="fillCells(int, int, int, int, int)"><!-- --></A><H3>
fillCells</H3>
<PRE>
public void <B>fillCells</B>(int&nbsp;col,
                      int&nbsp;row,
                      int&nbsp;width,
                      int&nbsp;height,
                      int&nbsp;tileIdx)
               throws java.lang.IndexOutOfBoundsException,
                      java.lang.ArrayIndexOutOfBoundsException</PRE>
<DL>
<DD>Fill an area of cells with a particular tile.  <p>

 Fill each cell in a rectangular area with a given animated or static
 tile<DD><DL>
<DT><B>Parameters:</B><DD><CODE>col</CODE> - Column of top-left cell<DD><CODE>row</CODE> - Row of top-left cell<DD><CODE>width</CODE> - Width, in rows, of area of cells to fill<DD><CODE>height</CODE> - Height, in rows, of area of cells to fill<DD><CODE>tileIdx</CODE> - Index of tile to place in fill region<DT><B>Throws:</B><DD><CODE>java.lang.ArrayIndexOutOfBoundsException</CODE> - if the rectangular region
         defined by the parameters extends beyond the bounds of the
         PlayField grid<DD><CODE>java.lang.IndexOutOfBoundsException</CODE> - if there is no tile with
         index <code>tileIdx</code></DL>
</DD>
</DL>
<HR>

<A NAME="draw(javax.microedition.lcdui.Graphics, int, int)"><!-- --></A><H3>
draw</H3>
<PRE>
public void <B>draw</B>(javax.microedition.lcdui.Graphics&nbsp;g,
                 int&nbsp;x,
                 int&nbsp;y)
          throws java.lang.NullPointerException</PRE>
<DL>
<DD>Draw the PlayField.  <p>

 Draw the PlayField to a Graphics instance, anchoring the top left corner
 of the PlayField view window at the position <code>(x, y)</code> on the
 Graphics instance.<p>

 The PlayField will be drawn as follows:<br>

 <OL>
 <li>Draw all the Sprites with depth < 0 in increasing order of depth
 (depth -2 drawn before or below depth -1).
 <li>Draw the tiles for all cells.<br>
     Empty cells, those with Tile 0, are considered fully transparent,
 so nothing is drawn for them.
 <li>Draw the all the Sprites with depth >= 0 in increasing order of
 depth (depth 1 drawn before or below depth 2). <br>
     The location of the Sprites is defined by the Sprite instance
 and is relative to the top left corner of the PlayField grid.
 </ol>

 <i>Notes:</i>
 <ul>
 <li>Drawing the PlayField will not cause it to clear the area
 behind it.  Therefore, if the PlayField includes any transparency
 (partially transparent tiles or empty cells), the
 area behind the PlayField may have to be cleared prior to each draw.
 <li>Sprites outside the boundary of the PlayField grid will
 be drawn only if the defined view window includes their location.
 </ul><DD><DL>
<DT><B>Parameters:</B><DD><CODE>g</CODE> - Graphics instance on which to draw the PlayField<DD><CODE>x</CODE> - the x coordinate of the top left corner of the PlayField<DD><CODE>y</CODE> - the y coordinate of the top left corner of the PlayField<DT><B>Throws:</B><DD><CODE>java.lang.NullPointerException</CODE> - if g is null<DT><B>See Also: </B><DD><A HREF="../../../com/motorola/game/PlayField.html#setViewWindow(int, int, int, int)"><CODE>setViewWindow(int, int, int, int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="getCellWidth()"><!-- --></A><H3>
getCellWidth</H3>
<PRE>
public int <B>getCellWidth</B>()</PRE>
<DL>
<DD>Get width of a cell, in pixels<DD><DL>
<DT><B>Returns:</B><DD>Width, in pixels, of a single cell in the PlayField grid</DL>
</DD>
</DL>
<HR>

<A NAME="getCellHeight()"><!-- --></A><H3>
getCellHeight</H3>
<PRE>
public int <B>getCellHeight</B>()</PRE>
<DL>
<DD>Get height of a cell, in pixels<DD><DL>
<DT><B>Returns:</B><DD>Height, in pixels, of a single cell in the PlayField grid</DL>
</DD>
</DL>
<HR>

<A NAME="getGridWidth()"><!-- --></A><H3>
getGridWidth</H3>
<PRE>
public int <B>getGridWidth</B>()</PRE>
<DL>
<DD>Get width of the PlayField grid, in cells<DD><DL>
<DT><B>Returns:</B><DD>Width, in cells, of the PlayField grid</DL>
</DD>
</DL>
<HR>

<A NAME="getGridHeight()"><!-- --></A><H3>
getGridHeight</H3>
<PRE>
public int <B>getGridHeight</B>()</PRE>
<DL>
<DD>Get height of the PlayField grid, in cells<DD><DL>
<DT><B>Returns:</B><DD>Height, in cells, of the PlayField grid</DL>
</DD>
</DL>
<HR>

<A NAME="anyCollisions()"><!-- --></A><H3>
anyCollisions</H3>
<PRE>
public boolean <B>anyCollisions</B>()</PRE>
<DL>
<DD>Check for any collisions on the PlayField.  <p>

 This method checks whether any of the PlayField's Sprites collide
 with any of the PlayField's
 tiles or other Sprites on the PlayField.  It will return
 <code>true</code>
 if any Sprite on the PlayField collides with a tile or any
 other Sprite.  Like <A HREF="../../../com/motorola/game/PlayField.html#collidesWithSprites(com.motorola.game.Sprite)"><CODE>collidesWithSprites(Sprite)</CODE></A> and
 <A HREF="../../../com/motorola/game/PlayField.html#collidesWithAnyTile(com.motorola.game.Sprite)"><CODE>collidesWithAnyTile(Sprite)</CODE></A>, this method reports collisions
 only at a boundary level granularity, not pixel level granularity.<DD><DL>
<DT><B>Returns:</B><DD>boolean indicating whether any Sprite on the PlayField
         collides with another Sprite or a Tile</DL>
</DD>
</DL>
<HR>

<A NAME="collidesWithSprites(com.motorola.game.Sprite)"><!-- --></A><H3>
collidesWithSprites</H3>
<PRE>
public boolean <B>collidesWithSprites</B>(<A HREF="../../../com/motorola/game/Sprite.html">Sprite</A>&nbsp;s)
                            throws java.lang.NullPointerException</PRE>
<DL>
<DD>Check for Sprite collision with any other Sprites on the
 PlayField.  <p>

 Return true if Sprite instance s has boundaries that overlap
 with the boundaries of any other Sprite
 currently on the PlayField.<p>

 This method is complemented by
 <A HREF="../../../com/motorola/game/Sprite.html#collidesWith(com.motorola.game.Sprite, boolean)"><CODE>Sprite.collidesWith(Sprite, boolean)</CODE></A>; If
 <code>collidesWithSprites(Sprite)</code> returns true, the
 developer can find the exact Sprite collision(s) by using
 <A HREF="../../../com/motorola/game/Sprite.html#collidesWith(com.motorola.game.Sprite, boolean)"><CODE>Sprite.collidesWith(Sprite, boolean)</CODE></A>.  This is similar to how
 <A HREF="../../../com/motorola/game/PlayField.html#collidesWithAnyTile(com.motorola.game.Sprite)"><CODE>collidesWithAnyTile(Sprite)</CODE></A> and
 <A HREF="../../../com/motorola/game/PlayField.html#collidesWithTiles(int, int, int, int, com.motorola.game.Sprite, boolean)"><CODE>collidesWithTiles(int, int, int, int, Sprite, boolean)</CODE></A>
 complement each other.<p>

 Sprite <code>s</code> does not have to have been added to the
 PlayField. The collision detection will proceed as if the Sprite is
 on the PlayField.  That is, its location will be treated as relative
 to the origin of the PlayField's coordinate system.<DD><DL>
<DT><B>Parameters:</B><DD><CODE>s</CODE> - Sprite to check for collision<DT><B>Returns:</B><DD>boolean indicating whether the Sprite collides with any other
 Sprite on the PlayField.<DT><B>Throws:</B><DD><CODE>java.lang.NullPointerException</CODE> - if s is null</DL>
</DD>
</DL>
<HR>

<A NAME="collidesWithAnyTile(com.motorola.game.Sprite)"><!-- --></A><H3>
collidesWithAnyTile</H3>
<PRE>
public boolean <B>collidesWithAnyTile</B>(<A HREF="../../../com/motorola/game/Sprite.html">Sprite</A>&nbsp;s)
                            throws java.lang.NullPointerException</PRE>
<DL>
<DD>Check for Sprite collision with PlayField tiles.  <p>

 Return true if the Sprite overlaps with a cell that
 contains a tile (i.e. a cell containing a non-zero tile index). <p>

 Sprite <code>s</code> does not have to have been added to the
 PlayField. The collision detection will proceed as if the Sprite is
 on the PlayField.  That is, its location will be treated as relative
 to the origin of the PlayField's coordinate system.<DD><DL>
<DT><B>Parameters:</B><DD><CODE>s</CODE> - Sprite to check for collision<DT><B>Returns:</B><DD>boolean indicating whether the Sprite is colliding with a
 PlayField tile<DT><B>Throws:</B><DD><CODE>java.lang.NullPointerException</CODE> - if s is null</DL>
</DD>
</DL>
<HR>

<A NAME="collidesWithTiles(int, int, int, int, com.motorola.game.Sprite, boolean)"><!-- --></A><H3>
collidesWithTiles</H3>
<PRE>
public boolean <B>collidesWithTiles</B>(int&nbsp;col,
                                 int&nbsp;row,
                                 int&nbsp;width,
                                 int&nbsp;height,
                                 <A HREF="../../../com/motorola/game/Sprite.html">Sprite</A>&nbsp;s,
                                 boolean&nbsp;pixelLevel)
                          throws java.lang.NullPointerException,
                                 java.lang.ArrayIndexOutOfBoundsException</PRE>
<DL>
<DD>Check for Sprite collision with a region of PlayField tiles.  <p>

 Return true if the Sprite overlaps with a cell in the
 defined region that contains a tile (i.e. a cell containing a
 non-zero tile index).<p>

 If <code>pixelLevel</code> is true, this method
 will report a collision only when opaque Sprite pixels overlap
 opaque tile pixels.<p>

 This method complements the <A HREF="../../../com/motorola/game/PlayField.html#collidesWithAnyTile(com.motorola.game.Sprite)"><CODE>collidesWithAnyTile(Sprite)</CODE></A> method
 by letting the programmer focus their search and find
 specific tiles or regions of collision.  This is similar
 to how <A HREF="../../../com/motorola/game/Sprite.html#collidesWith(com.motorola.game.Sprite, boolean)"><CODE>Sprite.collidesWith(Sprite, boolean)</CODE></A> complements
 <A HREF="../../../com/motorola/game/PlayField.html#collidesWithSprites(com.motorola.game.Sprite)"><CODE>collidesWithSprites(Sprite)</CODE></A>.<p>

 Sprite <code>s</code> does not have to have been added to the
 PlayField. The collision detection will proceed as if the Sprite is
 on the PlayField.  That is, its location will be treated as relative
 to the origin of the PlayField's coordinate system.<DD><DL>
<DT><B>Parameters:</B><DD><CODE>row</CODE> - Row of top-left cell for collision check region<DD><CODE>col</CODE> - Column of top-left cell for collision check region<DD><CODE>height</CODE> - Height, in rows, of area for collision check<DD><CODE>width</CODE> - Width, in rows, of area for collision check<DD><CODE>s</CODE> - Sprite to check for collision<DD><CODE>pixelLevel</CODE> - Boolean indicating whether collision detection
              should be done at a pixel level instead of
              simply as boundary checks<DT><B>Returns:</B><DD>boolean indicating whether the Sprite is colliding with a tile<DT><B>Throws:</B><DD><CODE>java.lang.NullPointerException</CODE> - if s is null<DD><CODE>java.lang.ArrayIndexOutOfBoundsException</CODE> - if the rectangular region
         defined by the parameters extends beyond the bounds of the
         PlayField grid</DL>
</DD>
</DL>
<HR>

<A NAME="setStaticTileImage(int, javax.microedition.lcdui.Image, int, int)"><!-- --></A><H3>
setStaticTileImage</H3>
<PRE>
public void <B>setStaticTileImage</B>(int&nbsp;staticTileIdx,
                               javax.microedition.lcdui.Image&nbsp;img,
                               int&nbsp;x,
                               int&nbsp;y)
                        throws java.lang.NullPointerException,
                               java.lang.IndexOutOfBoundsException</PRE>
<DL>
<DD>Modify the image associated with a static tile.  <p>

 <b><i>NOTE: As currently prototyped, using this function will
 cause the entire static tile set to lose transparency information!
 This problem will be easy to fix in the actual implementation when this 
 method is handled by native code.</b></i><p>

 Replace the image currently associated with a static tile with a
 new image of the same size.  New static tile image will be extracted
 from the image passed in, starting from pixel <code>(x, y)</code>
 in the new
 source image and extending for <A HREF="../../../com/motorola/game/PlayField.html#getCellWidth()"><CODE>getCellWidth()</CODE></A> pixels
 horizontally
 and <A HREF="../../../com/motorola/game/PlayField.html#getCellHeight()"><CODE>getCellHeight()</CODE></A> pixels vertically.<p>

 As at tile set creation time, if a mutable source image is used,
 behavior of the tile set should be as if the new image were
 cached.  Updates to the mutable source image will not
 cause a change in the appearance of the tile image.<DD><DL>
<DT><B>Parameters:</B><DD><CODE>staticTileIdx</CODE> - Index of static tile whose image is to be updated<DD><CODE>img</CODE> - Source for new image<DD><CODE>x</CODE> - x coordinate of top-left pixel in source image for region of
          new tile image<DD><CODE>y</CODE> - y coordinate of top-left pixel in source image for region of
          new tile image<DT><B>Throws:</B><DD><CODE>java.lang.IndexOutOfBoundsException</CODE> - if there is no static tile with
         index <code>staticTileIdx</code> or if the rectangular
         region required for the tile extends beyond the bounds
         of the Image<DD><CODE>java.lang.NullPointerException</CODE> - if img is null</DL>
</DD>
</DL>
<HR>

<A NAME="setStaticTileSet(javax.microedition.lcdui.Image, int, int)"><!-- --></A><H3>
setStaticTileSet</H3>
<PRE>
public void <B>setStaticTileSet</B>(javax.microedition.lcdui.Image&nbsp;img,
                             int&nbsp;tWidth,
                             int&nbsp;tHeight)
                      throws java.lang.NullPointerException,
                             java.lang.IllegalArgumentException</PRE>
<DL>
<DD>Change the static tile set.  <p>

 Replaces the current static tile set with a new static tile set.
 See the constructor <A HREF="../../../com/motorola/game/PlayField.html#PlayField(int, int, javax.microedition.lcdui.Image, int, int)"><CODE>PlayField(int, int, Image, int, int)</CODE></A>
 for information on how the tiles are created from the
 image.<p>

 If the new static tiles have the same dimensions as the previous
 static tiles, the view window will be unchanged.  If the new static
 tiles have different dimensions than the previous
 static tiles, the view window will be reset to the construction default,
 i.e. the entire grid dimension.<p>

 If the new static tile set has as many or more tiles than the previous
 static tile set, then:
 <ul>
 <li>The animated tiles will be unchanged
 <li>The contents of the PlayField grid will be unchanged.
 </ul>
 If the new static tile set has
 less tiles than the previous static tile set, then:
 <ul>
 <li>The PlayField grid will be reset to completely empty
 <li>All animated tiles will be deleted
 </ul><DD><DL>
<DT><B>Parameters:</B><DD><CODE>img</CODE> - Image to use for Sprite<DD><CODE>tWidth</CODE> - width, in pixels, of the individual tiles<DD><CODE>tHeight</CODE> - height, in pixels, of the individual tiles<DT><B>Throws:</B><DD><CODE>java.lang.NullPointerException</CODE> - if img is null<DD><CODE>java.lang.IllegalArgumentException</CODE> - if <code>tWidth < 1 || tHeight < 1 ||
         img.getWidth() % tWidth != 0 || img.getHeight() % tHeight !=0
         </code></DL>
</DD>
</DL>
<HR>

<A NAME="setViewWindow(int, int, int, int)"><!-- --></A><H3>
setViewWindow</H3>
<PRE>
public void <B>setViewWindow</B>(int&nbsp;x,
                          int&nbsp;y,
                          int&nbsp;width,
                          int&nbsp;height)</PRE>
<DL>
<DD>Set the view on the PlayField.  <p>

 Sets the portion of the PlayField that will be drawn when
 <A HREF="../../../com/motorola/game/PlayField.html#draw(javax.microedition.lcdui.Graphics, int, int)"><CODE>draw(Graphics, int, int)</CODE></A> is called.  This will limit the
 portion
 of the PlayField that is drawn to the rectangle defined by
 the region <code>(x, y)</code> to 
 <code>(x + width, y + height)</code>.<p>

 The default view window (at construction time) is the entire area
 of the PlayField, i.e. the rectangular region bounded by
 <code>(0, 0)</code>
 and <code>(<A HREF="../../../com/motorola/game/PlayField.html#getGridWidth()"><CODE>getGridWidth()</CODE></A> * <A HREF="../../../com/motorola/game/PlayField.html#getCellWidth()"><CODE>getCellWidth()</CODE></A>,
            <A HREF="../../../com/motorola/game/PlayField.html#getGridHeight()"><CODE>getGridHeight()</CODE></A> * <A HREF="../../../com/motorola/game/PlayField.html#getCellHeight()"><CODE>getCellHeight()</CODE></A>)</code>.
 <p>

 The rectangle defined by the parameters may extend beyond the bounds
 of the PlayField.  If this happens, the
 <A HREF="../../../com/motorola/game/PlayField.html#draw(javax.microedition.lcdui.Graphics, int, int)"><CODE>draw(Graphics, int, int)</CODE></A> method will draw no
 tiles in the area outside the grid boundaries.  Sprites may still be
 drawn in this area if their
 position places them outside the bounds of the PlayField grid.<p>

 The view window stays in effect until it is modified by another
 call to this method or is reset as a result of calling
 <A HREF="../../../com/motorola/game/PlayField.html#setStaticTileSet(javax.microedition.lcdui.Image, int, int)"><CODE>setStaticTileSet(Image, int, int)</CODE></A>.<P>

 <i><b>No method is defined for getting the current view window.</i></b><DD><DL>
<DT><B>Parameters:</B><DD><CODE>x</CODE> - x coord of top-left pixel for the drawing view window<DD><CODE>y</CODE> - y coord of top-left pixel for the drawing view window<DD><CODE>width</CODE> - width of the drawing view window<DD><CODE>height</CODE> - height of the drawing view window</DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>

<!-- ========== START OF NAVBAR ========== -->
<A NAME="navbar_bottom"><!-- --></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../com/motorola/game/PaletteImage.html"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../../../com/motorola/game/SoundEffect.html"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../index.html" TARGET="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="PlayField.html" TARGET="_top"><B>NO FRAMES</B></A></FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY: &nbsp;INNER&nbsp;|&nbsp;FIELD&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL: &nbsp;FIELD&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<!-- =========== END OF NAVBAR =========== -->

<HR>

</BODY>
</HTML>
