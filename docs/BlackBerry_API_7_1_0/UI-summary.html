<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Frameset//EN""http://www.w3.org/TR/REC-html40/frameset.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc on Mon Jul 28 14:36:56 EDT 2008 -->
<TITLE>
BlackBerry Java SDK 7.0 API Reference: UI
</TITLE>
<LINK REL ="stylesheet" TYPE="text/css" HREF="stylesheet.css" TITLE="Style">
<script type="text/javascript">
<!--
// switchMenu - Expand or collapse a code sample div. Takes two arguments:
// divSample, the id of the div to expand, divList
function switchMenu(divSample, sourceLink) {

	var el = document.getElementById(divSample).style;
	if (el.display == 'none') {
		el.display = 'block';
		sourceLink.className = 'explink_minus';
	} else {
		el.display = 'none';
		sourceLink.className = 'explink_plus';
	}
}

// collapseAll - Collapses all expandable divs and adds the + graphic automatically when the page loads.
// This is done so that users who do not have JS enabled can still see the code samples.
function collapseAll() {
	// Collapse all expandable divs
	var divsOnPage = document.getElementsByTagName('div');
	for (var x = 0; x < divsOnPage.length; x++) {
		if (divsOnPage[x].id.substr(0,3) == "UI_") {
		
			divsOnPage[x].style.display = 'none';
			
		}
	}
	// Change all the expand/collapse links to explink_plus, to show a plus sign beside it
	var linksOnPage = document.getElementsByTagName('a');
	for (var y = 0; y < linksOnPage.length; y++) {
		if (linksOnPage[y].className == "explink") {
			linksOnPage[y].className = "explink_plus";
		}
	}
}
//-->
</script>
</HEAD>
<BODY BGCOLOR="white" onLoad="collapseAll();">

<!-- ========== START OF NAVBAR ========== -->
<A NAME="navbar_top"><!-- --></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A> </TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev">  <FONT CLASS="NavBarFont1Rev">Package</FONT> </TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev">  <FONT CLASS="NavBarFont1Rev">Class</FONT> </TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="overview-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A> </TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A> </TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A> </TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A> </TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
 PREV 
 NEXT</FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="index.html" TARGET="_top"><B>FRAMES</B></A>   
 <A HREF="UI-summary.html" TARGET="_top"><B>NO FRAMES</B></A></FONT></TD>
</TR>
</TABLE>
<!-- =========== END OF NAVBAR =========== -->
<HR>
<FORM action="https://www.blackberry.com/DocsFeedback/" method="GET" target="_new">
<INPUT type="hidden" name="title" value="API Reference">
<INPUT type="hidden" name="source" value="External">

<INPUT type="hidden" name="version" value="7.0.0">
<INPUT type="hidden" name="classname" value="UI overview">
<INPUT type="submit" value="Submit Feedback" /></FORM>

<BR>


<h1 align="center">User Interface (UI)<a name="UI_TOP"></a></h1>

<h2>Overview</h2>
<p>This document describes how to create UIs for BlackBerry&reg; device applications. This document includes the following sections:
<ul>
  <li><a href="#UI_1">UI frameworks</a></li>
  <li><a href="#UI_2">Advantages of the BlackBerry UI APIs</a></li>
  <li><a href="#UI_3">Interactions between MIDlets and BlackBerry Java Applications</a></li>
  <li><a href="#UI_MVC">The Model-View-Controller design pattern</a></li>
  <li><a href="#UI_4">UI application threads</a></li>
  <li><a href="#UI_7">Modal screens</a> </li>
</ul>
<p>For more information about UI development, visit <a href="http://www.blackberry.com/go/devguides">www.blackberry.com/go/devguides</a> to read the <i>BlackBerry Java SDK UI and Navigation Development Guide</i>. For additional resources, visit <a href="http://www.blackberry.com/developers">www.blackberry.com/developers</a>.
<h2>UI frameworks <a name="UI_1"></a></h2>
<p>You can create UIs for the BlackBerry device using the following frameworks: 
<ul>
  <li><a href="#UI_1A">BlackBerry UI APIs</a> </li>
  <li><a href="#UI_1B">Mobile Information Device Profile APIs </a> </li>
  <li><a href="#UI_1C">Scalable Vector Graphics APIs</a></li>
  <li><a href="#UI_VG">Graphics Utility API</a></li>
</ul>
<h3>BlackBerry UI APIs <a name="UI_1A"></a></h3>
<p><strong>Packages</strong>: <a href="net/rim/device/api/browser/field/package-summary.html">net.rim.device.api.browser.field</a>, <a href="net/rim/device/api/browser/field2/package-summary.html">net.rim.device.api.browser.field2</a>, <a href="net/rim/device/api/lbs/package-summary.html">net.rim.device.api.lbs</a>, <a href="net/rim/blackberry/api/spellcheck/package-summary.html">net.rim.blackberry.api.spellcheck</a>, 
<a href="net/rim/device/api/ui/package-summary.html">net.rim.device.api.ui</a>, <a href="net/rim/device/api/ui/accessibility/package-summary.html">net.rim.device.api.ui.accessibility </a>, <a href="net/rim/device/api/ui/autotext/package-summary.html">net.rim.device.api.ui.autotext</a>, <a href="net/rim/device/api/ui//component/package-summary.html">net.rim.device.api.ui.component</a>, <a href="net/rim/device/api/ui/container/package-summary.html">net.rim.device.api.ui.container</a>, <a href="net/rim/device/api/ui/decor/package-summary.html">net.rim.device.api.ui.decor</a>, <a href="net/rim/device/api/ui/extension/container/package-summary.html">net.rim.device.api.ui.extension.container</a>, <a href="net/rim/device/api/ui/extension/component/package-summary.html">net.rim.device.api.ui.extension.component</a>, <a href="net/rim/device/api/ui/image/package-summary.html">net.rim.device.api.ui.image </a>, <a href="net/rim/device/api/ui/menu/package-summary.html">net.rim.device.api.ui.menu </a>, <a href="net/rim/device/api/ui/picker/package-summary.html">net.rim.device.api.ui.picker</a>, <a href="net/rim/device/api/ui/text/package-summary.html">net.rim.device.api.ui.text</a>
<p>To create UI applications that are optimized to run on  BlackBerry devices and interact efficiently with core  applications (such as the Messages application and Phone application), use the BlackBerry UI APIs. Applications that use the BlackBerry UI APIs cannot run on other mobile devices.
<p> For more information about the BlackBerry UI APIs, see the <a href="net/rim/device/api/ui/package-summary.html">package overview</a>. 
<h3>Mobile Information Device Profile (MIDP) APIs <a name="UI_1B"></a></h3>

<p><strong>Packages</strong>:
<a href="javax/microedition/lcdui/package-summary.html">javax.microedition.lcdui,</a> <a href="javax/microedition/lcdui/game/package-summary.html">javax.microedition.lcdui.game</a>, <a href="javax/microedition/midlet/package-summary.html">javax.microedition.midlet</a>

<p>MIDlets are applications that use only the standard Mobile Information Device Profile (MIDP) APIs and Connected Limited Device Configuration (CLDC) APIs. The BlackBerry&reg;  Java&reg;  SDK currently supports both MIDP  1.0 (<a href="http://jcp.org/en/jsr/detail?id=37" target="_blank">JSR 37</a>) and MIDP 2.1 (<a href="http://jcp.org/en/jsr/detail?id=118" target="_blank">JSR 118</a>). MIDlets run on BlackBerry devices and other devices that support the Java Platform, Micro Edition (Java&reg;  ME) platform.
<p>For more information about the MIDP UI APIs, see the <a href="javax/microedition/lcdui/package-summary.html">package overview</a>.
<h3>Scalable Vector Graphics (SVG) APIs <a name="UI_1C"></a></h3>

<p><strong>Packages</strong>:
<a href="org/w3c/dom/package-summary.html">org.w3c.dom</a>, <a href="org/w3c/dom/events/package-summary.html">org.w3c.dom.events</a>, <a href="org/w3c/dom/svg/package-summary.html">org.w3c.dom.svg</a>, <a href="net/rim/plazmic/mediaengine/package-summary.html">net.rim.plazmic.mediaengine</a>, <a href="net/rim/plazmic/mediaengine/io/package-summary.html">net.rim.plazmic.mediaengine.io</a>
<p>Scalable Vector Graphics (SVG) is a text-based markup language, similar to HTML, that represents 2D vector graphics, animation, and interactivity. SVG support was added to Java ME with <a href="http://jcp.org/en/jsr/detail?id=226" target="_blank">JSR 226</a>. Vector graphics rely on geometrical primitive objects such as lines, circles, polygons. Because they are based on geometry, vector graphics can be easily manipulated without loss of accuracy.  SVG has the advantage of automatically scaling objects to the screen resolution on a mobile device. You can use SVG for both MIDlets and BlackBerry Java Applications.
<p>There are two ways to use SVG in your applications on a BlackBerry device:
<ul>
  <li>For BlackBerry Java SDK 4.6 or later,  you can use SVG directly, as detailed in  
  <a href="http://jcp.org/en/jsr/detail?id=226" target="_blank">JSR 226</a>, using  <a href="org/w3c/dom/package-summary.html">org.w3c.dom</a>, <a href="org/w3c/dom/events/package-summary.html">org.w3c.dom.events</a>, and<a href="org/w3c/dom/svg/package-summary.html"> org.w3c.dom.svg</a>.</li>
  <li>For BlackBerry Java SDK 4.5 or earlier,  you can use .pme files as a binary representation of SVG content by using the <a href="net/rim/plazmic/mediaengine/package-summary.html">net.rim.plazmic.mediaengine</a> and <a href="net/rim/plazmic/mediaengine/io/package-summary.html">net.rim.plazmic.mediaengine.io</a> packages. With .pme files, you can test content using the media engine simulator or the BlackBerry Smartphone Simulator, and view content on a BlackBerry device.</li>
</ul>

<h3>Graphics Utility API<a name="UI_VG"></a></h3>

<p><strong>Packages</strong>:
<a href="net/rim/device/api/openvg/package-summary.html">net.rim.device.api.openvg</a>, 
<a href="net/rim/device/api/opengles/package-summary.html">net.rim.device.api.opengles</a>

<p>The Graphics Utility API is new in BlackBerry Java SDK 6.0. The API is designed to simplify OpenVG&trade; and OpenGL&reg; ES development on BlackBerry devices while also optimizing performance. Because this API is included in the <a href="#UI_1A">BlackBerry  UI APIs</a>, applications that use this API cannot run on other mobile devices.
<p>The  <a href="net/rim/device/api/openvg/VGField.html" class="style2">VGField</a> class and <a href="net/rim/device/api/opengles/GLField.html" class="style2">GLField</a>  class are included in this API.
<h2>Advantages of the BlackBerry UI APIs<a name="UI_2"></a> <span class="style4"><a href="#UI_TOP" class="backtotop">[back to top]</a></span></h2>
<p>While you can use either MIDP APIs or BlackBerry UI APIs, consider the following advantages that are available when you use the BlackBerry UI APIs to create UIs.
<h3>Increased display options  </h3>
<p>A major difference between the MIDP API and BlackBerry UI APIs is the number of display options permitted. MIDP separates UI components into high- and low-level APIs. When you use the high-level APIs to make it easier to run your application on other mobile device platforms,  you can view only one <a href="javax/microedition/lcdui/Displayable.html" class="style2">Displayable</a> object, which represents the device screen, at one time. As a result, you can  view only certain types of UI components at a time. For example, you cannot combine a <a href="javax/microedition/lcdui/List.html" class="style2">List</a> with another type of UI component, such as a <a href="javax/microedition/lcdui/Form.html" class="style2">Form</a>. </p>
<p>&nbsp;</p>
<p><img src="images/UI_MIDP.jpg"></p>
<p>&nbsp;</p>
<p>In contrast, the BlackBerry UI APIs are very flexible. The three main UI objects are <a href="net/rim/device/api/ui/Screen.html" class="style2">Screen</a>, <a href="net/rim/device/api/ui/Manager.html" class="style2">Manager</a>, and <a href="net/rim/device/api/ui/Field.html" class="style2">Field</a>. A screen is the top-level container for the UI elements that what you want to display in your application. Screens can contain fields, such as text fields, radio buttons, and drop-down lists. Screens can also contain layout managers, which contain sets of fields. And because layout managers are fields themselves, they can contain other managers. This architecture provides you with a lot of flexibility when designing your UI.</p>
<p>The BlackBerry API provides a number of layout managers. The following layout managers are most commonly used:</p>
<ul>
  <li><a href="net/rim/device/api/ui/container/VerticalFieldManager.html" class="style2">VerticalFieldManager</a>, which arranges fields in a single vertical column</li>
  <li><a href="net/rim/device/api/ui/container/HorizontalFieldManager.html" class="style2">HorizontalFieldManager</a>, which arranges fields in a single horizontal row</li>
  <li><a href="net/rim/device/api/ui/container/FlowFieldManager.html" class="style2">FlowFieldManager</a>, which  arranges fields first horizontally, then vertically</li>
</ul>
<p>Even using only these three types of managers, you can create  rich layouts in your screens. For example: 
<p>&nbsp;</p>
<p><img src="images/ScreenFieldManager.png"></p>

<h3>Custom fields</h3>
<p>The BlackBerry APIs provide several ways to display particular types of data in a field. Consider the following fields:</p>
<ul>
  <li><a href="net/rim/device/api/ui/component/DateField.html" class="style2">DateField</a> allows you to store a date and display it in different formats in a field (such as 2011/11/17).</li>
  <li><a href="net/rim/device/api/lbs/MapField.html" class="style2">MapField</a> allows you to render a map in a field.</li>
  <li><a href="net/rim/device/api/browser/field2/BrowserField.html" class="style2">BrowserField</a> allows you to display web content in a field.</li>
</ul>
<p>In addition to the  useful field types that are defined in the BlackBerry UI API, you can create your own field types. The BlackBerry UI API provides you with the functionality to extend the <span class="style2">Field</span> class to create any type of field.</p>

<p><a class="explink" onClick="switchMenu('UI_11', this);">Click for code sample: Create a custom text field that contains (non-editable) separate pieces of text</a></p>
<div id="UI_11" class="codesample">
<table cellspacing="0" class="codesample" width="75%">
    <tr>
      <td>
      <pre><span id="support">class MultiElementTextField extends Field 
{  
    //  we must extend field
    String[] _texts;   // an array of text segments
    int[] _spaces;     // an array containing the amount of  space
                       // allocated to each text segment
    int_buffer;        // an integer value which represents
                       // the amount of buffer space between
                       // each text segment

    /* Constructor sets up each of the data arrays
       and the buffer value */
    public MultiElementTextField(Object[] data, int buffer,  long style)
         throws IllegalArgumentException 
    {
        super(style);   // a call to super, this sets up the
                        // particular style of the field.
        int n = data.length;
        if ((n % 2) != 0) 
        {
            throw new  IllegalArgumentException("Invalid number of  elements");
        } 
        else 
        {
            _texts  = new String[n / 2];
            _spaces = new int[n / 2];
        }
        for (int i = 0; i &lt; n ; i = i + 2) 
        {
            _texts[i / 2]  = (String)data[i];
            _spaces[i / 2] = ((Integer)data[i+1]).intValue();
        }
        _buffer = buffer;
    }

    public boolean isFocusable() 
    {
        // this field can accept the focus, return true
        return true;
    }

    /* we use layout to determine the extent of the field,
       we ultimately call setExtent(int, int) with the total field  size */
    public void layout(int width, int height) 
    {
        Font font = getFont();
        int _fieldHeight = font.getHeight();
        int _fieldWidth = 0;
        int n = _spaces.length;
        for (int i = 0; i &lt; n; ++i) 
        {
            _fieldWidth += _spaces[i];
            if (i &lt; n - 1) 
            {
                _fieldWidth += _buffer;
            }
        }
        setExtent(_fieldWidth, _fieldHeight);
    }

    /* paint draws the text objects to the screen using the
       Graphics object passed in. Here we are using the values
       from buffer and spaces[] to determine the location and
       size of each segment of text. We use the ELLIPSIS style
       to handle text that is too long for its allocated space
       by replacing any characters that do not fit with ...   */
     public void paint(Graphics graphics) 
    {
        int xpos = 0;
        int n = _spaces.length;
        for (int i = 0; i &lt; n; ++i) 
        {
            graphics.drawText(_texts[i],xpos,0,graphics.ELLIPSIS,_spaces[i]);
            xpos += _spaces[i];
            if (i &lt; n - 1) 
            {
                xpos += _buffer;
            }
        }
    }
}</span></pre></td>
</tr>
</table>
</div>
<p>To create custom fields using the MIDP APIs, you can use the <a href="javax/microedition/lcdui/CustomItem.html" class="style2">CustomItem</a> class. However, unlike <span class="style2">Field</span> extensions, this approach does not allow you to easily modify display options such as borders, layout, and theming.</p>
<h3>Layout control</h3>
<p>The BlackBerry API provides layout managers that offer flexibility when displaying fields. You declare a layout manager at the top level of your screen, and then add fields to it. Because layout managers are subclasses of <a href="net/rim/device/api/ui/Field.html" class="style2">Field</a>, they can be embedded in other layout managers. You can also define your own layout manager.
<p><a class="explink" onClick="switchMenu('UI_22', this);">Click for code sample: Create a custom layout for a screen</a></p>
<div id="UI_22" class="codesample">

<table cellspacing="0" class="codesample" width="75%">
    <tr>
      <td>
      <pre><span id="support">class LayoutManager extends Manager 
{
    public LayoutManager() 
    {
        //construct a manager with vertical scrolling
        super(Manager.VERTICAL_SCROLL);
    }
    
    //overwrite the nextFocus method for custom navigation
    protected int nextFocus(int direction, boolean alt) 
    {
        //retrieve the index of the current field that is selected
        int index= this.getFieldWithFocusIndex();
         if(alt) 
        {
             if(direction  0){...}
             else ...}
        }
        // if we did not handle it, let the manager's parent  class
        if (index == this.getFieldWithFocusIndex())
            return super.nextFocus(direction, alt);
        else
            return index;
     }

    protected void sublayout(int width, int height) 
    {
        Field field;
        //get total number of fields within this manager
        int numberOfFields = getFieldCount();
        int x = 0;
        int y = 0;
        for (int i = 0;i < numberOfFields;i++) 
        {
            field = getField(i);     //get the field
            setPositionChild(field,x,y);  //set the position  for the field
            layoutChild(field, width, height);  //lay out the field
            y += ...;
            ...
        }
        setExtent(width, height);
    }

    public int getPreferredWidth() 
    {
        return 160;
    }

    public int getPreferredHeight() 
    {
        int height= 0;
        int numberOfFields= getFieldCount();
        for (int i= 0; i &lt; numberOfFields; i++) 
        {
            height+= getField(i).getPreferredHeight();
            return height;
        }
    }

    /****************
      Main Class
    ****************/

    ...
    RichTextField myField = new RichTextField("Hello");
    RichTextField myOtherField = new RichTextField("World");
    LayoutManager myManager = new LayoutManager();
    MainScreen myScreen = new MainScreen();
    myScreen.add(myManager);
    myManager.add(myField);
    myManager.add(myOtherField);
}</span></pre></td>
</tr>
</table>
</div>
<p>In the MIDP API, the component that is most closely related to a layout manager is  <span class="style2"><a href="javax/microedition/lcdui/Form.html">Form</a></span>. A <span class="style2">Form</span> arranges <a href="javax/microedition/lcdui/Item.html" class="style2">Item</a> objects vertically on the screen, but does not allow you to change the order that the items are displayed in. As a result, if your UI requires a specific ordering, involves frequent scrolling between fields, or involves a horizontal field layout,  BlackBerry API layout managers are more suitable.
<h3>Pop-up screens </h3>
<p>The BlackBerry UI API has two main types of <a href="net/rim/device/api/ui/Screen.html" class="style2">Screen</a> objects, <a href="net/rim/device/api/ui/container/PopupScreen.html" class="style2">PopupScreen</a> and <a href="net/rim/device/api/ui/container/FullScreen.html" class="style2">FullScreen</a>. <span class="style2">PopupScreen</span> is subclassed by <a href="net/rim/device/api/ui/component/Dialog.html" class="style2">Dialog</a>,  <a href="net/rim/device/api/ui/component/Status.html" class="style2">Status</a>,  <a href="net/rim/device/api/lbs/picker/LocationPicker.html" class="style2">LocationPicker</a>, and <a href="net/rim/device/api/lbs/picker/AbstractLocationPicker.html" class="style2">AbstractLocationPicker</a>. <span class="style2">FullScreen</span> is subclassed by <a href="net/rim/device/api/ui/container/MainScreen.html" class="style2">MainScreen</a> and <a href="net/rim/blackberry/api/phone/phonegui/PhoneScreen.html" class="style2">PhoneScreen</a>.
<p>&nbsp;</p>
<p><img src="images/UI_BB_Popup.jpg" >
<p>&nbsp;</p>

<p>You can use the BlackBerry UI API to display information that is supplementary to your application in a pop-up screen without interrupting the flow of the application. As a result, you do not have to leave the main screen and then return to it later. In addition, you can prioritize which <span class="style2">PopupScreen</span> objects are pushed to the top of the display stack by invoking <a href="net/rim/device/api/ui/UiEngine.html#pushGlobalScreen(net.rim.device.api.ui.Screen, int, int)" class="style2">pushGlobalScreen(Screen, int, int)</a>. 
<p>Because MIDP is intended for devices with minimal screens, such as mobile phones,  <a href="javax/microedition/lcdui/Alert.html" class="style2">Alert</a> objects function differently from <span class="style2">PopupScreen</span> objects in the BlackBerry APIs. <span class="style2">Alert</span> objects are screens that use the entire screen when they are invoked.
<h3>Menus</h3>
<p>The MIDP UI prioritizes commands according to the device specifications, and assigns certain commands to soft keys, which are keys that are not hard-coded on the mobile device. BlackBerry devices organize commands on a menu that you can access by pressing the Menu key. You can specify the order of menu items and the menu item that is selected by default when the menu opens. In addition, you can add or remove menu items depending on the screen or application state when the menu displays.
<h3>Listeners</h3>
<p>The MIDP API includes one default type of listener, <a href="javax/microedition/lcdui/CommandListener.html" class="style2">CommandListener</a>. You can  register only one <span class="style2">CommandListener</span> for each <a href="javax/microedition/lcdui/Displayable.html" class="style2">Displayable</a> object. After you register a <span class="style2">CommandListener</span> with the <span class="style2">Displayable</span> object, you can write code to perform an action when a user selects that object. For example, you can assign a command listener to a <span class="style2">Form</span>, and then perform an action when the user selects an item in the <span class="style2">Form</span>. The MIDP API also contains functions for basic event handling that is based on keyboard input.
<p>The BlackBerry UI API offers a flexible implementation of listeners that is based on a more complex organization of components on a screen. The BlackBerry UI API contains a generic event listener model that permits you to implement listeners for many types of events, such as when a field is changed, or when the user presses a key, clicks the trackpad or trackball, or touches the touch screen.
<h2>Interactions between MIDlets and BlackBerry Java Applications<a name="UI_3"></a>  <span class="style4"><a href="#UI_TOP" class="backtotop">[back to top]</a></span></h2>
<p>When you create UI applications that are MIDlets, you can use BlackBerry APIs to provide specific functionality that is only available for BlackBerry Java Applications. For example, if your MIDlet must notify users when specific events take place, it can invoke the methods that are available in the <a href="net/rim/device/api/notification/package-summary.html" class="style2">net.rim.device.api.notification</a> package. As a result, your application cannot run on other mobile devices.
<p>You can use most of the BlackBerry APIs in your MIDlet. However, do not try to use any classes in the <a href="net/rim/device/api/ui/package-summary.html" class="style2">net.rim.device.api.ui</a> package. Using these classes in a MIDlet is unsupported, and, because of potential incompatibility with future BlackBerry&reg; Device Software releases, may result in an unpredictable user experience.
<h2>The Model-View-Controller design pattern<a name="UI_MVC"></a>  <span class="style4"><a href="#UI_TOP" class="backtotop">[back to top]</a></span></h2>
<p>Some standard components in the BlackBerry UI API &mdash;including activity and progress indicators in the <a href="net/rim/device/api/ui/component/progressindicator/package-summary.html" class="style2">net.rim.device.api.ui.component.progressindicator</a> package and lists and tables in the <a href="net/rim/device/api/ui/component/table/package-summary.html" class="style2">net.rim.device.api.ui.component.table</a> package&mdash;use the Model-View-Controller (MVC) design pattern.  
<p>Before using these components, you should be familar with the MVC design pattern. There are many print and online resources where you can learn about MVC. 
<h2>UI application threads<a name="UI_4"></a>  <span class="style4"><a href="#UI_TOP" class="backtotop">[back to top]</a></span></h2>
<p>All UI applications that are written using the BlackBerry UI APIs contain one event dispatcher thread. The thread that invokes  <a href="net/rim/device/api/system/Application.html#enterEventDispatcher()" class="style2">Application.enterEventDispatcher()</a> becomes the event dispatcher thread and starts to process events.

<h3>Using the event dispatcher thread<a name="UI_6"></a>  </h3>
<p>You can add a runnable object to the event queue. Create a class that implements the <a href="java/lang/Runnable.html" class="style2">Runnable</a> interface, then add the <span class="style2">Runnable</span> object to the event queue by using one of the following methods (which are located in the <a href="net/rim/device/api/system/Application.html" class="style2">net.rim.device.api.system.Application</a> package):
<ul>
<li>Use <a href="net/rim/device/api/system/Application.html#invokeAndWait(java.lang.Runnable)" class="style2">invokeAndWait(Runnable runnable)</a> to queue the <span class="style2">Runnable</span> object to be called on the event dispatcher thread. This method blocks and does not return until the <a href="java/lang/Runnable.html#run()" class="style2">run()</a> method returns.
<li>Use <a href="net/rim/device/api/system/Application.html#invokeLater(java.lang.Runnable)" class="style2">invokeLater(Runnable runnable)</a> to queue the <span class="style2">Runnable</span>  object to be called on the event dispatcher thread after all pending events are processed. This method returns immediately, instead of blocking until <span class="style2">run()</span> returns.
<li>Use <a href="net/rim/device/api/system/Application.html#invokeLater(java.lang.Runnable, long, boolean)" class="style2">invokeLater(Runnable runnable, long time, Boolean repeat)</a> to queue the <span class="style2">Runnable</span> object to be called  on the event dispatcher thread after a specified amount of time. This method returns immediately, instead of blocking until <span class="style2">run()</span> returns. The <span class="style2">time</span> parameter specifies the number of milliseconds to wait before adding the <span class="style2">Runnable</span> object to the event queue. If <span class="style2">repeat</span> is <span class="style2">true</span>, the <span class="style2">Runnable</span> object is added to the event queue every <span class="style2">time</span> milliseconds.
</ul>

<p>Any thread can modify a <a href="net/rim/device/api/ui/Screen.html" class="style2">Screen</a> object before it is pushed on to the display stack or after it is popped off of the display stack.
<p><a class="explink" onClick="switchMenu('UI_44', this);">Click for code sample: Invoke <span class="style2">invokeLater(Runnable runnable)</span> to update a screen on the event thread</a></p>
<div id="UI_44" class="codesample">

<table cellspacing="0" class="codesample" width="75%">
    <tr>
      <td>
      <pre>UiApplication.getUiApplication().invokeLater (new  Runnable() 
{
    public void run()
    {
        //Perform screen changes here.


        //Calling invalidate() on your screen forces the paint method to be called. 
        screenName.invalidate();
    }
});</pre></td>
</tr>
</table>
</div>


<h3>Using a background thread with the event lock<a name="UI_5"></a>  </h3>
<p>You can use background threads to access the UI by acquiring the event lock for a short time. Invoke <a href="net/rim/device/api/system/Application.html#getEventLock()" class="style2">Application.getEventLock()</a> on the background thread to retrieve the event lock, and then synchronize this object to serialize access to the UI. You should only hold this lock for short periods of time because the event dispatcher thread is paused. An application should never call <span class="style2"><a href="java/lang/Object.html#notify()">notify()</a></span> or <span class="style2"><a href="java/lang/Object.html#wait()">wait()</a></span> while holding the event lock on the background thread.
<h2>Modal screens<a name="UI_7"></a>  <span class="style4"><a href="#UI_TOP" class="backtotop">[back to top]</a></span></h2>
<p><span class="style2">Screen</span> objects are pushed on to the display stack by using the <a href="net/rim/device/api/ui/UiEngine.html#pushScreen(net.rim.device.api.ui.Screen)" class="style2">pushScreen()</a> and <a href="net/rim/device/api/ui/UiEngine.html#pushModalScreen(net.rim.device.api.ui.Screen)" class="style2">pushModalScreen()</a> methods of the <span class="style2">UiApplication</span> class. Because <span class="style2">pushModalScreen()</span> blocks until the screen is popped off of the display stack (where <span class="style2">pushScreen()</span> returns immediately), the order of operations is crucial when you use modal screens. Do not invoke <span class="style2">pushModalScreen()</span> before starting the event dispatcher thread; doing so throws a <a href="java/lang/RuntimeException.html" class="style2">RuntimeException</a>. Other methods, such as <a href="net/rim/device/api/ui/component/Dialog.html#inform(java.lang.String)" class="style2">Dialog.inform()</a> and <a href="net/rim/device/api/ui/component/Dialog.html#alert(java.lang.String)" class="style2">Dialog.alert()</a>, also use <span class="style2">pushModalScreen()</span>.
<p><a class="explink" onClick="switchMenu('UI_55', this);">Click for code sample: Display a modal screen and non-modal screen efficiently</a></p>

<div id="UI_55" class="codesample">


<table cellspacing="0" class="codesample" width="75%">
    <tr>
      <td>
        <pre>public class MyApp extends UiApplication implements Runnable 
{
    public MyApp() 
    {
        MainScreen screen = new MainScreen();
        screen.setTitle("My Application");
        screen.add(new LabelField("Welcome to my application!"));
        this.pushScreen(screen);
    }

    public static void main(String[] args) 
    {
        MyApp app = new MyApp();
        new Thread(app).start();
        app.enterEventDispatcher();
    }

    public void run() 
    {
        while (! this.hasEventThread()) 
        {
            Thread.yield();
        }
        this.invokeAndWait(new Runnable() 
        {
            public void run() 
            {
                Dialog.inform("This dialog is being displayed");
            }
        });
    }
}</pre>
</td>
</tr>
</table>
</div>

<HR>
<div id="legalnotice">
<table cellspacing="0" cellpading="0" width="100%" style="border:none;">
<tr>
<td style="border:none;">
<font size=-1>
<P>Copyright 1999-2011 Research In Motion Limited. 295 Phillip Street, Waterloo, Ontario, Canada, N2L 3W8. All Rights Reserved.<br>
Java is a trademark of Oracle America, Inc. in the US and other countries.</p>
</font>
</td>
<td style="text-align:right; border:none;">
<font size=-1><br>
<a href="http://www.blackberry.com/legal" target="_blank">Legal</a>
</font>
</td>
</tr>
</table>
 </div>
 </BODY>
</HTML>
