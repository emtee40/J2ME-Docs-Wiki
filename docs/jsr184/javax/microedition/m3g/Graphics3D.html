<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.4.2_08) on Thu Jun 30 13:21:20 EEST 2005 -->
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<TITLE>
Graphics3D (Mobile 3D Graphics API (M3G))
</TITLE>

<META NAME="keywords" CONTENT="javax.microedition.m3g.Graphics3D class">

<LINK REL ="stylesheet" TYPE="text/css" HREF="../../../stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    parent.document.title="Graphics3D (Mobile 3D Graphics API (M3G))";
}
</SCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A>
<A HREF="#skip-navbar_top" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=3 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/Graphics3D.html"><FONT CLASS="NavBarFont1"><B>Use</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<EM><B>M3G 1.1 -- Jun 22, 2005</B></EM></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../javax/microedition/m3g/Fog.html" title="class in javax.microedition.m3g"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../../../javax/microedition/m3g/Group.html" title="class in javax.microedition.m3g"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../index.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="Graphics3D.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>

</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;<A HREF="#field_summary">FIELD</A>&nbsp;|&nbsp;CONSTR&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;<A HREF="#field_detail">FIELD</A>&nbsp;|&nbsp;CONSTR&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A>
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
javax.microedition.m3g</FONT>
<BR>
Class Graphics3D</H2>
<PRE>
java.lang.Object
  <IMG SRC="../../../resources/inherit.gif" ALT="extended by"><B>javax.microedition.m3g.Graphics3D</B>
</PRE>
<HR>
<DL>
<DT>public class <B>Graphics3D</B><DT>extends java.lang.Object</DL>

<P>
<p>A singleton 3D graphics context that can be bound to a rendering target.
All rendering is done through the <code>render</code> methods in this class,
including the rendering of World objects. There is no other way to draw
anything in this API.</p>

<h3>Quick introduction</h3>

<p>Using the Graphics3D is very straightforward. The application only
needs to obtain the Graphics3D instance (there is only one), bind a
target to it, render everything, and release the target. This is shown
in the code fragment below.</p>

<ul>
<pre class="example"><span class="example_modifier">public</span> <span class="example_proclamation">class</span> <span class="example_class">MyCanvas</span> <span class="example_proclamation">extends</span> <span class="example_class">Canvas</span>
{
   <span class="example_class">Graphics</span>3D myG3D = <span class="example_class">Graphics</span>3D.getInstance();

   <span class="example_modifier">public</span> <span class="example_type">void</span> paint(<span class="example_class">Graphics</span> g) {
   <span class="example_control">try</span> {
      myG3D.bindTarget(g);
      <span class="example_comment">// ... update the scene ...</span>
      <span class="example_comment">// ... render the scene ...</span>
   } <span class="example_control">finally</span> {
      myG3D.releaseTarget();
   }
}</pre>
</ul>

<h3>Immediate mode and retained mode rendering</h3>

<p>There are four different <code>render</code> methods, operating at
different levels of granularity. The first method is for rendering an
entire World. When this method is used, we say that the API operates in
<i>retained mode</i>. The second method is for rendering scene graph
nodes, including Groups. The third and fourth methods are for rendering
an individual submesh. When the node and submesh rendering methods are
used, the API is said to operate in <i>immediate mode</i>.</p>

<p>There is a <i>current camera</i> and an array of <i>current lights</i>
in Graphics3D. These are used by the immediate mode rendering methods only.
The retained mode rendering method <code>render(World)</code> uses the camera
and lights that are specified in the World itself, ignoring the Graphics3D
camera and lights. Instead, <code>render(World)</code> <i>replaces</i> the
Graphics3D current camera and lights with the active camera and lights in the
rendered World. This allows subsequent immediate mode rendering to utilize
the same camera and lighting setup as the World.</p>

<h3>Rendering targets</h3>

<p>Before rendering anything or even clearing the screen, the
application must bind a <i>rendering target</i> to this Graphics3D,
using the <code>bindTarget</code> method. When finished with rendering
a frame, the application must release the rendering target by calling
the <code>releaseTarget</code> method. Implementations may queue
rendering commands and only execute them when the target is released.</p>

<p>The rendering target can be either a Graphics object or an Image2D.
The type of the Graphics object is specific to the Java profile that
this API is implemented on. In case of the MID profile, it must be a
<code>javax.microedition.lcdui.Graphics</code> object, and it may be
associated with a Canvas, mutable Image, or CustomItem.</p>

<p>Once a rendering target is bound to the Graphics3D, all rendering
will end up in the color buffer of its rendering target until
<code>releaseTarget</code> is called.
<span class="new">If the <code>OVERWRITE</code> hint flag is not given,
the contents of the rendering
target, after releasing it, will be equal to what they were before
the target was bound, augmented with any 3D rendering performed while
it was bound. If the hint flag is given, the
implementation may substitute undefined data for the original contents
of the rendering target.</span></p>

<p>There can be only one rendering target bound to the Graphics3D at a
time. Also, a bound rendering target should not be accessed via any
other interface than the host Graphics3D. This is not enforced, but
the results are unpredictable otherwise. For example, the following
scenarios will result in unpredictable output:</p>

<ul>
<li>2D graphics is rendered via MIDP into a bound Image or Canvas.</li>
<li>A bound Image is read from by the application or the MIDP
    implementation.</li>
<li>A bound Image2D is used by a Graphics3D <code>render</code> method.</li>
</ul>

<p>The contents of the depth buffer are unspecified after
<code>bindTarget</code>, and they are discarded after
<code>releaseTarget</code>. In order to clear depth buffer contents
(and color buffer contents, if so desired) after binding a rendering
target, the application must call the <code>clear</code> method,
either explicitly, or implicitly by rendering a World.</p>

<H3>Origin translation and clipping</H3>

<p>The viewport can be freely positioned relative to the rendering target,
without releasing and re-binding the target. The position of the viewport
is specified relative to the origin of the rendering target. For Graphics
targets, this is the origin in effect when calling <code>bindTarget</code>;
for Image2D targets, the origin is always at the top left corner. Changing
the origin of a bound Graphics object has no effect.</p>

<p>All 3D rendering is clipped to visible part of the viewport, that is,
the intersection of the viewport specified in <code>setViewport</code>
and the rendering target clip rectangle. Rendering operations (including
<code>clear</code>) must not touch pixels falling outside of the visible
part of the viewport. This is illustrated in the figure below.</p>

<center><img src="./doc-files/Graphics3D-clipping.png"
width="333" height="256"/></center>

<p>For Graphics targets, the clipping rectangle is the MIDP/AWT clipping
rectangle that is in effect when calling <code>bindTarget</code>. Similar
to the origin, changing the clipping rectangle of a bound Graphics object
<span class="new">will result in unpredictable behavior</span>.
For Image2D targets, the clipping rectangle comprises all
pixels in the target image.</p>

<p>Origin translation and clipping are independent of the viewport and
projection transformations, as well as rasterization. All other parameters
being equal, rendering calls must produce the same pixels (prior to clipping)
into the area bounded by the viewport regardless of the position of the
viewport or the target clipping rectangle.</p>

<p>Note that when we refer to the viewport in this specification, we
occasionally mean only the visible part of it. If it is not obvious
from the context whether we mean the full viewport or just the visible
portion, we state that explicitly.</p>

<h3><a name="hints">Rendering quality hints</a></h3>

<p>In some situations, image quality might be more important for an application
than rendering speed or memory usage. Some applications might also want to
increase or decrease the image quality based on device capabilities. Some
might go so far as to dynamically adjust the quality; for instance, by
displaying freeze frames or slow-motion sequences in higher quality.</p>

<p>There are three global options in Graphics3D that allow applications
to indicate a preference for higher rendering quality at the expense of
slower speed and/or extra memory usage. <span class="new">The application
can specify these <i>rendering quality hints</i> when binding a rendering
target (see <A HREF="../../../javax/microedition/m3g/Graphics3D.html#bindTarget(java.lang.Object, boolean, int)"><CODE>bindTarget</CODE></A>), and
query their availability using <A HREF="../../../javax/microedition/m3g/Graphics3D.html#getProperties()"><CODE>getProperties</CODE></A>. The
hints are as follows:</span></p>

<ul>
<p><li><b>Antialiasing</b>. Specifies that antialiasing should be used to
increase the perceived resolution of the screen. No particular method of
antialiasing is mandated. However, it is strongly recommended that the
method be independent of drawing order, and fast enough to operate at
interactive frame rates. If the chosen method requires post-processing
per frame, that can be done in <code>releaseTarget</code>.</li></p>

<p><li><b>Dithering</b>. Specifies that dithering should be used to increase
the perceived color depth of the screen. No particular method of dithering
is mandated. However, the method should be optimized for animated content
(as opposed to still images) and be able to operate at interactive frame
rates. For example, ordered dithering is recommended over error diffusion.
Implementations may choose to do the dithering at rendering time (per pixel)
or as a post-process (upon <code>releaseTarget</code>).</li></p>

<p><li><b>True color rendering</b>. Specifies that rendering should be done
with an internal color depth higher than what is supported by the device.
For example, on a device with an RGB565 display, rendering could be done
into an RGBA8 back buffer, truncating the pixels to 16 bits only upon
<code>releaseTarget</code>. True color rendering is especially useful
when combined with dithering.</li></p>
</ul>

<p class="new">The fact that a hint is supported does not guarantee that
it is supported for all different types of rendering targets. For example,
antialiasing may be supported for Image targets, but not Canvas targets.
Implementations must indicate support for a hint if that hint is supported
for at least one type of rendering target. Furthermore, if more than one
hint is supported, it is not guaranteed that those hints can be used
together. For example, antialiasing may preclude dithering, and vice versa.
If the application specifies two or more hints, and that combination is not
supported, the implementation may enable any one (or two) of those hints.</p>

<p>It is only meaningful for the
implementation to support a hint if that allows the application to
trade performance for quality or vice versa. For example, if dithering
is built into the display hardware and is always enabled, the
implementation should not indicate support for the dithering
hint. Similarly, if the device has a 24 bpp display, the implementation
should not support the true color hint (unless, of course, it uses even
higher color precision in the back buffer).</p>

<h3>Implementation guidelines</h3>

<p>See the <a href="package-summary.html#Conventions">package
description</a> for general implementation requirements, definitions
of coordinate systems, and other background information.</p>

<h4>Depth buffer</h4>

<p>The format and bit depth of the depth buffer are specific to each
implementation and are not known to the application. However, the depth
buffer resolution must be at least 8 bits. The contents of the depth
buffer are never exposed through the API, so implementations may choose
not to use a conventional depth buffer at all. However, a conforming
implementation is required to behave <i>as if</i> it were using an
ordinary depth buffer.</p>

<h4>Color buffer</h4>

<p>The resolution of each color channel (R, G, B and A) in the color
buffer must be at least 1 bit. Not all color channels are necessarily
present; for example, the alpha channel is missing from Canvas and
Image targets in MIDP. On a device with a black and white display,
there may be only one channel, representing the luminance. In such
a situation, the conversion of RGB colors into luminance can be done
at any point in the pipeline, provided that the conversion is done
according to the general rules set forth in the package description.</p>

<p>The <code>clear</code> and <code>render(World)</code> methods impose
the restriction that the background image must be in the same format as
the bound rendering target. It is worth highlighting that when bound
to a MIDP Graphics object, the effective format can only be RGB (never
RGBA) due to restrictions in the MIDP specification. It is also true
that the MIDP Graphics object appears to be an RGB target even when the
physical display is in fact monochrome. This reduces the complexity of
application development considerably, since an RGB format image is
valid for any binding to a MIDP target. Other target platforms may
or may not be similarly specified.</p>

<h4>Back buffer</h4>

<p>It is intentionally unspecified whether a separate back buffer should
be allocated for colors or not. Instead, we leave it the implementation to
decide which mode of operation is the most efficient, or which produces
the best quality, according to the screen dimensions and speed versus
quality preferences given by the application.</p>

<p>The decision whether to allocate any back buffer memory should be made
at the latest when a new rendering target is first bound to the Graphics3D
object. A previously bound rendering target is considered to be "new" when
the rendering quality hints or the dimensions of the clipping rectangle
have changed. In the case of a Graphics target, the actual rendering target
is considered to be the Canvas, Image or other surface that the Graphics
is attached to. The motivation for this rule is to guarantee that repeated
rebinding of a rendering target - or several different rendering targets -
will not incur the performance penalty of reallocating back buffer memory.</p>

<p>As an example of when a back buffer may be desired, consider a case
where the application specifies <code>setDitheringEnable(true)</code> and
subsequently binds a Canvas target. If the MIDP native color format is of
low precision (such as RGB444), the implementation may wish to render at a
higher color precision to a back buffer, then dither down to the MIDP native
color format.</p>
<P>

<P>
<DL>
<DT><b>Example:</b><DD><div class="example_title">A code fragment illustrating the usage of Graphics3D.

</div><pre class="example"><span class="example_modifier">public</span> <span class="example_proclamation">class</span> <span class="example_class">MyCanvas</span> <span class="example_proclamation">extends</span> <span class="example_class">Canvas</span>
{
    <span class="example_class">World</span> myWorld;
    <span class="example_type">int</span> currentTime = 0;

    <span class="example_modifier">public</span> <span class="example_class">MyCanvas</span>() <span class="example_proclamation">throws</span> <span class="example_class">IOException</span> {

        <span class="example_comment">// Load an entire World. Proper exception handling is omitted</span>
        <span class="example_comment">// for clarity; see the class description of Loader for a more</span>
        <span class="example_comment">// elaborate example.</span>

        <span class="example_class">Object</span>3D[] objects = <span class="example_class">Loader</span>.load(<span class="example_string">"http://www.example.com/myscene.m3g"</span>);
        myWorld = (<span class="example_class">World</span>) objects[0];
    }

    <span class="example_comment">// The paint method is called by MIDP after the application has issued</span>
    <span class="example_comment">// a repaint request. We draw a new frame on this Canvas by binding the</span>
    <span class="example_comment">// current Graphics object as the target, then rendering, and finally</span>
    <span class="example_comment">// releasing the target.</span>

    <span class="example_modifier">protected</span> <span class="example_type">void</span> paint(<span class="example_class">Graphics</span> g) {

        <span class="example_comment">// Get the singleton Graphics3D instance that is associated</span>
        <span class="example_comment">// with this midlet.</span>

        <span class="example_class">Graphics</span>3D g3d = <span class="example_class">Graphics</span>3D.getInstance();

        <span class="example_comment">// Bind the 3D graphics context to the given MIDP Graphics</span>
        <span class="example_comment">// object. The viewport will cover the whole of this Canvas.</span>

        g3d.bindTarget(g);

        <span class="example_comment">// Apply animations, render the scene and release the Graphics.</span>

        myWorld.animate(currentTime);
        g3d.render(myWorld);    <span class="example_comment">// render a view from the active camera</span>
        g3d.releaseTarget();    <span class="example_comment">// flush the rendered image</span>
        currentTime += 50;      <span class="example_comment">// assume we can handle 20 frames per second</span>
    }
}</pre></DD></DD></DL>
<HR>

<P>
<!-- ======== NESTED CLASS SUMMARY ======== -->


<!-- =========== FIELD SUMMARY =========== -->

<A NAME="field_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=2><FONT SIZE="+2">
<B>Field Summary</B></FONT></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/microedition/m3g/Graphics3D.html#ANTIALIAS">ANTIALIAS</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A parameter to <code>bindTarget</code>, specifying that
 antialiasing should be turned on. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/microedition/m3g/Graphics3D.html#DITHER">DITHER</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A parameter to <code>bindTarget</code>, specifying that
 dithering should be turned on. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/microedition/m3g/Graphics3D.html#OVERWRITE">OVERWRITE</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="new">A parameter to <code>bindTarget</code>,
 specifying that the existing contents of the rendering target
 need not be preserved. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/microedition/m3g/Graphics3D.html#TRUE_COLOR">TRUE_COLOR</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A parameter to <code>bindTarget</code>, specifying that true
 color rendering should be turned on. </TD>
</TR>
</TABLE>
&nbsp;
<!-- ======== CONSTRUCTOR SUMMARY ======== -->


<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=2><FONT SIZE="+2">
<B>Method Summary</B></FONT></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/microedition/m3g/Graphics3D.html#addLight(javax.microedition.m3g.Light, javax.microedition.m3g.Transform)">addLight</A></B>(<A HREF="../../../javax/microedition/m3g/Light.html" title="class in javax.microedition.m3g">Light</A>&nbsp;light,
         <A HREF="../../../javax/microedition/m3g/Transform.html" title="class in javax.microedition.m3g">Transform</A>&nbsp;transform)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Binds a Light to use in subsequent immediate mode rendering.
 </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/microedition/m3g/Graphics3D.html#bindTarget(java.lang.Object)">bindTarget</A></B>(java.lang.Object&nbsp;target)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Binds the given Graphics or mutable Image2D as the rendering target
 of this Graphics3D. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/microedition/m3g/Graphics3D.html#bindTarget(java.lang.Object, boolean, int)">bindTarget</A></B>(java.lang.Object&nbsp;target,
           boolean&nbsp;depthBuffer,
           int&nbsp;hints)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Binds the given Graphics or mutable Image2D as the rendering
 target of this Graphics3D. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/microedition/m3g/Graphics3D.html#clear(javax.microedition.m3g.Background)">clear</A></B>(<A HREF="../../../javax/microedition/m3g/Background.html" title="class in javax.microedition.m3g">Background</A>&nbsp;background)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Clears the viewport as specified in the given Background object. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../javax/microedition/m3g/Camera.html" title="class in javax.microedition.m3g">Camera</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/microedition/m3g/Graphics3D.html#getCamera(javax.microedition.m3g.Transform)">getCamera</A></B>(<A HREF="../../../javax/microedition/m3g/Transform.html" title="class in javax.microedition.m3g">Transform</A>&nbsp;transform)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="new">Returns the current camera.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;float</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/microedition/m3g/Graphics3D.html#getDepthRangeFar()">getDepthRangeFar</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="new">Returns the far distance of the depth range.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;float</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/microedition/m3g/Graphics3D.html#getDepthRangeNear()">getDepthRangeNear</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="new">Returns the near distance of the depth range.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/microedition/m3g/Graphics3D.html#getHints()">getHints</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="new">Returns the rendering hints given for the
 current rendering target. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../../javax/microedition/m3g/Graphics3D.html" title="class in javax.microedition.m3g">Graphics3D</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/microedition/m3g/Graphics3D.html#getInstance()">getInstance</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Retrieves the singleton Graphics3D instance that is associated with
 this application. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../javax/microedition/m3g/Light.html" title="class in javax.microedition.m3g">Light</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/microedition/m3g/Graphics3D.html#getLight(int, javax.microedition.m3g.Transform)">getLight</A></B>(int&nbsp;index,
         <A HREF="../../../javax/microedition/m3g/Transform.html" title="class in javax.microedition.m3g">Transform</A>&nbsp;transform)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="new">Returns a light in the current light array.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/microedition/m3g/Graphics3D.html#getLightCount()">getLightCount</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="new">Returns the size of the current light array.
 </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.util.Hashtable</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/microedition/m3g/Graphics3D.html#getProperties()">getProperties</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Retrieves implementation specific properties. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.Object</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/microedition/m3g/Graphics3D.html#getTarget()">getTarget</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="new">Returns the current rendering target.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/microedition/m3g/Graphics3D.html#getViewportHeight()">getViewportHeight</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="new">Returns the height of the viewport.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/microedition/m3g/Graphics3D.html#getViewportWidth()">getViewportWidth</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="new">Returns the width of the viewport.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/microedition/m3g/Graphics3D.html#getViewportX()">getViewportX</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="new">Returns the horizontal position of the
 viewport.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/microedition/m3g/Graphics3D.html#getViewportY()">getViewportY</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="new">Returns the vertical position of the viewport.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/microedition/m3g/Graphics3D.html#isDepthBufferEnabled()">isDepthBufferEnabled</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="new">Queries whether depth buffering is enabled for
 the current rendering target. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/microedition/m3g/Graphics3D.html#releaseTarget()">releaseTarget</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Flushes the rendered 3D image to the currently bound target and
 then releases the target. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/microedition/m3g/Graphics3D.html#render(javax.microedition.m3g.Node, javax.microedition.m3g.Transform)">render</A></B>(<A HREF="../../../javax/microedition/m3g/Node.html" title="class in javax.microedition.m3g">Node</A>&nbsp;node,
       <A HREF="../../../javax/microedition/m3g/Transform.html" title="class in javax.microedition.m3g">Transform</A>&nbsp;transform)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Renders the given Sprite3D, Mesh, or Group node with the given
 transformation from local coordinates to world coordinates. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/microedition/m3g/Graphics3D.html#render(javax.microedition.m3g.VertexBuffer, javax.microedition.m3g.IndexBuffer, javax.microedition.m3g.Appearance, javax.microedition.m3g.Transform)">render</A></B>(<A HREF="../../../javax/microedition/m3g/VertexBuffer.html" title="class in javax.microedition.m3g">VertexBuffer</A>&nbsp;vertices,
       <A HREF="../../../javax/microedition/m3g/IndexBuffer.html" title="class in javax.microedition.m3g">IndexBuffer</A>&nbsp;triangles,
       <A HREF="../../../javax/microedition/m3g/Appearance.html" title="class in javax.microedition.m3g">Appearance</A>&nbsp;appearance,
       <A HREF="../../../javax/microedition/m3g/Transform.html" title="class in javax.microedition.m3g">Transform</A>&nbsp;transform)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Renders the given submesh with the given transformation from
 local coordinates to world coordinates. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/microedition/m3g/Graphics3D.html#render(javax.microedition.m3g.VertexBuffer, javax.microedition.m3g.IndexBuffer, javax.microedition.m3g.Appearance, javax.microedition.m3g.Transform, int)">render</A></B>(<A HREF="../../../javax/microedition/m3g/VertexBuffer.html" title="class in javax.microedition.m3g">VertexBuffer</A>&nbsp;vertices,
       <A HREF="../../../javax/microedition/m3g/IndexBuffer.html" title="class in javax.microedition.m3g">IndexBuffer</A>&nbsp;triangles,
       <A HREF="../../../javax/microedition/m3g/Appearance.html" title="class in javax.microedition.m3g">Appearance</A>&nbsp;appearance,
       <A HREF="../../../javax/microedition/m3g/Transform.html" title="class in javax.microedition.m3g">Transform</A>&nbsp;transform,
       int&nbsp;scope)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Renders the given submesh with the given scope and the given
 transformation from local coordinates to world coordinates.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/microedition/m3g/Graphics3D.html#render(javax.microedition.m3g.World)">render</A></B>(<A HREF="../../../javax/microedition/m3g/World.html" title="class in javax.microedition.m3g">World</A>&nbsp;world)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Renders an image of <code>world</code> as viewed by the
 active camera of that World. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/microedition/m3g/Graphics3D.html#resetLights()">resetLights</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Clears the array of current Lights.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/microedition/m3g/Graphics3D.html#setCamera(javax.microedition.m3g.Camera, javax.microedition.m3g.Transform)">setCamera</A></B>(<A HREF="../../../javax/microedition/m3g/Camera.html" title="class in javax.microedition.m3g">Camera</A>&nbsp;camera,
          <A HREF="../../../javax/microedition/m3g/Transform.html" title="class in javax.microedition.m3g">Transform</A>&nbsp;transform)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the Camera to use in subsequent immediate mode rendering. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/microedition/m3g/Graphics3D.html#setDepthRange(float, float)">setDepthRange</A></B>(float&nbsp;near,
              float&nbsp;far)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Specifies the mapping of depth values from normalized device
 coordinates to window coordinates. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/microedition/m3g/Graphics3D.html#setLight(int, javax.microedition.m3g.Light, javax.microedition.m3g.Transform)">setLight</A></B>(int&nbsp;index,
         <A HREF="../../../javax/microedition/m3g/Light.html" title="class in javax.microedition.m3g">Light</A>&nbsp;light,
         <A HREF="../../../javax/microedition/m3g/Transform.html" title="class in javax.microedition.m3g">Transform</A>&nbsp;transform)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="new">Replaces or modifies a Light currently bound for
 immediate mode rendering. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/microedition/m3g/Graphics3D.html#setViewport(int, int, int, int)">setViewport</A></B>(int&nbsp;x,
            int&nbsp;y,
            int&nbsp;width,
            int&nbsp;height)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Specifies a rectangular viewport on the currently bound
 rendering target. </TD>
</TR>
</TABLE>
&nbsp;
&nbsp;
<P>

<!-- ============ FIELD DETAIL =========== -->

<A NAME="field_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=1><FONT SIZE="+2">
<B>Field Detail</B></FONT></TD>
</TR>
</TABLE>

<A NAME="ANTIALIAS"><!-- --></A><H3>
ANTIALIAS</H3>
<PRE>
public static final int <B>ANTIALIAS</B></PRE>
<DL>
<DD><p>A parameter to <code>bindTarget</code>, specifying that
 antialiasing should be turned on. The application may query
 from <code>getProperties</code> whether this hint is acted upon
 by the implementation.</p>
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#javax.microedition.m3g.Graphics3D.ANTIALIAS">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="DITHER"><!-- --></A><H3>
DITHER</H3>
<PRE>
public static final int <B>DITHER</B></PRE>
<DL>
<DD><p>A parameter to <code>bindTarget</code>, specifying that
 dithering should be turned on. The application may query from
 <code>getProperties</code> whether this hint is acted upon by
 the implementation.</p>
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#javax.microedition.m3g.Graphics3D.DITHER">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="TRUE_COLOR"><!-- --></A><H3>
TRUE_COLOR</H3>
<PRE>
public static final int <B>TRUE_COLOR</B></PRE>
<DL>
<DD><p>A parameter to <code>bindTarget</code>, specifying that true
 color rendering should be turned on. The application may query
 from <code>getProperties</code> whether this hint is acted upon
 by the implementation.</p>
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#javax.microedition.m3g.Graphics3D.TRUE_COLOR">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="OVERWRITE"><!-- --></A><H3>
OVERWRITE</H3>
<PRE>
public static final int <B>OVERWRITE</B></PRE>
<DL>
<DD><span class="new">A parameter to <code>bindTarget</code>,
 specifying that the existing contents of the rendering target
 need not be preserved. This can improve performance in
 applications that fully overwrite the rendering target without
 necessarily clearing it first.</span>
<P>
<DL>
<DT><B>Since:</B></DT>
  <DD><span class="new">M3G 1.1</span></DD>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#javax.microedition.m3g.Graphics3D.OVERWRITE">Constant Field Values</A></DL>
</DL>

<!-- ========= CONSTRUCTOR DETAIL ======== -->


<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=1><FONT SIZE="+2">
<B>Method Detail</B></FONT></TD>
</TR>
</TABLE>

<A NAME="getInstance()"><!-- --></A><H3>
getInstance</H3>
<PRE>
public static final <A HREF="../../../javax/microedition/m3g/Graphics3D.html" title="class in javax.microedition.m3g">Graphics3D</A> <B>getInstance</B>()</PRE>
<DL>
<DD><p>Retrieves the singleton Graphics3D instance that is associated with
 this application. The same instance will be returned every time.</p>

 <p>Initially, the state of the Graphics3D instance is as follows:</p>
 
 <ul>
 <li>viewport : undefined (reset at <code>bindTarget</code>)</li>
 <li>depth range : [0, 1]</li>
 <li>current camera : none</li>
 <li>current lights : none</li>
 </ul>
<P>
<DD><DL>

<DT><B>Returns:</B><DD>the Graphics3D instance associated with this application</DL>
</DD>
</DL>
<HR>

<A NAME="bindTarget(java.lang.Object)"><!-- --></A><H3>
bindTarget</H3>
<PRE>
public void <B>bindTarget</B>(java.lang.Object&nbsp;target)</PRE>
<DL>
<DD><p>Binds the given Graphics or mutable Image2D as the rendering target
 of this Graphics3D. The type of the Graphics object depends on the
 Java profile that this specification is implemented on, as follows:</p>
 
 <ul>
 <li><code>java.awt.Graphics</code> on profiles supporting AWT;</li>
 <li><code>javax.microedition.lcdui.Graphics</code> on profiles
     supporting LCDUI;</li>
 <li>either of the above on profiles supporting both AWT and LCDUI.</li>
 </ul>

 <p>The state of this Graphics3D after calling this method will be
 as follows:</p>
 
 <ul>
 <li>rendering target : the given Graphics or Image2D</li>
 <li class="new">viewport : covering the target clipping rectangle</li>
 <li>depth buffer : enabled</li>
 <li>antialiasing : disabled</li>
 <li>dithering : disabled</li>
 <li>true color : disabled</li>
 <li class="new">overwrite : disabled</li>
 <li>depth range : as before</li>
 <li>current camera : as before</li>
 <li>current lights : as before</li>
 </ul>

 <p class="new">The dimensions of the given target must
 not exceed the implementation-specific maximum viewport size,
 which can be queried with <code>getProperties</code>.
 The viewport is set such that its top left corner is at the top
 left corner of the target clipping rectangle, and its
 dimensions are equal to those of the clipping rectangle.
 </p>

 <p>Note that this method will not block waiting if another thread
 has already bound a rendering target to this Graphics3D. Instead,
 it will throw an exception. Only one target can be bound at a time,
 and it makes no difference whether that target has been bound from
 the current thread or some other thread.</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>target</CODE> - the Image2D or Graphics object to receive the rendered
        image
<DT><B>Throws:</B>
<DD><CODE>java.lang.NullPointerException</CODE> - if <code>target</code> is null
<DD><CODE>java.lang.IllegalStateException</CODE> - if this Graphics3D already has a
         rendering target
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if <code>target</code> is not
         a mutable Image2D object or a Graphics object appropriate
         to the underlying Java profile
<DD><CODE>java.lang.IllegalArgumentException</CODE> - <span class="new">if
         <code>(target.width &gt; maxViewportWidth) ||
         (target.height &gt; maxViewportHeight)</code></span>
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if <code>target</code> is an Image2D
         with an internal format other than <code>RGB</code> or
         <code>RGBA</code><DT><B>See Also:</B><DD><A HREF="../../../javax/microedition/m3g/Graphics3D.html#releaseTarget()"><CODE>releaseTarget</CODE></A>, 
<A HREF="../../../javax/microedition/m3g/Graphics3D.html#getHints()"><CODE><span class="new">getHints</span></CODE></A>, 
<A HREF="../../../javax/microedition/m3g/Graphics3D.html#isDepthBufferEnabled()"><CODE><span class="new">isDepthBufferEnabled</span></CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="bindTarget(java.lang.Object, boolean, int)"><!-- --></A><H3>
bindTarget</H3>
<PRE>
public void <B>bindTarget</B>(java.lang.Object&nbsp;target,
                       boolean&nbsp;depthBuffer,
                       int&nbsp;hints)</PRE>
<DL>
<DD><p>Binds the given Graphics or mutable Image2D as the rendering
 target of this Graphics3D. This method is identical to the
 simpler variant of <code>bindTarget</code>, but allows the
 depth buffering enable flag and the rendering hints to be
 specified. See the class description for more information on
 these.</p>

 <p>If the depth buffer is disabled, depth testing and depth writing
 are implicitly disabled for <i>all</i> objects, regardless of their
 individual CompositingMode settings.</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>target</CODE> - the Image2D or Graphics object to receive the
        rendered image<DD><CODE>depthBuffer</CODE> - <i>true</i> to enable depth buffering;
        <i>false</i> to disable<DD><CODE>hints</CODE> - an integer bitmask specifying which rendering
        hints to enable, or zero to disable all hints
<DT><B>Throws:</B>
<DD><CODE>java.lang.NullPointerException</CODE> - if <code>target</code> is null
<DD><CODE>java.lang.IllegalStateException</CODE> - if this Graphics3D already has a
         rendering target
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if <code>target</code> is not
         a mutable Image2D object or a Graphics object appropriate
         to the underlying Java profile
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if <code>target</code> is an Image2D
         with an internal format other than <code>RGB</code> or
         <code>RGBA</code>
<DD><CODE>java.lang.IllegalArgumentException</CODE> - <span class="new">if
         <code>(target.width &gt; maxViewportWidth) ||
         (target.height &gt; maxViewportHeight)</code></span>
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if <code>hints</code> is not zero
         or an OR bitmask of one or more of <code>ANTIALIAS, DITHER,
         TRUE_COLOR</code>, and <code>OVERWRITE</code><DT><B>See Also:</B><DD><A HREF="../../../javax/microedition/m3g/Graphics3D.html#releaseTarget()"><CODE>releaseTarget</CODE></A>, 
<A HREF="../../../javax/microedition/m3g/Graphics3D.html#getHints()"><CODE><span class="new">getHints</span></CODE></A>, 
<A HREF="../../../javax/microedition/m3g/Graphics3D.html#isDepthBufferEnabled()"><CODE><span class="new">isDepthBufferEnabled</span></CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="releaseTarget()"><!-- --></A><H3>
releaseTarget</H3>
<PRE>
public void <B>releaseTarget</B>()</PRE>
<DL>
<DD><p>Flushes the rendered 3D image to the currently bound target and
 then releases the target. This ensures that the 3D image is actually
 made visible on the target that was set in <code>bindTarget</code>.
 Otherwise, the image may or may not become visible.
 <span class="new">If no target is bound, the request to release the
 target is silently ignored.</span></p>
<P>
<DD><DL>
<DT><B>See Also:</B><DD><A HREF="../../../javax/microedition/m3g/Graphics3D.html#bindTarget(java.lang.Object)"><CODE>bindTarget</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="getTarget()"><!-- --></A><H3>
getTarget</H3>
<PRE>
public java.lang.Object <B>getTarget</B>()</PRE>
<DL>
<DD><span class="new">Returns the current rendering target.</span>
<P>
<DD><DL>

<DT><B>Returns:</B><DD><span class="new">the currently bound rendering target, or
 <code>null</code> if no target is bound</span><DT><B>Since:</B></DT>
  <DD><span class="new">M3G 1.1</span></DD>
<DT><B>See Also:</B><DD><A HREF="../../../javax/microedition/m3g/Graphics3D.html#bindTarget(java.lang.Object)"><CODE><span class="new">bindTarget</span></CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="getHints()"><!-- --></A><H3>
getHints</H3>
<PRE>
public int <B>getHints</B>()</PRE>
<DL>
<DD><span class="new">Returns the rendering hints given for the
 current rendering target. If no target is bound, the return
 value is undefined.</span>

 <p class="new">Note that the return value is the hint bitmask
 set by the application, even if the implementation is not
 acting upon all of the hints in it.</p>
<P>
<DD><DL>

<DT><B>Returns:</B><DD><span class="new">the current rendering hint bitmask</span><DT><B>Since:</B></DT>
  <DD><span class="new">M3G 1.1</span></DD>
<DT><B>See Also:</B><DD><A HREF="../../../javax/microedition/m3g/Graphics3D.html#bindTarget(java.lang.Object)"><CODE><span class="new">bindTarget</span></CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="isDepthBufferEnabled()"><!-- --></A><H3>
isDepthBufferEnabled</H3>
<PRE>
public boolean <B>isDepthBufferEnabled</B>()</PRE>
<DL>
<DD><span class="new">Queries whether depth buffering is enabled for
 the current rendering target. If no target is bound, the return
 value is undefined.</span>
<P>
<DD><DL>

<DT><B>Returns:</B><DD><span class="new"><code>true</code> if depth buffering is
         enabled, <code>false</code> if not</span><DT><B>Since:</B></DT>
  <DD><span class="new">M3G 1.1</span></DD>
<DT><B>See Also:</B><DD><A HREF="../../../javax/microedition/m3g/Graphics3D.html#bindTarget(java.lang.Object)"><CODE><span class="new">bindTarget</span></CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="setViewport(int, int, int, int)"><!-- --></A><H3>
setViewport</H3>
<PRE>
public void <B>setViewport</B>(int&nbsp;x,
                        int&nbsp;y,
                        int&nbsp;width,
                        int&nbsp;height)</PRE>
<DL>
<DD><p>Specifies a rectangular viewport on the currently bound
 rendering target. The viewport is the area where the view of
 the current camera will appear. Any parts of the viewport that
 lie outside the boundaries of the target clipping rectangle are
 silently clipped off; however, this must simply discard the
 pixels without affecting projection. The viewport upper left
 corner (x, y) is given relative to the origin for a Graphics
 rendering target, or the upper left corner for an Image2D
 target. Refer to the class description for details.</p>

 <p>The viewport mapping transforms vertices from normalized device
 coordinates (x<sub>ndc</sub>, y<sub>ndc</sub>) to window coordinates
 (x<sub>w</sub>, y<sub>w</sub>) as follows:</p>

 <ul>
 x<sub>w</sub> = 0.5 x<sub>ndc</sub> w + o<sub>x</sub><br>
 y<sub>w</sub> = -0.5 y<sub>ndc</sub> h + o<sub>y</sub><br>
 </ul>

 <p>where w and h are the width and height of the viewport,
 specified in pixels, and (o<sub>x</sub>, o<sub>y</sub>) is the
 center of the viewport, also in pixels. The center of the
 viewport is obtained from the (x, y) coordinates of the top
 left corner as follows:</p>

 <ul>
 o<sub>x</sub> = x + 0.5 w<br>
 o<sub>y</sub> = y + 0.5 h<br>
 </ul>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>x</CODE> - X coordinate of the viewport upper left corner, in pixels<DD><CODE>y</CODE> - Y coordinate of the viewport upper left corner, in pixels<DD><CODE>width</CODE> - width of the viewport, in pixels<DD><CODE>height</CODE> - height of the viewport, in pixels
<DT><B>Throws:</B>
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if <code class="new">(width &lt;= 0)
         || (height &lt;= 0)</code> (note that <code>x</code> and
         <code>y</code> may have any value)
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if <code class="new">(width
         &gt; maxViewportWidth) || (height &gt; maxViewportHeight)</code><DT><B>See Also:</B><DD><A HREF="../../../javax/microedition/m3g/Graphics3D.html#bindTarget(java.lang.Object)"><CODE>bindTarget</CODE></A>, 
<A HREF="../../../javax/microedition/m3g/Graphics3D.html#getViewportX()"><CODE><span class="new">getViewportX</span></CODE></A>, 
<A HREF="../../../javax/microedition/m3g/Graphics3D.html#getViewportY()"><CODE><span class="new">getViewportY</span></CODE></A>, 
<A HREF="../../../javax/microedition/m3g/Graphics3D.html#getViewportWidth()"><CODE><span class="new">getViewportWidth</span></CODE></A>, 
<A HREF="../../../javax/microedition/m3g/Graphics3D.html#getViewportHeight()"><CODE><span class="new">getViewportHeight</span></CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="getViewportX()"><!-- --></A><H3>
getViewportX</H3>
<PRE>
public int <B>getViewportX</B>()</PRE>
<DL>
<DD><span class="new">Returns the horizontal position of the
 viewport.</span>
<P>
<DD><DL>

<DT><B>Returns:</B><DD><span class="new">the X coordinate of the upper left
         corner, in pixels</span><DT><B>Since:</B></DT>
  <DD><span class="new">M3G 1.1</span></DD>
<DT><B>See Also:</B><DD><A HREF="../../../javax/microedition/m3g/Graphics3D.html#setViewport(int, int, int, int)"><CODE><span class="new">setViewport</span></CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="getViewportY()"><!-- --></A><H3>
getViewportY</H3>
<PRE>
public int <B>getViewportY</B>()</PRE>
<DL>
<DD><span class="new">Returns the vertical position of the viewport.</span>
<P>
<DD><DL>

<DT><B>Returns:</B><DD><span class="new">the Y coordinate of the upper left corner,
         in pixels</span><DT><B>Since:</B></DT>
  <DD><span class="new">M3G 1.1</span></DD>
<DT><B>See Also:</B><DD><A HREF="../../../javax/microedition/m3g/Graphics3D.html#setViewport(int, int, int, int)"><CODE><span class="new">setViewport</span></CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="getViewportWidth()"><!-- --></A><H3>
getViewportWidth</H3>
<PRE>
public int <B>getViewportWidth</B>()</PRE>
<DL>
<DD><span class="new">Returns the width of the viewport.</span>
<P>
<DD><DL>

<DT><B>Returns:</B><DD><span class="new">the width of the viewport, in pixels</span><DT><B>Since:</B></DT>
  <DD><span class="new">M3G 1.1</span></DD>
<DT><B>See Also:</B><DD><A HREF="../../../javax/microedition/m3g/Graphics3D.html#setViewport(int, int, int, int)"><CODE><span class="new">setViewport</span></CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="getViewportHeight()"><!-- --></A><H3>
getViewportHeight</H3>
<PRE>
public int <B>getViewportHeight</B>()</PRE>
<DL>
<DD><span class="new">Returns the height of the viewport.</span>
<P>
<DD><DL>

<DT><B>Returns:</B><DD><span class="new">the height of the viewport, in pixels</span><DT><B>Since:</B></DT>
  <DD><span class="new">M3G 1.1</span></DD>
<DT><B>See Also:</B><DD><A HREF="../../../javax/microedition/m3g/Graphics3D.html#setViewport(int, int, int, int)"><CODE><span class="new">setViewport</span></CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="setDepthRange(float, float)"><!-- --></A><H3>
setDepthRange</H3>
<PRE>
public void <B>setDepthRange</B>(float&nbsp;near,
                          float&nbsp;far)</PRE>
<DL>
<DD><p>Specifies the mapping of depth values from normalized device
 coordinates to window coordinates. Window coordinates are used
 for depth buffering.</p>
 
 <p>Depth values may range from -1 to 1 in normalized device
 coordinates (NDC), and from 0 to 1 in window coordinates. By
 default, the whole [0, 1] range of window coordinates is
 used. This method allows the normalized device coordinates [-1,
 1] to be mapped to a "tighter" interval of window coordinates,
 for example, (0.5, 1].</p>

 <p>Formally, the Z coordinate of a vertex in NDC, z<sub>ndc</sub>,
 is transformed to window coordinates (z<sub>w</sub>) as follows:</p>

 <ul>
 z<sub>w</sub> = 0.5 (far - near) (z<sub>ndc</sub> + 1) + near
 </ul>

 <p>where <code>near</code> and <code>far</code> are the distances,
 in window coordinates, to the near and far plane of the depth range,
 respectively. Both distances must be in [0, 1]. However, it is not
 necessary for the near plane to be closer than the far plane; inverse
 mappings are also acceptable.</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>near</CODE> - distance to the near clipping plane, in window coordinates<DD><CODE>far</CODE> - distance to the far clipping plane, in window coordinates
<DT><B>Throws:</B>
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if <code>(near &lt; 0) ||
         (near &gt; 1)</code>
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if <code>(far &lt; 0) ||
         (far &gt; 1)</code><DT><B>See Also:</B><DD><A HREF="../../../javax/microedition/m3g/Graphics3D.html#getDepthRangeNear()"><CODE><span class="new">getDepthRangeNear</span></CODE></A>, 
<A HREF="../../../javax/microedition/m3g/Graphics3D.html#getDepthRangeFar()"><CODE><span class="new">getDepthRangeFar</span></CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="getDepthRangeNear()"><!-- --></A><H3>
getDepthRangeNear</H3>
<PRE>
public float <B>getDepthRangeNear</B>()</PRE>
<DL>
<DD><span class="new">Returns the near distance of the depth range.</span>
<P>
<DD><DL>

<DT><B>Returns:</B><DD><span class="new">distance to the near clipping plane, in
         window coordinates</span><DT><B>Since:</B></DT>
  <DD><span class="new">M3G 1.1</span></DD>
<DT><B>See Also:</B><DD><A HREF="../../../javax/microedition/m3g/Graphics3D.html#setDepthRange(float, float)"><CODE><span class="new">setDepthRange</span></CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="getDepthRangeFar()"><!-- --></A><H3>
getDepthRangeFar</H3>
<PRE>
public float <B>getDepthRangeFar</B>()</PRE>
<DL>
<DD><span class="new">Returns the far distance of the depth range.</span>
<P>
<DD><DL>

<DT><B>Returns:</B><DD><span class="new">distance to the far clipping plane, in
         window coordinates</span><DT><B>Since:</B></DT>
  <DD><span class="new">M3G 1.1</span></DD>
<DT><B>See Also:</B><DD><A HREF="../../../javax/microedition/m3g/Graphics3D.html#setDepthRange(float, float)"><CODE><span class="new">setDepthRange</span></CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="clear(javax.microedition.m3g.Background)"><!-- --></A><H3>
clear</H3>
<PRE>
public void <B>clear</B>(<A HREF="../../../javax/microedition/m3g/Background.html" title="class in javax.microedition.m3g">Background</A>&nbsp;background)</PRE>
<DL>
<DD><p>Clears the viewport as specified in the given Background object. If
 the background object is null, the default settings are used. That is,
 the color buffer is cleared to transparent black, and the depth buffer
 to the maximum depth value (1.0).</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>background</CODE> - a Background object defining which buffers to clear
        and how, or null to use the default settings
<DT><B>Throws:</B>
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if the background image in
         <code>background</code> is not in the same format as
         the currently bound rendering target
<DD><CODE>java.lang.IllegalStateException</CODE> - if this Graphics3D does not have a
         rendering target</DL>
</DD>
</DL>
<HR>

<A NAME="render(javax.microedition.m3g.World)"><!-- --></A><H3>
render</H3>
<PRE>
public void <B>render</B>(<A HREF="../../../javax/microedition/m3g/World.html" title="class in javax.microedition.m3g">World</A>&nbsp;world)</PRE>
<DL>
<DD><p>Renders an image of <code>world</code> as viewed by the
 active camera of that World. The node transformation of the
 World is ignored, but its other attributes are respected.</p>

 <p>Contrary to the immediate mode <code>render</code> variants,
 this method automatically clears the color buffer and the depth
 buffer according to the Background settings of the World.</p>

 <p>Prior to rendering, the current camera and lights set in this
 Graphics3D are automatically overwritten with the active camera
 and lights of the World. Upon method return, the lights array
 will contain precisely those Light nodes whose effective rendering
 enable flag is <i>true</i> (see <A HREF="../../../javax/microedition/m3g/Node.html#setRenderingEnable(boolean)"><CODE>Node.setRenderingEnable</CODE></A>).
 The Lights are written to the array in undefined order, but such
 that the first Light is at index 0 and there are no empty slots
 interleaved within non-empty slots. <span class="new">As usual,
 the Camera and Light transformations will be from their local
 coordinates to world coordinates (i.e., the coordinate system of
 <code>world</code>). In other words, the Camera and Lights are
 effectively set up as follows:</span></p>

 <ul class="new"><pre>
 Camera c = world.getActiveCamera();
 myG3D.setCamera(c, c.getTransformTo(world));
 myG3D.resetLights();
 for (&lt;all enabled Lights l in world&gt;) {
    myG3D.addLight(l, l.getTransformTo(world));
 }</pre>
 </ul>

 <p>For any node that is rendered, if the transformation from that
 node's local coordinates to the camera space is not invertible,
 the results of lighting and fogging are undefined.</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>world</CODE> - the World to render
<DT><B>Throws:</B>
<DD><CODE>java.lang.NullPointerException</CODE> - if <code>world</code> is null
<DD><CODE>java.lang.IllegalStateException</CODE> - if this Graphics3D does not have a
         rendering target
<DD><CODE>java.lang.IllegalStateException</CODE> - if <code>world</code> has no active
         camera, or the active camera is not in that world
<DD><CODE>java.lang.IllegalStateException</CODE> - if the background image of
         <code>world</code> is not in the same format as the
         currently bound rendering target
<DD><CODE>java.lang.IllegalStateException</CODE> - if any Mesh that is rendered violates
         the constraints defined in Mesh, MorphingMesh, SkinnedMesh,
         VertexBuffer, or IndexBuffer
<DD><CODE>java.lang.ArithmeticException</CODE> - if the transformation from the
         active camera of <code>world</code> to the world
         space is uninvertible</DL>
</DD>
</DL>
<HR>

<A NAME="render(javax.microedition.m3g.Node, javax.microedition.m3g.Transform)"><!-- --></A><H3>
render</H3>
<PRE>
public void <B>render</B>(<A HREF="../../../javax/microedition/m3g/Node.html" title="class in javax.microedition.m3g">Node</A>&nbsp;node,
                   <A HREF="../../../javax/microedition/m3g/Transform.html" title="class in javax.microedition.m3g">Transform</A>&nbsp;transform)</PRE>
<DL>
<DD><p>Renders the given Sprite3D, Mesh, or Group node with the given
 transformation from local coordinates to world coordinates. The
 node transformation of the given node is ignored, but its other
 attributes are respected.</p>
 
 <p>Any ancestors of the given node are ignored, as well as their
 transformations and other attributes. The node's descendants, if
 any, are rendered as usual. However, any Camera and Light nodes
 among the descendants are ignored and the camera and lights of
 this Graphics3D are used instead.</p>
 
 <p>The scope masks of the current Lights and Camera are respected,
 as well as the rendering enable flags of the Lights. The rendering
 enable flag of the Camera is ignored, as always.</p>

 <p>Note that Mesh nodes include MorphingMesh and SkinnedMesh nodes,
 and that Group nodes include World nodes. If a World is passed to
 this method, it is simply treated like any other Group and therefore
 any Background, Camera and Light objects it may have are ignored.</p>

 <p>This method does <i>not</i> clear the color and depth buffers;
 the application must explicitly clear them with the <A HREF="../../../javax/microedition/m3g/Graphics3D.html#clear(javax.microedition.m3g.Background)"><CODE>clear</CODE></A> method and/or draw any background graphics beforehand.</p>

 <p>For any node that is rendered, if the transformation from that
 node's local coordinates to the camera space is not invertible, the
 results of lighting and fogging are undefined.</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>node</CODE> - the Sprite3D, Mesh, or Group to render<DD><CODE>transform</CODE> - the transformation from the local coordinate
        system of <code>node</code> to world space, or null to
        indicate the identity matrix
<DT><B>Throws:</B>
<DD><CODE>java.lang.NullPointerException</CODE> - if <code>node</code> is null
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if <code>node</code> is not a
         Sprite3D, Mesh, or Group
<DD><CODE>java.lang.IllegalStateException</CODE> - if this Graphics3D does not have
         a rendering target
<DD><CODE>java.lang.IllegalStateException</CODE> - if this Graphics3D does not have
         a current camera
<DD><CODE>java.lang.IllegalStateException</CODE> - if any Mesh that is rendered violates
         the constraints defined in Mesh, MorphingMesh, SkinnedMesh,
         VertexBuffer, or IndexBuffer</DL>
</DD>
</DL>
<HR>

<A NAME="render(javax.microedition.m3g.VertexBuffer, javax.microedition.m3g.IndexBuffer, javax.microedition.m3g.Appearance, javax.microedition.m3g.Transform, int)"><!-- --></A><H3>
render</H3>
<PRE>
public void <B>render</B>(<A HREF="../../../javax/microedition/m3g/VertexBuffer.html" title="class in javax.microedition.m3g">VertexBuffer</A>&nbsp;vertices,
                   <A HREF="../../../javax/microedition/m3g/IndexBuffer.html" title="class in javax.microedition.m3g">IndexBuffer</A>&nbsp;triangles,
                   <A HREF="../../../javax/microedition/m3g/Appearance.html" title="class in javax.microedition.m3g">Appearance</A>&nbsp;appearance,
                   <A HREF="../../../javax/microedition/m3g/Transform.html" title="class in javax.microedition.m3g">Transform</A>&nbsp;transform,
                   int&nbsp;scope)</PRE>
<DL>
<DD><p>Renders the given submesh with the given scope and the given
 transformation from local coordinates to world coordinates.</p>

 <p>The scope masks of the current Lights and Camera are respected,
 as well as the rendering enable flags of the Lights. The rendering
 enable flag of the Camera is ignored, as always.</p>

 <p>If the transformation from local coordinates to the camera
 space is not invertible, the results of lighting and fogging
 are undefined.</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>vertices</CODE> - a VertexBuffer defining the vertex attributes<DD><CODE>triangles</CODE> - an IndexBuffer defining the triangle strips<DD><CODE>appearance</CODE> - an Appearance defining the surface properties<DD><CODE>transform</CODE> - the transformation from the local coordinate system of
        <code>vertices</code> to world space, or null to indicate the
        identity matrix<DD><CODE>scope</CODE> - the scope of the submesh; this determines whether the
        submesh is rendered at all, and if it is, which lights are
        used; "-1" makes the scope as wide as possible
<DT><B>Throws:</B>
<DD><CODE>java.lang.NullPointerException</CODE> - if <code>vertices</code> is null
<DD><CODE>java.lang.NullPointerException</CODE> - if <code>triangles</code> is null
<DD><CODE>java.lang.NullPointerException</CODE> - if <code>appearance</code> is null
<DD><CODE>java.lang.IllegalStateException</CODE> - if this Graphics3D does not have
         a rendering target
<DD><CODE>java.lang.IllegalStateException</CODE> - if this Graphics3D does not have
         a current camera
<DD><CODE>java.lang.IllegalStateException</CODE> - if <code>vertices</code> or
         <code>triangles</code> violates the constraints defined
         in VertexBuffer or IndexBuffer</DL>
</DD>
</DL>
<HR>

<A NAME="render(javax.microedition.m3g.VertexBuffer, javax.microedition.m3g.IndexBuffer, javax.microedition.m3g.Appearance, javax.microedition.m3g.Transform)"><!-- --></A><H3>
render</H3>
<PRE>
public void <B>render</B>(<A HREF="../../../javax/microedition/m3g/VertexBuffer.html" title="class in javax.microedition.m3g">VertexBuffer</A>&nbsp;vertices,
                   <A HREF="../../../javax/microedition/m3g/IndexBuffer.html" title="class in javax.microedition.m3g">IndexBuffer</A>&nbsp;triangles,
                   <A HREF="../../../javax/microedition/m3g/Appearance.html" title="class in javax.microedition.m3g">Appearance</A>&nbsp;appearance,
                   <A HREF="../../../javax/microedition/m3g/Transform.html" title="class in javax.microedition.m3g">Transform</A>&nbsp;transform)</PRE>
<DL>
<DD><p>Renders the given submesh with the given transformation from
 local coordinates to world coordinates. This method is exactly
 the same as the other submesh rendering method, except that the
 scope is implicitly set to -1 (the widest possible).</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>vertices</CODE> - a VertexBuffer defining the vertex attributes<DD><CODE>triangles</CODE> - an IndexBuffer defining the triangle strips<DD><CODE>appearance</CODE> - an Appearance defining the surface properties<DD><CODE>transform</CODE> - the transformation from the local coordinate system of
        <code>vertices</code> to world space, or null to indicate the
        identity matrix
<DT><B>Throws:</B>
<DD><CODE>java.lang.NullPointerException</CODE> - if <code>vertices</code> is null
<DD><CODE>java.lang.NullPointerException</CODE> - if <code>triangles</code> is null
<DD><CODE>java.lang.NullPointerException</CODE> - if <code>appearance</code> is null
<DD><CODE>java.lang.IllegalStateException</CODE> - if this Graphics3D does not have
         a rendering target
<DD><CODE>java.lang.IllegalStateException</CODE> - if this Graphics3D does not have
         a current camera
<DD><CODE>java.lang.IllegalStateException</CODE> - if <code>vertices</code> or
         <code>triangles</code> violates the constraints defined
         in VertexBuffer or IndexBuffer</DL>
</DD>
</DL>
<HR>

<A NAME="setCamera(javax.microedition.m3g.Camera, javax.microedition.m3g.Transform)"><!-- --></A><H3>
setCamera</H3>
<PRE>
public void <B>setCamera</B>(<A HREF="../../../javax/microedition/m3g/Camera.html" title="class in javax.microedition.m3g">Camera</A>&nbsp;camera,
                      <A HREF="../../../javax/microedition/m3g/Transform.html" title="class in javax.microedition.m3g">Transform</A>&nbsp;transform)</PRE>
<DL>
<DD><p>Sets the Camera to use in subsequent immediate mode rendering. The
 given transformation is from the Camera's local coordinate system
 (camera space) to the world space. The transformation is copied in,
 so any further changes to it will not be reflected in this Graphics3D.
 The node transformation of the Camera is ignored. If the Camera has
 any ancestors, they are also ignored.</p>

 <p>The scope of the Camera is respected when rendering. The rendering
 enable flag of the Camera is ignored, as always.</p>
 
 <p>The given camera-to-world transformation must be invertible in
 order that the model-to-camera (or "modelview") transformation for
 each rendered object and light source can be computed.</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>camera</CODE> - the Camera to bind for immediate mode rendering, or null
        to unbind the current camera<DD><CODE>transform</CODE> - the transformation from the local coordinate system of
        <code>camera</code> to world space, or null to indicate the
        identity matrix
<DT><B>Throws:</B>
<DD><CODE>java.lang.ArithmeticException</CODE> - if <code>transform</code> is not invertible<DT><B>See Also:</B><DD><A HREF="../../../javax/microedition/m3g/Graphics3D.html#getCamera(javax.microedition.m3g.Transform)"><CODE><span class="new">getCamera</span></CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="getCamera(javax.microedition.m3g.Transform)"><!-- --></A><H3>
getCamera</H3>
<PRE>
public <A HREF="../../../javax/microedition/m3g/Camera.html" title="class in javax.microedition.m3g">Camera</A> <B>getCamera</B>(<A HREF="../../../javax/microedition/m3g/Transform.html" title="class in javax.microedition.m3g">Transform</A>&nbsp;transform)</PRE>
<DL>
<DD><span class="new">Returns the current camera.</span>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>transform</CODE> - <span class="new">a Transform to store the
 current camera transformation in, or <code>null</code> to
 only get the camera</span>
<DT><B>Returns:</B><DD><span class="new">the current camera</span><DT><B>Since:</B></DT>
  <DD><span class="new">M3G 1.1</span></DD>
<DT><B>See Also:</B><DD><A HREF="../../../javax/microedition/m3g/Graphics3D.html#setCamera(javax.microedition.m3g.Camera, javax.microedition.m3g.Transform)"><CODE><span class="new">setCamera</span></CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="addLight(javax.microedition.m3g.Light, javax.microedition.m3g.Transform)"><!-- --></A><H3>
addLight</H3>
<PRE>
public int <B>addLight</B>(<A HREF="../../../javax/microedition/m3g/Light.html" title="class in javax.microedition.m3g">Light</A>&nbsp;light,
                    <A HREF="../../../javax/microedition/m3g/Transform.html" title="class in javax.microedition.m3g">Transform</A>&nbsp;transform)</PRE>
<DL>
<DD><p>Binds a Light to use in subsequent immediate mode rendering.
 <span class="new">The Light is inserted at the end of the
 current lights array, regardless of whether there are empty
 (null) slots at lower indices.</span> The index of the slot in
 which the Light is inserted is returned to the application.
 The returned indices are guaranteed to be strictly increasing,
 until <code>render(World)</code> or <code>resetLights</code> is
 called.</p>

 <p class="new">The given transformation is from the Light's
 local coordinate system to the world space. Note that the
 transformation need not be invertible.  The transformation is
 copied in, so any further changes to it will not be reflected
 in this Graphics3D. The node transformation of the Light is
 ignored. If the Light has any ancestors, they are also
 ignored.</p>

 <p class="new">Note that the complete transformation is not
 required for performing lighting computations.  Implementations
 may therefore opt to store only the required parts of it.</p>
 
 <p>The index of the added Light is guaranteed to remain the same
 until the light is either removed using <code>setLight</code>, or
 the lights array is overwritten by <code>render(World)</code>, or
 the array is explicitly cleared with <code>resetLights</code>.</p>

 <p class="new">The scope and rendering enable flag of the Light
 are respected when rendering. This enables selection of subsets
 of the current light array without repeatedly resetting the
 light array.</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>light</CODE> - the Light to add at the end of the array of current lights<DD><CODE>transform</CODE> - the transformation from the local coordinate system
        of <code>light</code> to world space, or null to indicate the
        identity matrix
<DT><B>Returns:</B><DD>the index at which the Light was inserted in the array
<DT><B>Throws:</B>
<DD><CODE>java.lang.NullPointerException</CODE> - if <code>light</code> is null<DT><B>See Also:</B><DD><A HREF="../../../javax/microedition/m3g/Graphics3D.html#setLight(int, javax.microedition.m3g.Light, javax.microedition.m3g.Transform)"><CODE>setLight</CODE></A>, 
<A HREF="../../../javax/microedition/m3g/Graphics3D.html#getLight(int, javax.microedition.m3g.Transform)"><CODE><span class="new">getLight</span></CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="setLight(int, javax.microedition.m3g.Light, javax.microedition.m3g.Transform)"><!-- --></A><H3>
setLight</H3>
<PRE>
public void <B>setLight</B>(int&nbsp;index,
                     <A HREF="../../../javax/microedition/m3g/Light.html" title="class in javax.microedition.m3g">Light</A>&nbsp;light,
                     <A HREF="../../../javax/microedition/m3g/Transform.html" title="class in javax.microedition.m3g">Transform</A>&nbsp;transform)</PRE>
<DL>
<DD><span class="new">Replaces or modifies a Light currently bound for
 immediate mode rendering. This is similar to addLight, except
 that an existing light is replaced and the size of the light
 array does not change.</span>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>index</CODE> - index of the light to set<DD><CODE>light</CODE> - the Light to set, or null to remove the light at
        <code>index</code><DD><CODE>transform</CODE> - the transformation from the local coordinate system
        of <code>light</code> to world space, or null to indicate the
        identity matrix
<DT><B>Throws:</B>
<DD><CODE>java.lang.IndexOutOfBoundsException</CODE> - if <code>(index &lt; 0) || (index
         &gt;= <span class="new">getLightCount</span>)</code><DT><B>See Also:</B><DD><A HREF="../../../javax/microedition/m3g/Graphics3D.html#addLight(javax.microedition.m3g.Light, javax.microedition.m3g.Transform)"><CODE>addLight</CODE></A>, 
<A HREF="../../../javax/microedition/m3g/Graphics3D.html#getLight(int, javax.microedition.m3g.Transform)"><CODE><span class="new">getLight</span></CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="resetLights()"><!-- --></A><H3>
resetLights</H3>
<PRE>
public void <B>resetLights</B>()</PRE>
<DL>
<DD><p>Clears the array of current Lights.</p>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getLightCount()"><!-- --></A><H3>
getLightCount</H3>
<PRE>
public int <B>getLightCount</B>()</PRE>
<DL>
<DD><span class="new">Returns the size of the current light array.
 This includes actual lights as well as any empty slots in the
 array.</span>
<P>
<DD><DL>

<DT><B>Returns:</B><DD><span class="new">the number of slots in the current
         light array</span><DT><B>Since:</B></DT>
  <DD><span class="new">M3G 1.1</span></DD>
<DT><B>See Also:</B><DD><A HREF="../../../javax/microedition/m3g/Graphics3D.html#addLight(javax.microedition.m3g.Light, javax.microedition.m3g.Transform)"><CODE><span class="new">addLight</span></CODE></A>, 
<A HREF="../../../javax/microedition/m3g/Graphics3D.html#setLight(int, javax.microedition.m3g.Light, javax.microedition.m3g.Transform)"><CODE><span class="new">setLight</span></CODE></A>, 
<A HREF="../../../javax/microedition/m3g/Graphics3D.html#getLight(int, javax.microedition.m3g.Transform)"><CODE><span class="new">getLight</span></CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="getLight(int, javax.microedition.m3g.Transform)"><!-- --></A><H3>
getLight</H3>
<PRE>
public <A HREF="../../../javax/microedition/m3g/Light.html" title="class in javax.microedition.m3g">Light</A> <B>getLight</B>(int&nbsp;index,
                      <A HREF="../../../javax/microedition/m3g/Transform.html" title="class in javax.microedition.m3g">Transform</A>&nbsp;transform)</PRE>
<DL>
<DD><span class="new">Returns a light in the current light array.</span>

 <p class="new">Note that implementations are not required to
 store the complete light transformation passed in
 <code>addLight</code> or <code>setLight</code>.  The returned
 transformation may therefore be different from the
 transformation passed in, but must produce the same
 lighting.</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>index</CODE> - <span class="new">index of the light to get</span><DD><CODE>transform</CODE> - <span class="new">transform to store the light
        transformation in, or <code>null</code> to only get the
        Light object</span>
<DT><B>Returns:</B><DD><span class="new">the light object at <code>index</code></span>
<DT><B>Throws:</B>
<DD><CODE>java.lang.IndexOutOfBoundsException</CODE> - <span class="new">if
         <code>(index &lt; 0) ||
         (index &gt;= getLightCount)</code></span><DT><B>Since:</B></DT>
  <DD><span class="new">M3G 1.1</span></DD>
<DT><B>See Also:</B><DD><A HREF="../../../javax/microedition/m3g/Graphics3D.html#addLight(javax.microedition.m3g.Light, javax.microedition.m3g.Transform)"><CODE><span class="new">addLight</span></CODE></A>, 
<A HREF="../../../javax/microedition/m3g/Graphics3D.html#setLight(int, javax.microedition.m3g.Light, javax.microedition.m3g.Transform)"><CODE><span class="new">setLight</span></CODE></A>, 
<A HREF="../../../javax/microedition/m3g/Graphics3D.html#getLightCount()"><CODE><span class="new">getLightCount</span></CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="getProperties()"><!-- --></A><H3>
getProperties</H3>
<PRE>
public static final java.util.Hashtable <B>getProperties</B>()</PRE>
<DL>
<DD><p>Retrieves implementation specific properties. The properties
 are stored in a Hashtable that is keyed by String values. The
 Hashtable will always contain the entries listed in the table
 below, but there may also be other entries specific to each
 implementation.</p>

 <p>The third column shows for each property the baseline
 requirement that all implementations must satisfy. The actual
 value returned may be equal to or greater than the baseline
 requirement.</p>

 <table border cellpadding=3>
 <tr>
 <th>Key (String)</th>
 <th>Value type</th>
 <th>Minimum requirement</th>
 <th>Description</th>
 </tr>
 <tr>
 <td>supportAntialiasing</td>
 <td>Boolean</td>
 <td>false</td>
 <td>See <a href="#hints">above</a></td>
 </tr>
 <tr>
 <td>supportTrueColor</td>
 <td>Boolean</td>
 <td>false</td>
 <td>See <a href="#hints">above</a></td>
 </tr>
 <tr><td>supportDithering</td>
 <td>Boolean</td>
 <td>false</td>
 <td>See <a href="#hints">above</a></td>
 </tr>
 <tr>
 <td>supportMipmapping</td>
 <td>Boolean</td>
 <td>false</td>
 <td>See <a href="Texture2D.html#filtering">Texture2D</a></td>
 </tr>
 <tr>
 <td>supportPerspectiveCorrection</td>
 <td>Boolean</td>
 <td>false</td>
 <td>See <A HREF="../../../javax/microedition/m3g/PolygonMode.html" title="class in javax.microedition.m3g">PolygonMode</A></td>
 </tr>
 <tr>
 <td>supportLocalCameraLighting</td>
 <td>Boolean</td>
 <td>false</td>
 <td>See <A HREF="../../../javax/microedition/m3g/PolygonMode.html" title="class in javax.microedition.m3g">PolygonMode</A></td>
 </tr>
 <tr>
 <td>maxLights</td>
 <td>Integer</td>
 <td>8</td>
 <td>See <A HREF="../../../javax/microedition/m3g/Light.html" title="class in javax.microedition.m3g">Light</A></td>
 </tr>
 <tr class="new">
 <td>maxViewportWidth</td>
 <td>Integer</td>
 <td>256</td>
 <td>See <A HREF="../../../javax/microedition/m3g/Graphics3D.html#setViewport(int, int, int, int)">setViewport</A></td>
 </tr>
 <tr class="new">
 <td>maxViewportHeight</td>
 <td>Integer</td>
 <td>256</td>
 <td>See <A HREF="../../../javax/microedition/m3g/Graphics3D.html#setViewport(int, int, int, int)">setViewport</A></td>
 </tr>
 <tr>
 <td>maxViewportDimension</td>
 <td>Integer</td>
 <td>256</td>
 <td>The minimum of {maxViewportWidth, maxViewportHeight}</td>
 </tr>
 <tr>
 <td>maxTextureDimension</td>
 <td>Integer</td>
 <td>256</td>
 <td>See <A HREF="../../../javax/microedition/m3g/Texture2D.html" title="class in javax.microedition.m3g">Texture2D</A></td>
 </tr>
 <tr>
 <td>maxSpriteCropDimension</td>
 <td>Integer</td>
 <td>256</td>
 <td>See <A HREF="../../../javax/microedition/m3g/Sprite3D.html" title="class in javax.microedition.m3g">Sprite3D</A></td>
 </tr>
 <tr>
 <td>maxTransformsPerVertex</td>
 <td>Integer</td>
 <td>2</td>
 <td>See <A HREF="../../../javax/microedition/m3g/SkinnedMesh.html#addTransform(javax.microedition.m3g.Node, int, int, int)">SkinnedMesh</A></td>
 </tr>
 <tr>
 <td>numTextureUnits</td>
 <td>Integer</td>
 <td>1</td>
 <td>See <A HREF="../../../javax/microedition/m3g/Appearance.html" title="class in javax.microedition.m3g">Appearance</A></td>
 </tr>
 </table>
<P>
<DD><DL>

<DT><B>Returns:</B><DD>a Hashtable defining properties specific to this implementation</DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A>
<A HREF="#skip-navbar_bottom" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=3 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/Graphics3D.html"><FONT CLASS="NavBarFont1"><B>Use</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<EM><B>M3G 1.1 -- Jun 22, 2005</B></EM></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../javax/microedition/m3g/Fog.html" title="class in javax.microedition.m3g"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../../../javax/microedition/m3g/Group.html" title="class in javax.microedition.m3g"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../index.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="Graphics3D.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>

</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;<A HREF="#field_summary">FIELD</A>&nbsp;|&nbsp;CONSTR&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;<A HREF="#field_detail">FIELD</A>&nbsp;|&nbsp;CONSTR&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A>
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<HR>
<EM>Copyright &copy; 2005 Nokia Corporation. See the <a href="../../../overview-summary.html#Copyright">Copyright Notice</a> for details.</EM>
</BODY>
</HTML>
