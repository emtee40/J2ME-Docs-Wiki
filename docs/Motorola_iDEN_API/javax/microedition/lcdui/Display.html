<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN""http://www.w3.org/TR/REC-html40/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc on Thu Aug 14 16:48:24 GMT+08:00 2003 -->
<TITLE>
Display
</TITLE>
<META NAME="keywords" CONTENT="javax.microedition.lcdui.Display,Display class">
<LINK REL ="stylesheet" TYPE="text/css" HREF="../../../stylesheet.css" TITLE="Style">
</HEAD>
<SCRIPT>
function asd()
{
parent.document.title="Display";
}
</SCRIPT>
<BODY BGCOLOR="white" onload="asd();">

<!-- ========== START OF NAVBAR ========== -->
<A NAME="navbar_top"><!-- --></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0">
<TR>
<TD COLSPAN=3 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../javax/microedition/lcdui/DateField.html"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../../../javax/microedition/lcdui/Displayable.html"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../index.html" TARGET="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="Display.html" TARGET="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;
<SCRIPT>
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../allclasses-noframe.html" TARGET=""><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
<A HREF="../../../allclasses-noframe.html" TARGET=""><B>All Classes</B></A>
</NOSCRIPT>
</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;<A HREF="#field_summary">FIELD</A>&nbsp;|&nbsp;CONSTR&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;<A HREF="#field_detail">FIELD</A>&nbsp;|&nbsp;CONSTR&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<!-- =========== END OF NAVBAR =========== -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
javax.microedition.lcdui</FONT>
<BR>
Class Display</H2>
<PRE>
<A HREF="../../../java/lang/Object.html">java.lang.Object</A>
  |
  +--<B>javax.microedition.lcdui.Display</B>
</PRE>
<HR>
<DL>
<DT>public class <B>Display</B><DT>extends <A HREF="../../../java/lang/Object.html">Object</A></DL>

<P>
Display represents the manager of the display and input devices of
 the system. It includes methods for retrieving properties of the
 device and for requesting that objects be displayed on the device.
 Other methods that deal with device attributes are primarily used
 with <A HREF="../../../javax/microedition/lcdui/Canvas.html"><CODE>Canvas</CODE></A> objects and are thus defined there instead
 of here. <p>

 There is exactly one instance of Display per
 <A HREF="../../../javax/microedition/midlet/MIDlet.html"><CODE>MIDlet</CODE></A> and the application can get
 a reference to that instance by calling the
 <A HREF="../../../javax/microedition/lcdui/Display.html#getDisplay(javax.microedition.midlet.MIDlet)"><CODE>getDisplay()</CODE></A> method.
 The application may call the <tt>getDisplay()</tt> method from the beginning
 of the <A HREF="../../../javax/microedition/midlet/MIDlet.html#startApp()"><CODE>startApp()</CODE></A> call
 until the
 <A HREF="../../../javax/microedition/midlet/MIDlet.html#destroyApp(boolean)"><CODE>destroyApp()</CODE></A>
 call returns. The Display object returned by all calls to
 <tt>getDisplay()</tt> will remain the same during this time. <p>

 A typical application will perform the following actions in response to calls
 to its MIDlet methods: <UL>

 <LI><B><A HREF="../../../javax/microedition/midlet/MIDlet.html#startApp()"><CODE>startApp()</CODE></A></B>
 - the application is moving from the paused state to the active state.
 Initialization of objects needed while the application is
 active should be done. The application may call <A HREF="../../../javax/microedition/lcdui/Display.html#setCurrent(javax.microedition.lcdui.Displayable)"><CODE>setCurrent()</CODE></A> for the first screen if that
 has not already been done. Note that <tt>startApp()</tt> can be called
 several times, if <tt>pauseApp()</tt> is called in between. This means that
 one-time initialization should not take place here but instead should occur
 within the MIDlet's constructor. </LI>

 <LI><B><A HREF="../../../javax/microedition/midlet/MIDlet.html#pauseApp()"><CODE>pauseApp()</CODE></A></B>
 - the application may pause its threads. Also, if it is
 desirable to start with another screen when the application is re-activated,
 the new screen should be set with <A HREF="../../../javax/microedition/lcdui/Display.html#setCurrent(javax.microedition.lcdui.Displayable)"><CODE>setCurrent()</CODE></A>.</LI>

 <LI><B><A HREF="../../../javax/microedition/midlet/MIDlet.html#destroyApp(boolean)"><CODE>destroyApp()</CODE></A></B> - the application should free resources, terminate
 threads, etc. The behavior of method calls on user interface objects after
 <tt>destroyApp()</tt> has returned is undefined. </li> </UL> <p>

 The user interface objects that are shown on the display device are contained
 within a <A HREF="../../../javax/microedition/lcdui/Displayable.html"><CODE>Displayable</CODE></A> object. At any time the application
 may have at most one Displayable object that it intends to be shown on the
 display device and through which user interaction occurs.  This Displayable
 is referred to as the <i>current</i> Displayable. <p>

 The Display class has a <A HREF="../../../javax/microedition/lcdui/Display.html#setCurrent(javax.microedition.lcdui.Displayable)"><CODE>setCurrent()</CODE></A>
 method for setting the current <A HREF="../../../javax/microedition/lcdui/Displayable.html"><CODE>Displayable</CODE></A> and a <A HREF="../../../javax/microedition/lcdui/Display.html#getCurrent()"><CODE>getCurrent()</CODE></A> method for retrieving the current
 Displayable. The application has control over its current Displayable
 and may call setCurrent() at any time. Typically, the application will change
 the current Displayable in response to some user action.  This is not always
 the case, however.  Another thread may change the current Displayable in
 response to some other stimulus.  The current Displayable will also be
 changed when the timer for an <A HREF="../../../javax/microedition/lcdui/Alert.html"><CODE>Alert</CODE></A> elapses.<p>

 The application's current Displayable may not physically be drawn on the
 screen, nor will user events (such as keystrokes) that occur necessarily be
 directed to the current Displayable. This may occur because of the
 presence of other MIDlet applications running simultaneously on the
 same device. <p>

 An application is said to be in the <i>foreground</i> if its current
 Displayable is actually visible on the display device and if user input
 device events will be delivered to it. If the application is not in the
 foreground, it lacks access to both the display device and input devices
 and is said to be in the <i>background</i>. The policy for allocation of
 these devices to different MIDlet applications is outside the scope of this
 specification and is under the control of an external agent referred
 to as the <i>application management software</i>. <p>

 As mentioned above, the application still has a notion of its current
 Displayable even if it is in the background. The current Displayable is
 significant, even for background applications, because the current
 Displayable is always the one that will be shown when the application
 is next brought into the foreground. The application can determine whether
 a Displayable is actually visible on the display by calling
 <A HREF="../../../javax/microedition/lcdui/Displayable.html#isShown()"><CODE>isShown()</CODE></A>. In the case of Canvas, the
 <A HREF="../../../javax/microedition/lcdui/Canvas.html#showNotify()"><CODE>showNotify()</CODE></A> and
 <A HREF="../../../javax/microedition/lcdui/Canvas.html#hideNotify()"><CODE>hideNotify()</CODE></A> methods are called when the
 Canvas is made visible and is hidden, respectively.<p>

 Each <A HREF="../../../javax/microedition/midlet/MIDlet.html"><CODE>MIDlet</CODE></A> application has its own
 current <A HREF="../../../javax/microedition/lcdui/Displayable.html"><CODE>Displayable</CODE></A>. This means that
 the <A HREF="../../../javax/microedition/lcdui/Display.html#getCurrent()"><CODE>getCurrent()</CODE></A> method returns the MIDlet's current
 Displayable, regardless of its foreground/background state.  For example,
 suppose a MIDlet running in the foreground has current Displayable F, and a
 MIDlet running in the background has current Displayable B.  When the
 foreground MIDlet calls getCurrent(), it will return F, and when the
 background MIDlet calls getCurrent(), it will return B.  Furthermore if
 either MIDlet changes its current Displayable by calling setCurrent(), this
 will not affect any other MIDlet's current Displayable.<p>

 It is possible for <A HREF="../../../javax/microedition/lcdui/Display.html#getCurrent()"><CODE>getCurrent()</CODE></A> to return
 <tt>null</tt>. This may occur at
 startup time, before the MIDlet application has called
 <A HREF="../../../javax/microedition/lcdui/Display.html#setCurrent(javax.microedition.lcdui.Displayable)"><CODE>setCurrent()</CODE></A>
 on its first screen. It may also occur if the system has switched to
 a system screen (see below). The <tt>getCurrent()</tt> method will never
 return a reference to a Displayable object that was not passed in a
 prior call to <tt>setCurrent()</tt> call by this MIDlet. <p>

 <b>System Screens</b><p>

 Typically, the current screen of the foreground MIDlet will be visible on the
 display.  However, under certain circumstances, the system may create a
 screen that temporarily obscures the application's current screen.  These
 screens are referred to as <i>system screens</i>.  This may occur if the
 system needs to show a menu of commands or if the system requires the user to
 edit text on a separate screen instead of within a text field inside a Form.
 Even through the system screen obscures the application's screen, the notion
 of the current screen does not change.  In particular, while a system screen
 is visible, a call to <A HREF="../../../javax/microedition/lcdui/Display.html#getCurrent()"><CODE>getCurrent()</CODE></A> will return the
 applications's current screen, not the system screen.  The value returned by
 <A HREF="../../../javax/microedition/lcdui/Displayable.html#isShown()"><CODE>isShown()</CODE></A> returns <tt>false</tt> while the
 current <A HREF="../../../javax/microedition/lcdui/Displayable.html"><CODE>Displayable</CODE></A> is obscured by a system screen.<p>

 If the system screen obscures a <A HREF="../../../javax/microedition/lcdui/Canvas.html"><CODE>Canvas</CODE></A>, its
 <A HREF="../../../javax/microedition/lcdui/Canvas.html#hideNotify()"><CODE>hideNotify()</CODE></A> method is called.
 When the system screen is removed, restoring the Canvas, its
 <A HREF="../../../javax/microedition/lcdui/Canvas.html#showNotify()"><CODE>showNotify()</CODE></A>
 method and then its <A HREF="../../../javax/microedition/lcdui/Canvas.html#paint(javax.microedition.lcdui.Graphics)"><CODE>paint()</CODE></A> method are called.
 If the system screen was used by the user to issue a <A HREF="../../../javax/microedition/lcdui/Command.html"><CODE>Command</CODE></A>,
 the <A HREF="../../../javax/microedition/lcdui/CommandListener.html#commandAction(javax.microedition.lcdui.Command, javax.microedition.lcdui.Displayable)"><CODE>commandAction()</CODE></A> method is called after <tt>showNotify()</tt> is called.
<P>

<P>
<HR>

<P>
<!-- ======== NESTED CLASS SUMMARY ======== -->


<!-- =========== FIELD SUMMARY =========== -->

<A NAME="field_summary"><!-- --></A>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=2><FONT SIZE="+2">
<B>Field Summary</B></FONT></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/microedition/lcdui/Display.html#ALERT">ALERT</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Image type for <code>Alert</code> image.

 </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/microedition/lcdui/Display.html#CHOICE_GROUP_ELEMENT">CHOICE_GROUP_ELEMENT</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Image type for <code>ChoiceGroup</code> element image.

 </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/microedition/lcdui/Display.html#COLOR_BACKGROUND">COLOR_BACKGROUND</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A color specifier for use with <code>getColor</code>.
 </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/microedition/lcdui/Display.html#COLOR_BORDER">COLOR_BORDER</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A color specifier for use with <code>getColor</code>.
 </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/microedition/lcdui/Display.html#COLOR_FOREGROUND">COLOR_FOREGROUND</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A color specifier for use with <code>getColor</code>.
 </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/microedition/lcdui/Display.html#COLOR_HIGHLIGHTED_BACKGROUND">COLOR_HIGHLIGHTED_BACKGROUND</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A color specifier for use with <code>getColor</code>.
 </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/microedition/lcdui/Display.html#COLOR_HIGHLIGHTED_BORDER">COLOR_HIGHLIGHTED_BORDER</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A color specifier for use with <code>getColor</code>.
 </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/microedition/lcdui/Display.html#COLOR_HIGHLIGHTED_FOREGROUND">COLOR_HIGHLIGHTED_FOREGROUND</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A color specifier for use with <code>getColor</code>.
 </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/microedition/lcdui/Display.html#LIST_ELEMENT">LIST_ELEMENT</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Image type for <code>List</code> element image.

 </TD>
</TR>
</TABLE>
&nbsp;
<!-- ======== CONSTRUCTOR SUMMARY ======== -->


<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=2><FONT SIZE="+2">
<B>Method Summary</B></FONT></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/microedition/lcdui/Display.html#callSerially(java.lang.Runnable)">callSerially</A></B>(<A HREF="../../../java/lang/Runnable.html">Runnable</A>&nbsp;r)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Causes the <A HREF="../../../java/lang/Runnable.html"><CODE>Runnable</CODE></A> object <tt>r</tt> to have
 its <A HREF="../../../java/lang/Runnable.html#run()"><CODE>Runnable.run()</CODE></A> method
 called later, serialized with the event stream. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/microedition/lcdui/Display.html#flashBacklight(int)">flashBacklight</A></B>(int&nbsp;duration)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Requests a flashing effect for the device's backlight.  </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/microedition/lcdui/Display.html#getBestImageHeight(int)">getBestImageHeight</A></B>(int&nbsp;imageType)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the best image height for a given image type.
 </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/microedition/lcdui/Display.html#getBestImageWidth(int)">getBestImageWidth</A></B>(int&nbsp;imageType)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the best image width for a given image type.
 </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/microedition/lcdui/Display.html#getBorderStyle(boolean)">getBorderStyle</A></B>(boolean&nbsp;highlighted)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the stroke style used for border drawing
 depending on the state of the component
 (highlighted/non-highlighted). </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/microedition/lcdui/Display.html#getColor(int)">getColor</A></B>(int&nbsp;colorSpecifier)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns one of the colors from the high level user interface
 color scheme, in the form <code>0x00RRGGBB</code> based on the
 <code>colorSpecifier</code> passed in.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../javax/microedition/lcdui/Displayable.html">Displayable</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/microedition/lcdui/Display.html#getCurrent()">getCurrent</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Gets the current Displayable object for this MIDlet.  </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../../javax/microedition/lcdui/Display.html">Display</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/microedition/lcdui/Display.html#getDisplay(javax.microedition.midlet.MIDlet)">getDisplay</A></B>(<A HREF="../../../javax/microedition/midlet/MIDlet.html">MIDlet</A>&nbsp;m)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Gets the Display object that is unique to this MIDlet.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/microedition/lcdui/Display.html#isColor()">isColor</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Gets information about color support of the device.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/microedition/lcdui/Display.html#numAlphaLevels()">numAlphaLevels</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Gets the number of alpha transparency levels supported by this
 implementation.  </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/microedition/lcdui/Display.html#numColors()">numColors</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Gets the number of colors (if <A HREF="../../../javax/microedition/lcdui/Display.html#isColor()"><CODE>isColor()</CODE></A> is
 <tt>true</tt>) or graylevels (if <A HREF="../../../javax/microedition/lcdui/Display.html#isColor()"><CODE>isColor()</CODE></A> is
 <tt>false</tt>) that can be represented on the device.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/microedition/lcdui/Display.html#setCurrent(javax.microedition.lcdui.Alert, javax.microedition.lcdui.Displayable)">setCurrent</A></B>(<A HREF="../../../javax/microedition/lcdui/Alert.html">Alert</A>&nbsp;alert,
           <A HREF="../../../javax/microedition/lcdui/Displayable.html">Displayable</A>&nbsp;next)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Requests that <tt>alert</tt> be made current, and that
 <tt>nextDisplayable</tt> be made current after the Alert is dismissed.
 </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/microedition/lcdui/Display.html#setCurrent(javax.microedition.lcdui.Displayable)">setCurrent</A></B>(<A HREF="../../../javax/microedition/lcdui/Displayable.html">Displayable</A>&nbsp;next)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Requests that a different Displayable object be made visible on the
 display.  </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/microedition/lcdui/Display.html#setCurrentItem(javax.microedition.lcdui.Item)">setCurrentItem</A></B>(<A HREF="../../../javax/microedition/lcdui/Item.html">Item</A>&nbsp;item)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Requests that the <code>Displayable</code> that contains this
 <code>Item</code> be made current,
 scrolls the <code>Displayable</code> so that this
 <code>Item</code> is visible, and possibly
 assigns the focus to this <code>Item</code>.  </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/microedition/lcdui/Display.html#vibrate(int)">vibrate</A></B>(int&nbsp;duration)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Requests operation of the device's vibrator.  </TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.lang.Object"><!-- --></A>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TD><B>Methods inherited from class java.lang.<A HREF="../../../java/lang/Object.html">Object</A></B></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../../../java/lang/Object.html#equals(java.lang.Object)">equals</A>, <A HREF="../../../java/lang/Object.html#getClass()">getClass</A>, <A HREF="../../../java/lang/Object.html#hashCode()">hashCode</A>, <A HREF="../../../java/lang/Object.html#notify()">notify</A>, <A HREF="../../../java/lang/Object.html#notifyAll()">notifyAll</A>, <A HREF="../../../java/lang/Object.html#toString()">toString</A>, <A HREF="../../../java/lang/Object.html#wait()">wait</A>, <A HREF="../../../java/lang/Object.html#wait(long)">wait</A>, <A HREF="../../../java/lang/Object.html#wait(long, int)">wait</A></CODE></TD>
</TR>
</TABLE>
&nbsp;
<P>

<!-- ============ FIELD DETAIL =========== -->

<A NAME="field_detail"><!-- --></A>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=1><FONT SIZE="+2">
<B>Field Detail</B></FONT></TD>
</TR>
</TABLE>

<A NAME="LIST_ELEMENT"><!-- --></A><H3>
LIST_ELEMENT</H3>
<PRE>
public static final int <B>LIST_ELEMENT</B></PRE>
<DL>
<DD>Image type for <code>List</code> element image.

 <P>The value of <code>LIST_ELEMENT</code> is <code>1</code>.</P>
<P>
<DL>
<DT><B>Since:</B></DT>
  <DD>MIDP 2.0</DD>
<DT><B>See Also:</B><DD><A HREF="../../../javax/microedition/lcdui/Display.html#getBestImageWidth(int)"><CODE>getBestImageWidth(int imageType)</CODE></A>, 
<A HREF="../../../javax/microedition/lcdui/Display.html#getBestImageHeight(int)"><CODE>getBestImageHeight(int imageType)</CODE></A>, 
<A HREF="../../../constant-values.html#javax.microedition.lcdui.Display.LIST_ELEMENT">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="CHOICE_GROUP_ELEMENT"><!-- --></A><H3>
CHOICE_GROUP_ELEMENT</H3>
<PRE>
public static final int <B>CHOICE_GROUP_ELEMENT</B></PRE>
<DL>
<DD>Image type for <code>ChoiceGroup</code> element image.

 <P>The value of <code>CHOICE_GROUP_ELEMENT</code> is <code>2</code>.</P>
<P>
<DL>
<DT><B>Since:</B></DT>
  <DD>MIDP 2.0</DD>
<DT><B>See Also:</B><DD><A HREF="../../../javax/microedition/lcdui/Display.html#getBestImageWidth(int)"><CODE>getBestImageWidth(int imageType)</CODE></A>, 
<A HREF="../../../javax/microedition/lcdui/Display.html#getBestImageHeight(int)"><CODE>getBestImageHeight(int imageType)</CODE></A>, 
<A HREF="../../../constant-values.html#javax.microedition.lcdui.Display.CHOICE_GROUP_ELEMENT">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="ALERT"><!-- --></A><H3>
ALERT</H3>
<PRE>
public static final int <B>ALERT</B></PRE>
<DL>
<DD>Image type for <code>Alert</code> image.

 <P>The value of <code>ALERT</code> is <code>3</code>.</P>
<P>
<DL>
<DT><B>Since:</B></DT>
  <DD>MIDP 2.0</DD>
<DT><B>See Also:</B><DD><A HREF="../../../javax/microedition/lcdui/Display.html#getBestImageWidth(int)"><CODE>getBestImageWidth(int imageType)</CODE></A>, 
<A HREF="../../../javax/microedition/lcdui/Display.html#getBestImageHeight(int)"><CODE>getBestImageHeight(int imageType)</CODE></A>, 
<A HREF="../../../constant-values.html#javax.microedition.lcdui.Display.ALERT">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="COLOR_BACKGROUND"><!-- --></A><H3>
COLOR_BACKGROUND</H3>
<PRE>
public static final int <B>COLOR_BACKGROUND</B></PRE>
<DL>
<DD>A color specifier for use with <code>getColor</code>.
 <code>COLOR_BACKGROUND</code> specifies the background color of
 the screen.
 The background color will always contrast with the foreground color.

 <p>
 <code>COLOR_BACKGROUND</code> has the value <code>0</code>.
<P>
<DL>
<DT><B>Since:</B></DT>
  <DD>MIDP 2.0</DD>
<DT><B>See Also:</B><DD><A HREF="../../../javax/microedition/lcdui/Display.html#getColor(int)"><CODE>getColor(int)</CODE></A>, 
<A HREF="../../../constant-values.html#javax.microedition.lcdui.Display.COLOR_BACKGROUND">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="COLOR_FOREGROUND"><!-- --></A><H3>
COLOR_FOREGROUND</H3>
<PRE>
public static final int <B>COLOR_FOREGROUND</B></PRE>
<DL>
<DD>A color specifier for use with <code>getColor</code>.
 <code>COLOR_FOREGROUND</code> specifies the foreground color,
 for text characters
 and simple graphics on the screen.  Static text or user-editable
 text should be drawn with the foreground color.  The foreground color
 will always constrast with background color.

 <p> <code>COLOR_FOREGROUND</code> has the value <code>1</code>.
<P>
<DL>
<DT><B>Since:</B></DT>
  <DD>MIDP 2.0</DD>
<DT><B>See Also:</B><DD><A HREF="../../../javax/microedition/lcdui/Display.html#getColor(int)"><CODE>getColor(int)</CODE></A>, 
<A HREF="../../../constant-values.html#javax.microedition.lcdui.Display.COLOR_FOREGROUND">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="COLOR_HIGHLIGHTED_BACKGROUND"><!-- --></A><H3>
COLOR_HIGHLIGHTED_BACKGROUND</H3>
<PRE>
public static final int <B>COLOR_HIGHLIGHTED_BACKGROUND</B></PRE>
<DL>
<DD>A color specifier for use with <code>getColor</code>.
 <code>COLOR_HIGHLIGHTED_BACKGROUND</code> identifies the color for the
 focus, or focus highlight, when it is drawn as a
 filled in rectangle. The highlighted
 background will always constrast with the highlighted foreground.

 <p>
 <code>COLOR_HIGHLIGHTED_BACKGROUND</code> has the value <code>2</code>.
<P>
<DL>
<DT><B>Since:</B></DT>
  <DD>MIDP 2.0</DD>
<DT><B>See Also:</B><DD><A HREF="../../../javax/microedition/lcdui/Display.html#getColor(int)"><CODE>getColor(int)</CODE></A>, 
<A HREF="../../../constant-values.html#javax.microedition.lcdui.Display.COLOR_HIGHLIGHTED_BACKGROUND">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="COLOR_HIGHLIGHTED_FOREGROUND"><!-- --></A><H3>
COLOR_HIGHLIGHTED_FOREGROUND</H3>
<PRE>
public static final int <B>COLOR_HIGHLIGHTED_FOREGROUND</B></PRE>
<DL>
<DD>A color specifier for use with <code>getColor</code>.
 <code>COLOR_HIGHLIGHTED_FOREGROUND</code> identifies the color for text
 characters and simple graphics when they are highlighted.
 Highlighted
 foreground is the color to be used to draw the highlighted text
 and graphics against the highlighted background.
 The highlighted foreground will always constrast with
 the highlighted background.

 <p>
 <code>COLOR_HIGHLIGHTED_FOREGROUND</code> has the value <code>3</code>.
<P>
<DL>
<DT><B>Since:</B></DT>
  <DD>MIDP 2.0</DD>
<DT><B>See Also:</B><DD><A HREF="../../../javax/microedition/lcdui/Display.html#getColor(int)"><CODE>getColor(int)</CODE></A>, 
<A HREF="../../../constant-values.html#javax.microedition.lcdui.Display.COLOR_HIGHLIGHTED_FOREGROUND">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="COLOR_BORDER"><!-- --></A><H3>
COLOR_BORDER</H3>
<PRE>
public static final int <B>COLOR_BORDER</B></PRE>
<DL>
<DD>A color specifier for use with <code>getColor</code>.
 <code>COLOR_BORDER</code> identifies the color for boxes and borders
 when the object is to be drawn in a
 non-highlighted state.  The border color is intended to be used with
 the background color and will contrast with it.
 The application should draw its borders using the stroke style returned
 by <code>getBorderStyle()</code>.

 <p> <code>COLOR_BORDER</code> has the value <code>4</code>.
<P>
<DL>
<DT><B>Since:</B></DT>
  <DD>MIDP 2.0</DD>
<DT><B>See Also:</B><DD><A HREF="../../../javax/microedition/lcdui/Display.html#getColor(int)"><CODE>getColor(int)</CODE></A>, 
<A HREF="../../../constant-values.html#javax.microedition.lcdui.Display.COLOR_BORDER">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="COLOR_HIGHLIGHTED_BORDER"><!-- --></A><H3>
COLOR_HIGHLIGHTED_BORDER</H3>
<PRE>
public static final int <B>COLOR_HIGHLIGHTED_BORDER</B></PRE>
<DL>
<DD>A color specifier for use with <code>getColor</code>.
 <code>COLOR_HIGHLIGHTED_BORDER</code>
 identifies the color for boxes and borders when the object is to be
 drawn in a highlighted state.  The highlighted border color is intended
 to be used with the background color (not the highlighted background
 color) and will contrast with it.  The application should draw its
 borders using the stroke style returned <code>by getBorderStyle()</code>.

 <p> <code>COLOR_HIGHLIGHTED_BORDER</code> has the value <code>5</code>.
<P>
<DL>
<DT><B>Since:</B></DT>
  <DD>MIDP 2.0</DD>
<DT><B>See Also:</B><DD><A HREF="../../../javax/microedition/lcdui/Display.html#getColor(int)"><CODE>getColor(int)</CODE></A>, 
<A HREF="../../../constant-values.html#javax.microedition.lcdui.Display.COLOR_HIGHLIGHTED_BORDER">Constant Field Values</A></DL>
</DL>

<!-- ========= CONSTRUCTOR DETAIL ======== -->


<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=1><FONT SIZE="+2">
<B>Method Detail</B></FONT></TD>
</TR>
</TABLE>

<A NAME="callSerially(java.lang.Runnable)"><!-- --></A><H3>
callSerially</H3>
<PRE>
public void <B>callSerially</B>(<A HREF="../../../java/lang/Runnable.html">Runnable</A>&nbsp;r)</PRE>
<DL>
<DD>Causes the <A HREF="../../../java/lang/Runnable.html"><CODE>Runnable</CODE></A> object <tt>r</tt> to have
 its <A HREF="../../../java/lang/Runnable.html#run()"><CODE>Runnable.run()</CODE></A> method
 called later, serialized with the event stream. As noted in the
 event delivery section of <A HREF="../../../javax/microedition/lcdui/Canvas.html"><CODE>Canvas</CODE></A>, the methods that
 deliver event notifications to the current Canvas are all called
 serially. The call to <tt>r.run()</tt> will be serialized along with
 the event calls on the current Canvas. The run() method will be called
 exactly once for each call to callSerially(). Calls to run() will occur
 in the order in which they were requested by calls to callSerially(). <p>

 If there is a repaint pending at the time of a call to callSerially(),
 the current Canvas's paint() method will be called and will return, and
 a buffer switch will occur (if double buffering is in effect), before the
 Runnable's run() method is called. Calls to the run() method will occur
 in a timely fashion, but they are not guaranteed to occur immediately
 after the repaint cycle finishes, or even before the next event is
 delivered.<p>

 The callSerially() method may be called from any thread. The call to the
 run() method will occur independently of the call to callSerially(). In
 particular, callSerially() will <i>never</i> block waiting for
 r.run() to return. <p>

 As with other callbacks, the call to r.run() must return quickly. If it
 is necessary to perform a long-running operation, it may be initiated
 from within the run() method. The operation itself should be performed
 within another thread, allowing run() to return. <p>

 The callSerially() facility may be used by applications to run an
 animation that is properly synchronized with the repaint cycle. A
 typical application will set up a frame to be displayed and then
 call repaint(). The application must then wait until the frame is
 actually displayed, after which the setup for the next frame may occur.
 The example below shows callSerially() being used for this purpose.<p>

 <code><pre>
 class Animation extends Canvas implements Runnable {

     void paint(Graphics g) { ... } // paint the current frame

     void startAnimation() { // set up initial frame
         repaint();
         callSerially(this);
     }

     void run() { // called after previous repaint is finished
         if ( &#47;* there are more frames *&#47; ) {
             // update to the next frame
             repaint();
             callSerially(this);
         }
     }
 }
 </pre> </code>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>r</CODE> - instance of interface Runnable to be called</DL>
</DD>
</DL>
<HR>

<A NAME="flashBacklight(int)"><!-- --></A><H3>
flashBacklight</H3>
<PRE>
public boolean <B>flashBacklight</B>(int&nbsp;duration)</PRE>
<DL>
<DD>Requests a flashing effect for the device's backlight.  The flashing
 effect is intended to be used to attract the user's attention or as a
 special effect for games.  Examples of flashing are cycling the
 backlight on and off or from dim to bright repeatedly.
 The return value indicates if the flashing of the backlight
 can be controlled by the application.

 <p>The flashing effect occurs for the requested duration, or it is
 switched off if the requested duration is zero.  This method returns
 immediately; that is, it must not block the caller while the flashing
 effect is running.</p>

 <p>Calls to this method are honored only if the
 <code>Display</code> is in the
 foreground.  This method MUST perform no action
 and return <CODE>false</CODE> if the
 <code>Display</code> is in the background.

 <p>The device MAY limit or override the duration. For devices
 that do not include a controllable backlight, calls to this
 method return <CODE>false</CODE>.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>duration</CODE> - the number of milliseconds the backlight should be
 flashed, or zero if the flashing should be stopped
<DT><B>Returns:</B><DD><CODE>true</CODE> if the backlight can be controlled
       by the application and this display is in the foreground,
      <CODE>false</CODE> otherwise
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../java/lang/IllegalArgumentException.html">IllegalArgumentException</A></CODE> - if <code>duration</code> is negative<DT><B>Since:</B></DT>
  <DD>MIDP 2.0</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="getBestImageHeight(int)"><!-- --></A><H3>
getBestImageHeight</H3>
<PRE>
public int <B>getBestImageHeight</B>(int&nbsp;imageType)</PRE>
<DL>
<DD>Returns the best image height for a given image type.
 The image type must be one of
 <A HREF="../../../javax/microedition/lcdui/Display.html#LIST_ELEMENT"><CODE>LIST_ELEMENT</CODE></A>,
 <A HREF="../../../javax/microedition/lcdui/Display.html#CHOICE_GROUP_ELEMENT"><CODE>CHOICE_GROUP_ELEMENT</CODE></A>, or
 <A HREF="../../../javax/microedition/lcdui/Display.html#ALERT"><CODE>ALERT</CODE></A>.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>imageType</CODE> - the image type
<DT><B>Returns:</B><DD>the best image height for the image type, may be zero if
 there is no best size; must not be negative
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../java/lang/IllegalArgumentException.html">IllegalArgumentException</A></CODE> - if <code>imageType</code> is illegal<DT><B>Since:</B></DT>
  <DD>MIDP 2.0</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="getBestImageWidth(int)"><!-- --></A><H3>
getBestImageWidth</H3>
<PRE>
public int <B>getBestImageWidth</B>(int&nbsp;imageType)</PRE>
<DL>
<DD>Returns the best image width for a given image type.
 The image type must be one of
 <A HREF="../../../javax/microedition/lcdui/Display.html#LIST_ELEMENT"><CODE>LIST_ELEMENT</CODE></A>,
 <A HREF="../../../javax/microedition/lcdui/Display.html#CHOICE_GROUP_ELEMENT"><CODE>CHOICE_GROUP_ELEMENT</CODE></A>, or
 <A HREF="../../../javax/microedition/lcdui/Display.html#ALERT"><CODE>ALERT</CODE></A>.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>imageType</CODE> - the image type
<DT><B>Returns:</B><DD>the best image width for the image type, may be zero if
 there is no best size; must not be negative
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../java/lang/IllegalArgumentException.html">IllegalArgumentException</A></CODE> - if <code>imageType</code> is illegal<DT><B>Since:</B></DT>
  <DD>MIDP 2.0</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="getBorderStyle(boolean)"><!-- --></A><H3>
getBorderStyle</H3>
<PRE>
public int <B>getBorderStyle</B>(boolean&nbsp;highlighted)</PRE>
<DL>
<DD>Returns the stroke style used for border drawing
 depending on the state of the component
 (highlighted/non-highlighted). For example, on a monochrome
 system, the border around a non-highlighted item might be
 drawn with a <code>DOTTED</code> stroke style while the border around a
 highlighted item might be drawn with a <code>SOLID</code> stroke style.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>highlighted</CODE> - <code>true</code> if the border style being
 requested is for the
 highlighted state, <code>false</code> if the border style being
 requested is for the
 non-highlighted state
<DT><B>Returns:</B><DD><A HREF="../../../javax/microedition/lcdui/Graphics.html#DOTTED"><CODE>Graphics.DOTTED</CODE></A> or <A HREF="../../../javax/microedition/lcdui/Graphics.html#SOLID"><CODE>Graphics.SOLID</CODE></A><DT><B>Since:</B></DT>
  <DD>MIDP 2.0</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="getColor(int)"><!-- --></A><H3>
getColor</H3>
<PRE>
public int <B>getColor</B>(int&nbsp;colorSpecifier)</PRE>
<DL>
<DD>Returns one of the colors from the high level user interface
 color scheme, in the form <code>0x00RRGGBB</code> based on the
 <code>colorSpecifier</code> passed in.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>colorSpecifier</CODE> - the predefined color specifier;
  must be one of
  <A HREF="../../../javax/microedition/lcdui/Display.html#COLOR_BACKGROUND"><CODE>COLOR_BACKGROUND</CODE></A>,
  <A HREF="../../../javax/microedition/lcdui/Display.html#COLOR_FOREGROUND"><CODE>COLOR_FOREGROUND</CODE></A>,
  <A HREF="../../../javax/microedition/lcdui/Display.html#COLOR_HIGHLIGHTED_BACKGROUND"><CODE>COLOR_HIGHLIGHTED_BACKGROUND</CODE></A>,
  <A HREF="../../../javax/microedition/lcdui/Display.html#COLOR_HIGHLIGHTED_FOREGROUND"><CODE>COLOR_HIGHLIGHTED_FOREGROUND</CODE></A>,
  <A HREF="../../../javax/microedition/lcdui/Display.html#COLOR_BORDER"><CODE>COLOR_BORDER</CODE></A>, or
  <A HREF="../../../javax/microedition/lcdui/Display.html#COLOR_HIGHLIGHTED_BORDER"><CODE>COLOR_HIGHLIGHTED_BORDER</CODE></A>
<DT><B>Returns:</B><DD>color in the form of <code>0x00RRGGBB</code>
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../java/lang/IllegalArgumentException.html">IllegalArgumentException</A></CODE> - if <code>colorSpecifier</code>
 is not a valid color specifier<DT><B>Since:</B></DT>
  <DD>MIDP 2.0</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="getCurrent()"><!-- --></A><H3>
getCurrent</H3>
<PRE>
public <A HREF="../../../javax/microedition/lcdui/Displayable.html">Displayable</A> <B>getCurrent</B>()</PRE>
<DL>
<DD>Gets the current Displayable object for this MIDlet.  The Displayable
 object returned may not actually be visible on the display if the MIDlet
 is running in the background, or if the Displayable is obscured by a
 system screen.  The <A HREF="../../../javax/microedition/lcdui/Displayable.html#isShown()"><CODE>isShown()</CODE></A> method may be
 called to determine whether the Displayable is actually visible on the
 Display.<p>

 The value returned by getCurrent() may be <tt>null</tt>.  This occurs
 after the application has been initialized but before the first call to
 setCurrent().
<P>
<DD><DL>

<DT><B>Returns:</B><DD>the MIDlet's current Displayable object</DL>
</DD>
</DL>
<HR>

<A NAME="getDisplay(javax.microedition.midlet.MIDlet)"><!-- --></A><H3>
getDisplay</H3>
<PRE>
public static <A HREF="../../../javax/microedition/lcdui/Display.html">Display</A> <B>getDisplay</B>(<A HREF="../../../javax/microedition/midlet/MIDlet.html">MIDlet</A>&nbsp;m)</PRE>
<DL>
<DD>Gets the Display object that is unique to this MIDlet.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>m</CODE> - Midlet of the application<p>
<DT><B>Returns:</B><DD>the Display object that the application can use for its user
 interface<p>
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../java/lang/NullPointerException.html">NullPointerException</A></CODE> - if m is <tt>null</tt></DL>
</DD>
</DL>
<HR>

<A NAME="isColor()"><!-- --></A><H3>
isColor</H3>
<PRE>
public boolean <B>isColor</B>()</PRE>
<DL>
<DD>Gets information about color support of the device.
<P>
<DD><DL>

<DT><B>Returns:</B><DD><tt>true</tt> if the display supports color,
 <tt>false</tt> otherwise</DL>
</DD>
</DL>
<HR>

<A NAME="numAlphaLevels()"><!-- --></A><H3>
numAlphaLevels</H3>
<PRE>
public int <B>numAlphaLevels</B>()</PRE>
<DL>
<DD>Gets the number of alpha transparency levels supported by this
 implementation.  The minimum legal return value is
 <code>2</code>, which indicates
 support for full transparency and full opacity and no blending.  Return
 values greater than <code>2</code> indicate that alpha blending
 is supported.  For
 further information, see <a href="Image.html#alpha">Alpha
 Processing</a>.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>number of alpha levels supported<DT><B>Since:</B></DT>
  <DD>MIDP 2.0</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="numColors()"><!-- --></A><H3>
numColors</H3>
<PRE>
public int <B>numColors</B>()</PRE>
<DL>
<DD>Gets the number of colors (if <A HREF="../../../javax/microedition/lcdui/Display.html#isColor()"><CODE>isColor()</CODE></A> is
 <tt>true</tt>) or graylevels (if <A HREF="../../../javax/microedition/lcdui/Display.html#isColor()"><CODE>isColor()</CODE></A> is
 <tt>false</tt>) that can be represented on the device.<p>

 Note that number of colors for black and white display is 2.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>number of colors that can be displayed on the device</DL>
</DD>
</DL>
<HR>

<A NAME="setCurrent(javax.microedition.lcdui.Alert, javax.microedition.lcdui.Displayable)"><!-- --></A><H3>
setCurrent</H3>
<PRE>
public void <B>setCurrent</B>(<A HREF="../../../javax/microedition/lcdui/Alert.html">Alert</A>&nbsp;alert,
                       <A HREF="../../../javax/microedition/lcdui/Displayable.html">Displayable</A>&nbsp;next)</PRE>
<DL>
<DD>Requests that <tt>alert</tt> be made current, and that
 <tt>nextDisplayable</tt> be made current after the Alert is dismissed.
 This call returns immediately regardless of the Alert's timeout value or
 whether it is a modal Alert. <tt>nextDisplayable</tt> must not be an
 Alert, and it must not be null.<p>

 In other respects, this method behaves identically to
 <A HREF="../../../javax/microedition/lcdui/Display.html#setCurrent(javax.microedition.lcdui.Displayable)"><CODE>setCurrent(Displayable)</CODE></A>.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>alert</CODE> - the Alert to be shown
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../java/lang/NullPointerException.html">NullPointerException</A></CODE> - if <tt>alert</tt> or
 <tt>nextDisplayable</tt> is null
<DD><CODE><A HREF="../../../java/lang/IllegalArgumentException.html">IllegalArgumentException</A></CODE> - if <tt>nextDisplayable</tt> is an
 Alert<p><DT><B>See Also:</B><DD><A HREF="../../../javax/microedition/lcdui/Alert.html"><CODE>Alert</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="setCurrent(javax.microedition.lcdui.Displayable)"><!-- --></A><H3>
setCurrent</H3>
<PRE>
public void <B>setCurrent</B>(<A HREF="../../../javax/microedition/lcdui/Displayable.html">Displayable</A>&nbsp;next)</PRE>
<DL>
<DD>Requests that a different Displayable object be made visible on the
 display.  The change will typically not take effect immediately.  It may
 be delayed so that it occurs between event delivery method calls,
 although it is not guaranteed to occur before the next event delivery
 method is called.  The setCurrent() method returns immediately, without
 waiting for the change to take place.  Because of this delay, a call to
 getCurrent() shortly after a call to setCurrent() is unlikely to return
 the value passed to setCurrent().<p>

 Calls to setCurrent() are not queued.  A delayed request made by a
 setCurrent() call may be superseded by a subsequent call to setCurrent().
 For example, if screen S1 is current, then<p>

 <code><pre>
     d.setCurrent(S2);
     d.setCurrent(S3);
 </pre></code><p>

 may eventually result in S3 being made current, bypassing S2 entirely.<p>

 When a MIDlet application is first started, there is no current
 Displayable object.  It is the responsibility of the application to
 ensure that a Displayable is visible and can interact with the user at
 all times.  Therefore the application should always call setCurrent() as
 part of its initialization.<p>

 The application may pass <tt>null</tt> as the argument to setCurrent().
 This does not have the effect of setting the current Displayable to
 <tt>null</tt>; instead the current Displayable remains unchanged.
 However, the application management software may interpret this call as a
 hint from the application that it is requesting to be placed into the
 background.  Similarly, if the application is in the background, passing
 a non-null reference to setCurrent() may be interpreted by the
 application management software as a hint that the application is
 requesting to be brought to the foreground.  The request should be
 considered to be made even if the current Displayable is passed to the
 setCurrent().  For example, the code:<p>

 <code><pre>
     d.setCurrent(d.getCurrent());
 </pre></code><p>

 generally will have no effect other than requesting that the application
 be brought to the foreground.  These requests are only hints, and there
 is no requirement that the application management software comply with
 these requests in a timely fashion if at all.<p>

 If the Displayable passed to setCurrent() is an <A HREF="../../../javax/microedition/lcdui/Alert.html"><CODE>Alert</CODE></A>, the
 previous Displayable is restored after the Alert has been dismissed.  The
 effect is as if setCurrent(Alert, getCurrent()) had been called.  Note
 that this will result in an exception being thrown if the current
 Displayable is already an alert.  To specify the screen to be shown
 after an Alert is dismissed, the application should use
 <A HREF="../../../javax/microedition/lcdui/Display.html#setCurrent(javax.microedition.lcdui.Alert, javax.microedition.lcdui.Displayable)"><CODE>setCurrent(Alert, Displayable)</CODE></A>.<p>

 If the application calls setCurrent() while a system screen is active,
 the effect may be delayed until after the system screen is dismissed.
 The implementation may choose to interpret setCurrent() in such a
 situation as a request to cancel the effect of the system screen,
 regardless of whether setCurrent() has been delayed.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>next</CODE> - the Displayable requested to be made current</DL>
</DD>
</DL>
<HR>

<A NAME="setCurrentItem(javax.microedition.lcdui.Item)"><!-- --></A><H3>
setCurrentItem</H3>
<PRE>
public void <B>setCurrentItem</B>(<A HREF="../../../javax/microedition/lcdui/Item.html">Item</A>&nbsp;item)</PRE>
<DL>
<DD>Requests that the <code>Displayable</code> that contains this
 <code>Item</code> be made current,
 scrolls the <code>Displayable</code> so that this
 <code>Item</code> is visible, and possibly
 assigns the focus to this <code>Item</code>.  The containing
 <code>Displayable</code> is first
 made current as if <A HREF="../../../javax/microedition/lcdui/Display.html#setCurrent(javax.microedition.lcdui.Displayable)"><CODE>setCurrent(Displayable)</CODE></A> had been called.  When the containing
 <code>Displayable</code> becomes current, or if it is already
 current, it is
 scrolled if necessary so that the requested <code>Item</code>
 is made visible.
 Then, if the implementation supports the notion of input focus, and if
 the <code>Item</code> accepts the input focus, the input focus
 is assigned to the
 <code>Item</code>.

 <p>This method always returns immediately, without waiting for the
 switching of the <code>Displayable</code>, the scrolling, and
 the assignment of
 input focus to take place.</p>

 <p>It is an error for the <code>Item</code> not to be contained
 within a container.
 It is also an error if the <code>Item</code> is contained
 within an <code>Alert</code>.</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>item</CODE> - the item that should be made visible
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../java/lang/IllegalStateException.html">IllegalStateException</A></CODE> - if the item is not owned by a container
<DD><CODE><A HREF="../../../java/lang/IllegalStateException.html">IllegalStateException</A></CODE> - if the item is owned by an
 <code>Alert</code>
<DD><CODE><A HREF="../../../java/lang/NullPointerException.html">NullPointerException</A></CODE> - if <code>item</code> is <code>null</code><DT><B>Since:</B></DT>
  <DD>MIDP 2.0</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="vibrate(int)"><!-- --></A><H3>
vibrate</H3>
<PRE>
public boolean <B>vibrate</B>(int&nbsp;duration)</PRE>
<DL>
<DD>Requests operation of the device's vibrator.  The vibrator is
 intended to be used to attract the user's attention or as a
 special effect for games.  The return value indicates if the
 vibrator can be controlled by the application.

 <p>This method switches on the vibrator for the requested
 duration, or switches it off if the requested duration is zero.
 If this method is called while the vibrator is still activated
 from a previous call, the request is interpreted as setting a
 new duration. It is not interpreted as adding additional time
 to the original request. This method returns immediately; that
 is, it must not block the caller while the vibrator is
 running. </p>

 <p>Calls to this method are honored only if the
 <code>Display</code> is in the foreground.  This method MUST
 perform no action and return <CODE>false</CODE> if the
 <code>Display</code> is in the background.</p>

 <p>The device MAY limit or override the duration.  For devices
 that do not include a controllable vibrator, calls to this
 method return <CODE>false</CODE>.</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>duration</CODE> - the number of milliseconds the vibrator should be run,
 or zero if the vibrator should be turned off
<DT><B>Returns:</B><DD><CODE>true</CODE> if the vibrator can be controlled by the
       application and this display is in the foreground,
      <CODE>false</CODE> otherwise
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../java/lang/IllegalArgumentException.html">IllegalArgumentException</A></CODE> - if <code>duration</code> is negative<DT><B>Since:</B></DT>
  <DD>MIDP 2.0</DD>
</DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>

<!-- ========== START OF NAVBAR ========== -->
<A NAME="navbar_bottom"><!-- --></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0">
<TR>
<TD COLSPAN=3 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../javax/microedition/lcdui/DateField.html"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../../../javax/microedition/lcdui/Displayable.html"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../index.html" TARGET="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="Display.html" TARGET="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;
<SCRIPT>
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../allclasses-noframe.html" TARGET=""><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
<A HREF="../../../allclasses-noframe.html" TARGET=""><B>All Classes</B></A>
</NOSCRIPT>
</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;<A HREF="#field_summary">FIELD</A>&nbsp;|&nbsp;CONSTR&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;<A HREF="#field_detail">FIELD</A>&nbsp;|&nbsp;CONSTR&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<!-- =========== END OF NAVBAR =========== -->

<HR>

</BODY>
</HTML>
