<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Frameset//EN""http://www.w3.org/TR/REC-html40/frameset.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc on Fri Apr 25 17:17:26 JST 2003 -->
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<TITLE>
VSCL1.0/1.1: Class  SpriteCanvas
</TITLE>
<LINK REL ="stylesheet" TYPE="text/css" HREF="../../../../../stylesheet.css" TITLE="Style">
</HEAD>
<BODY BGCOLOR="white">

<!-- ========== START OF NAVBAR ========== -->
<A NAME="navbar_top"><!-- --></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../../index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;PREV CLASS&nbsp;
&nbsp;NEXT CLASS</FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../../../index.html" TARGET="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="SpriteCanvas.html" TARGET="_top"><B>NO FRAMES</B></A></FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY: &nbsp;INNER&nbsp;|&nbsp;<A HREF="#fields_inherited_from_class_javax.microedition.lcdui.Canvas">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL: &nbsp;FIELD&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<!-- =========== END OF NAVBAR =========== -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
com.vodafone.v10.graphics.sprite</FONT>
<BR>
Class  SpriteCanvas</H2>
<PRE>
java.lang.Object
  |
  +--javax.microedition.lcdui.Displayable
        |
        +--javax.microedition.lcdui.Canvas
              |
              +--<B>com.vodafone.v10.graphics.sprite.SpriteCanvas</B>
</PRE>
<HR>
<DL>
<DT>public abstract class <B>SpriteCanvas</B><DT>extends javax.microedition.lcdui.Canvas</DL>

<P>
SpriteCanvas class provides the Canvas for manipulating Sprite data.

<h3>1. Overview of SpriteCanvas</h3>

<h4>Class Makeup</h4>
<p>
SpriteCanvas inherits the MIDP Canvas class. In addition to the functions of the Canvas class, it provides functions for sprite drawing. A Java application creates and uses instances of SpriteCanvas or its subclasses.
</p><p>
The SpriteCanvas drawing functions are used in the same way as the ordinary Canvas subclass, by calling the Display object setCurrent() method and designating the SpriteCanvas object as current Displayable, then calling the SpriteCanvas method.
</p><p>
Functions other than SpriteCanvas drawing, such as those for key event control, should be implemented along the same lines as the Canvas class methods. For example, waiting for a key event can be implemented by overriding the Canvas class keyPressed() or other such method.
</p><p>

<h4>Functional Overview</h4>
<p>
Sprite data is graphical data made up of 256-color pixels and consisting of square blocks that are 8 pixels by 8 pixels in size. The SpriteCanvas class provides the functions for drawing sprite data on a virtual screen or in a frame buffer, and for performing image processing such as horizontal flip, vertical flip, rotate, and color data designation from a color palette.
</p><p>
A handset has one virtual screen, whose size is dependent on the handset design. The virtual screen contents can be copied to a frame buffer. The frame buffer is a kind of screen buffer belonging to the SpriteCanvas object; the Java application must create this buffer using a SpriteCanvas method.
</p><p>
A typical way of using this functionality is to have the Java application draw the background image on the virtual screen, copy that to the frame buffer, and after drawing sprite data on top of that background, copying the entire frame buffer contents to the real screen. The image copied to the real screen is what the user sees in the handset display. The Java application performs all this processing using SpriteCanvas methods. Note that drawing on the virtual screen can be done using the MIDP Graphics class functions in addition to sprite data drawing.
</p><p>
The drawing of sprite data is here described in terms of "sprite processing commands." The concept of sprite processing commands is illustrated in Figure 1.
</p>

<div align="center">
<img src="doc-files/sprite_command_model_en.gif" alt="sprite_command_model_en.gif">
<p><strong>Figure 1. The Sprite Processing Command Model</strong></p>
</div>

<p>
The Java application readies 8-pixel-square sprite data and registers it in the SpriteCanvas object. The SpriteCanvas object stores the sprite data array. When a draw is executed that involves image processing, the sprite data stored by the SpriteCanvas object is not affected.
</p><p>
When a sprite processing command is executed, the sprite data and the nature of the image processing are designated. In the example in Figure 1, sprite processing commands cmd1, cmd2, cmd3, and cmd4 are performed on sprite data A, each designating a different angle of rotation. Commands cmd5, cmd6, and cmd9 apply to sprite data C, with each designating a different color conversion.
</p><p>
A Java application uses a SpriteCanvas method to create a sprite processing command, and requests sprite drawing by designating the command as well as the draw destination position when it calls a SpriteCanvas drawing method. A method must be called each time a sprite drawing action is performed. There are separate drawing methods for virtual screen and frame buffer drawing.
</p><p>

<h3>2. Data Structure</h3>
</p><p>
The data structure used with the SpriteCanvas class is explained here.
</p>

<h4>2.1. Sprite Data Array</h4>
<p>
The sprite data structure is shown in Figure 2.
</p>

<div align="center">
<img src="doc-files/sprite_data_structure_en.gif" alt="sprite_data_structure_en.gif">
<p><strong>Figure 2. Sprite Data Structure</strong></p>
</div>

<p>
One unit of sprite data consists of a 64-pixel block (8 pixels by 8 pixels), with each pixel represented by one byte. Data must be arrayed in the direction shown in the left part of Figure 2.
</p><p>
When a Java application creates the SpriteCanvas object, it designates in the constructor the number of sprite data elements (max. 256) that can be registered. The SpriteCanvas object builds a sprite data array internally with this number of elements. The Java application must register each element in this array using the <A HREF="../../../../../com/vodafone/v10/graphics/sprite/SpriteCanvas.html#setPattern(int, byte[])"><CODE>setPattern()</CODE></A> method. As shown in Figure 2 on the right, these elements are designated by an index value from 0 to 255. The index values are used in the sprite processing commands described later. 
</p><p>

<h4>2.2. Color Palette</h4>
The color palette structure is shown in Figure 3.

<div align="center">
<img src="doc-files/sprite_color_palette_en.gif" alt="sprite_color_palette_en.gif">
<p><strong>Figure 3. Sprite Data Color Palette</strong></p>
</div>

<p>
The byte representing each pixel of sprite data is a color palette index indicating an array (color palette) made up of 24-bit colors (palette values), as shown in Figure 3. The color palette is made up of 4-byte integer values. Each palette value represents a color in the 24-bit RGB color space, and is calculated based on RGB 1-byte values as R*0x10000 + G*0x100 + B. Once the pixel value is known, the color of that pixel as a 24-bit color can be determined from the color palette array elements (called "palette entries" hereafter). 
</p><p>
When a Java application creates the SpriteCanvas object, it designates the number of palette colors (max. 256) that can be registered. The SpriteCanvas object builds a color palette array internally with this number of elements. The palette value upon creation is 0. The Java application must register each element in this array using the <A HREF="../../../../../com/vodafone/v10/graphics/sprite/SpriteCanvas.html#setPalette(int, int)"><CODE>setPalette()</CODE></A> method.
</p>

<h3>3. Sprite Processing Commands</h3>

<p>
Sprite processing commands are created by means of the <A HREF="../../../../../com/vodafone/v10/graphics/sprite/SpriteCanvas.html#createCharacterCommand(int, boolean, int, boolean, boolean, int)"><CODE>createCharacterCommand()</CODE></A> method. The items shown in Table 1 are designated as parameters with this method.
</p>

<table border=1 cellspacing=0 cellpadding=2>
<caption align = "left"><strong>Table 1. Sprite Processing Commands</strong></caption>
<tr>
<td><b>Item</b></td>
<td><b>Description</b></td>
</tr>
<tr>
<td><b>offset</b></td>
<td><b>Palette offset (0 to 7):</b><br>
This value multiplied by 32 is added to each pixel value of sprite data, and the lower byte of the result becomes the color palette index value that determines the color of the pixel. By changing the offset value, the same sprite data can be drawn in different colors. Note that when drawing is being performed in the frame buffer and transparent is "true," pixels having a pixel value of 0 are regarded as transparent and the offset value is not reflected in the drawing result.
</td>
</tr>
<tr>
<td><b>transparent</b></td>
<td><b>Transparent color use (false: transparent color not used; true: transparent color used):</b><br>
When drawing takes place in the frame buffer and transparent is "true," those pixels whose color value is 0 are treated as transparent and are drawn with the same color as the background color already drawn. In all other cases, i.e., when drawing on the virtual screen or when drawing in the frame buffer while transparent is "false," all pixels take the color of the color palette value as determined by palette offset processing based on the designated offset value.
</td>
</tr>
<tr>
<td><b>rotation</b></td>
<td><b>Rotation (0: no rotation; 1: 90 degrees; 2: 180 degrees; 3: 270 degrees):</b><br>
Sprite data is rotated clockwise by the designated number of degrees.
</td>
</tr>
<tr>
<td><b>isUpsideDown</b></td>
<td><b>Vertical flip (false: no flip; true: flip):</b><br>
When this value is "true," the sprite data is inverted vertically.
</td>
</tr>
<tr>
<td><b>isRightsideLeft</b></td>
<td><b>Horizontal flip (false: no flip; true: flip):</b><br>
When this value is "true," the sprite data is inverted horizontally.
</td>
</tr>
<tr>
<td><b>patternNo</b></td>
<td><b>Sprite number:</b><br>
The sprite data to which a command applies, designated by sprite data array index.
</td>
</tr>
</table>

<p>
Image processing designated in the sprite processing commands is performed in the order Rotate, Flip vertically, Flip horizontally.
</p><p>
A Java application creates sprite processing commands by calling the SpriteCanvas <A HREF="../../../../../com/vodafone/v10/graphics/sprite/SpriteCanvas.html#createCharacterCommand(int, boolean, int, boolean, boolean, int)"><CODE>createCharacterCommand()</CODE></A> method, designating the items in Table 2-1. It then uses these commands to issue drawing requests to the <A HREF="../../../../../com/vodafone/v10/graphics/sprite/SpriteCanvas.html#drawSpriteChar(short, short, short)"><CODE>drawSpriteChar()</CODE></A> method for drawing in the frame buffer, or to the <A HREF="../../../../../com/vodafone/v10/graphics/sprite/SpriteCanvas.html#drawBackground(short, short, short)"><CODE>drawBackground()</CODE></A> method for drawing on the virtual screen.
</p><p>

<h3>4. Virtual Screen/Frame Buffer/Real Screen</h3>

<div align="center">
<img src="doc-files/sprite_offscreens_en.gif" alt="sprite_offscreens_en.gif">
<p><strong>Figure 4. Image Buffers (Virtual Screen and Frame Buffer) and the Real Screen</strong></p>
</div>
<p>
Two kinds of screen buffers are used with SpriteCanvas, a "virtual screen" and "frame buffer." The final image seen by the user on the handset display is that copied from the frame buffer to the real screen. The relationship among these screens is illustrated in Figure 4.
</p>
<dl>
<p>
<dt><b>Real screen</b></dt>
<dd>The real screen is the screen image displayed on the LCD display of the handset as stored in video memory. Drawing operations in the real screen are displayed immediately on the LCD. The width and height of the real screen are obtained by issuing the Canvas class getWidth() and getHeight() methods.
</dd>
</p><p>
<dt><b>Virtual screen</b></dt>
<dd>The virtual screen is a kind of off-screen buffer, used for drawing a background image consisting of sprite data. The handset has only one virtual screen, of a fixed width and height. Dimensions for the virtual screen are obtained by means of the SpriteCanvas class static methods <A HREF="../../../../../com/vodafone/v10/graphics/sprite/SpriteCanvas.html#getVirtualWidth()"><CODE>getVirtualWidth()</CODE></A> and <A HREF="../../../../../com/vodafone/v10/graphics/sprite/SpriteCanvas.html#getVirtualHeight()"><CODE>getVirtualHeight()</CODE></A>.
</dd>
</p><p>
<dt><b>Frame buffer</b></dt>
<dd>The frame buffer is likewise a kind of off-screen buffer. The background drawn on the virtual screen is copied to the frame buffer, and sprite data is drawn on top of this background image. The frame buffer contents are then copied to the real screen for display to the user.
After the Java application creates the SpriteCanvas object, it must issue the  <A HREF="../../../../../com/vodafone/v10/graphics/sprite/SpriteCanvas.html#createFrameBuffer(int, int)"><CODE>createFrameBuffer()</CODE></A> method to create one frame buffer. The width and height of the frame buffer are designated at this time, and must be no larger than the real screen size. 
The frame buffer uses handset memory resources. When drawing by the SpriteCanvas object is not required, the frame buffer memory area can be freed using the <A HREF="../../../../../com/vodafone/v10/graphics/sprite/SpriteCanvas.html#disposeFrameBuffer()"><CODE>disposeFrameBuffer()</CODE></A> method, although any drawing data in the frame buffer at the time will be lost. Note also that if a method is called that assumes the existence of a frame buffer and none is currently created, an exception will be thrown.
</dd>
</p><p>
<dt><b>Screen copy</b></dt>
<dd>Contents of the virtual screen are copied to the frame buffer by calling the <A HREF="../../../../../com/vodafone/v10/graphics/sprite/SpriteCanvas.html#copyArea(int, int, int, int, int, int)"><CODE>copyArea()</CODE></A> method, designating the area to be copied and the destination coordinates.
The frame buffer contents are copied to the real screen by calling the <A HREF="../../../../../com/vodafone/v10/graphics/sprite/SpriteCanvas.html#drawFrameBuffer(int, int)"><CODE>drawFrameBuffer()</CODE></A> method, designating the copy destination coordinates on the real screen. The size of the area to be copied is the same as the frame buffer size. <br>
<br>
The position of the virtual screen contents can be changed (scrolled). This is done using the <A HREF="../../../../../com/vodafone/v10/graphics/sprite/SpriteCanvas.html#copyFullScreen(int, int)"><CODE>copyFullScreen()</CODE></A> method and designating the destination coordinates (dx, dy). In the example shown in Figure 5,  both dx and dy are designated as positive values.
<div align="center">
<img src="doc-files/sprite_scrolling_en.gif" alt="sprite_scrolling_en.gif">
<p><strong>Figure 5. Virtual Screen Scrolling</strong></p>
</div>
</dd>
</p>
</dl> 
If a portion of the image extends off the destination screen as a result of image move operations using <A HREF="../../../../../com/vodafone/v10/graphics/sprite/SpriteCanvas.html#copyArea(int, int, int, int, int, int)"><CODE>copyArea()</CODE></A>, <A HREF="../../../../../com/vodafone/v10/graphics/sprite/SpriteCanvas.html#drawFrameBuffer(int, int)"><CODE>drawFrameBuffer()</CODE></A> or <A HREF="../../../../../com/vodafone/v10/graphics/sprite/SpriteCanvas.html#copyFullScreen(int, int)"><CODE>copyFullScreen()</CODE></A>, that part is simply discarded without throwing an exception. 

<h3>5. Using the SpriteCanvas Class</h3>
<p>
An outline of the procedures when a Java application uses the SpriteCanvas class is shown in Figure 6. The names at the right of the figure are method names.
</p> 

<div align="center">
<img src="doc-files/sprite_ctrl_en.gif" alt="sprite_ctrl_en.gif">
<p><strong>Figure 6. Using the SpriteCanvas Class</strong></p>
</div>

<ol>
<li><p>The Java application creates an instance of SpriteCanvas or of its subclass. It sets in the SpriteCanvas constructor the maximum number of sprite data elements and the maximum number of color palette entries that can be registered. The SpriteCanvas object keeps a sprite data array and color palette array based on the designated numbers.
</p>
<li><p>The Java application registers the individual sprite data elements in the SpriteCanvas object using the <A HREF="../../../../../com/vodafone/v10/graphics/sprite/SpriteCanvas.html#setPattern(int, byte[])"><CODE>setPattern()</CODE></A> method, and registers the palette colors using the setPalette() method. Once the sprite data and color palette have been set, sprite data can be drawn.
</p>
<li><p>The Java application calls the Display object setCurrent() method and sets the created SpriteCanvas object as current Displayable.
</p>
<li><p>The Java application creates a frame buffer by calling the SpriteCanvas <A HREF="../../../../../com/vodafone/v10/graphics/sprite/SpriteCanvas.html#createFrameBuffer(int, int)"><CODE>createFrameBuffer()</CODE></A> method, designating the width and height of the frame buffer as parameters. Make sure these dimensions are no larger than the real screen dimensions. 
</p>
<li><p>For drawing sprite data, the Java application builds sprite processing commands by calling the <A HREF="../../../../../com/vodafone/v10/graphics/sprite/SpriteCanvas.html#createCharacterCommand(int, boolean, int, boolean, boolean, int)"><CODE>createCharacterCommand()</CODE></A> method. It then uses the <A HREF="../../../../../com/vodafone/v10/graphics/sprite/SpriteCanvas.html#drawSpriteChar(short, short, short)"><CODE>drawSpriteChar()</CODE></A> method to draw in the frame buffer and the <A HREF="../../../../../com/vodafone/v10/graphics/sprite/SpriteCanvas.html#drawBackground(short, short, short)"><CODE>drawBackground()</CODE></A> method to draw on the virtual screen, designating sprite processing commands and screen positions (in the frame buffer or virtual screen) in either case.
Contents of the virtual screen are scrolled using the <A HREF="../../../../../com/vodafone/v10/graphics/sprite/SpriteCanvas.html#copyFullScreen(int, int)"><CODE>copyFullScreen()</CODE></A> method, and are copied to the frame buffer using the <A HREF="../../../../../com/vodafone/v10/graphics/sprite/SpriteCanvas.html#copyArea(int, int, int, int, int, int)"><CODE>copyArea()</CODE></A> method.
The images drawn in the frame buffer are then copied to the real screen by means of the <A HREF="../../../../../com/vodafone/v10/graphics/sprite/SpriteCanvas.html#drawFrameBuffer(int, int)"><CODE>drawFrameBuffer()</CODE></A> method, making them visible to the user.
</p>
<li><p>When no sprite drawing is taking place, the <A HREF="../../../../../com/vodafone/v10/graphics/sprite/SpriteCanvas.html#disposeFrameBuffer()"><CODE>disposeFrameBuffer()</CODE></A> method may be called to free the frame buffer. Then when drawing is resumed, the frame buffer must be created anew using <A HREF="../../../../../com/vodafone/v10/graphics/sprite/SpriteCanvas.html#createFrameBuffer(int, int)"><CODE>createFrameBuffer()</CODE></A>.
</p>
<li><p>Use of SpriteCanvas is ended by setting a different Displayable subclass object to current Displayable.
</p>
</ol>

<p></p>
<p><b>Notes:</b></p>
<ul>
<li>In Figure 6 the settings using <A HREF="../../../../../com/vodafone/v10/graphics/sprite/SpriteCanvas.html#setPattern(int, byte[])"><CODE>setPattern()</CODE></A> and <A HREF="../../../../../com/vodafone/v10/graphics/sprite/SpriteCanvas.html#setPalette(int, int)"><CODE>setPalette()</CODE></A> are made right after SpriteCanvas is created; but this is not the only time these settings can be made. They may be set at any time so long as it is before the start of drawing on the virtual screen or frame buffer; and the settings may be changed at any time.
<li>While SpriteCanvas is set as current Displayable, drawing on the virtual screen can be performed using both the SpriteCanvas <A HREF="../../../../../com/vodafone/v10/graphics/sprite/SpriteCanvas.html#drawBackground(short, short, short)"><CODE>drawBackground()</CODE></A> method and the Graphics drawing-related methods. Drawing using the Graphics class is basically the same as that using the ordinary Canvas class functions. In this case the Canvas class paint() method is overridden and Graphics drawing methods are called. A difference from ordinary drawing using the Canvas class is that in order to display the drawn images on the handset, after copying the virtual screen contents to the frame buffer using the SpriteCanvas <A HREF="../../../../../com/vodafone/v10/graphics/sprite/SpriteCanvas.html#copyArea(int, int, int, int, int, int)"><CODE>copyArea()</CODE></A>, they must then be transferred to the real screen using  <A HREF="../../../../../com/vodafone/v10/graphics/sprite/SpriteCanvas.html#drawFrameBuffer(int, int)"><CODE>drawFrameBuffer()</CODE></A>.
<li>Since the purpose of the <A HREF="../../../../../com/vodafone/v10/graphics/sprite/SpriteCanvas.html#drawBackground(short, short, short)"><CODE>drawBackground()</CODE></A> method is to draw the background image, the transparency designation in a sprite processing command is ignored. Accordingly, pixels with value 0 are drawn using the palette color stored at index 0.
</ul>
<P>
<HR>

<P>
<!-- ======== INNER CLASS SUMMARY ======== -->


<!-- =========== FIELD SUMMARY =========== -->

<A NAME="fields_inherited_from_class_javax.microedition.lcdui.Canvas"><!-- --></A>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TD><B>Fields inherited from class javax.microedition.lcdui.Canvas</B></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE>DOWN, FIRE, GAME_A, GAME_B, GAME_C, GAME_D, KEY_NUM0, KEY_NUM1, KEY_NUM2, KEY_NUM3, KEY_NUM4, KEY_NUM5, KEY_NUM6, KEY_NUM7, KEY_NUM8, KEY_NUM9, KEY_POUND, KEY_STAR, LEFT, RIGHT, UP</CODE></TD>
</TR>
</TABLE>
&nbsp;
<!-- ======== CONSTRUCTOR SUMMARY ======== -->

<A NAME="constructor_summary"><!-- --></A>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=2><FONT SIZE="+2">
<B>Constructor Summary</B></FONT></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../../../../com/vodafone/v10/graphics/sprite/SpriteCanvas.html#SpriteCanvas(int, int)">SpriteCanvas</A></B>(int&nbsp;numPalettes,
             int&nbsp;numPatterns)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SpriteCanvas constructor</TD>
</TR>
</TABLE>
&nbsp;
<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=2><FONT SIZE="+2">
<B>Method Summary</B></FONT></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../com/vodafone/v10/graphics/sprite/SpriteCanvas.html#copyArea(int, int, int, int, int, int)">copyArea</A></B>(int&nbsp;sx,
         int&nbsp;sy,
         int&nbsp;fw,
         int&nbsp;fh,
         int&nbsp;tx,
         int&nbsp;ty)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Transfers a rectangular area of the virtual screen to the frame buffer.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../com/vodafone/v10/graphics/sprite/SpriteCanvas.html#copyFullScreen(int, int)">copyFullScreen</A></B>(int&nbsp;tx,
               int&nbsp;ty)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Copies the entire virtual screen to a designated position on the virtual screen.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;short</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../com/vodafone/v10/graphics/sprite/SpriteCanvas.html#createCharacterCommand(int, boolean, int, boolean, boolean, int)">createCharacterCommand</A></B>(int&nbsp;offset,
                       boolean&nbsp;transparent,
                       int&nbsp;rotation,
                       boolean&nbsp;isUpsideDown,
                       boolean&nbsp;isRightsideLeft,
                       int&nbsp;patternNo)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Creates sprite processing commands.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../com/vodafone/v10/graphics/sprite/SpriteCanvas.html#createFrameBuffer(int, int)">createFrameBuffer</A></B>(int&nbsp;fw,
                  int&nbsp;fh)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Creates a frame buffer.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../com/vodafone/v10/graphics/sprite/SpriteCanvas.html#disposeFrameBuffer()">disposeFrameBuffer</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Terminates use of the sprite function.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../com/vodafone/v10/graphics/sprite/SpriteCanvas.html#drawBackground(short, short, short)">drawBackground</A></B>(short&nbsp;command,
               short&nbsp;x,
               short&nbsp;y)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Draws a sprite in the virtual screen.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../com/vodafone/v10/graphics/sprite/SpriteCanvas.html#drawFrameBuffer(int, int)">drawFrameBuffer</A></B>(int&nbsp;tx,
                int&nbsp;ty)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Transfers the frame buffer contents to the real screen.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../com/vodafone/v10/graphics/sprite/SpriteCanvas.html#drawSpriteChar(short, short, short)">drawSpriteChar</A></B>(short&nbsp;command,
               short&nbsp;x,
               short&nbsp;y)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Draws a sprite in the frame buffer.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../com/vodafone/v10/graphics/sprite/SpriteCanvas.html#getVirtualHeight()">getVirtualHeight</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Gets the virtual screen height.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../com/vodafone/v10/graphics/sprite/SpriteCanvas.html#getVirtualWidth()">getVirtualWidth</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Gets the virtual screen width.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../com/vodafone/v10/graphics/sprite/SpriteCanvas.html#setPalette(int, int)">setPalette</A></B>(int&nbsp;index,
           int&nbsp;palette)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets a palette entry.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../com/vodafone/v10/graphics/sprite/SpriteCanvas.html#setPattern(int, byte[])">setPattern</A></B>(int&nbsp;index,
           byte[]&nbsp;data)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets sprite data.</TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_javax.microedition.lcdui.Canvas"><!-- --></A>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TD><B>Methods inherited from class javax.microedition.lcdui.Canvas</B></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE>getGameAction, getHeight, getKeyCode, getKeyName, getWidth, hasPointerEvents, hasPointerMotionEvents, hasRepeatEvents, hideNotify, isDoubleBuffered, keyPressed, keyReleased, keyRepeated, paint, pointerDragged, pointerPressed, pointerReleased, repaint, repaint, serviceRepaints, showNotify</CODE></TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_javax.microedition.lcdui.Displayable"><!-- --></A>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TD><B>Methods inherited from class javax.microedition.lcdui.Displayable</B></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE>addCommand, isShown, removeCommand, setCommandListener</CODE></TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.lang.Object"><!-- --></A>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TD><B>Methods inherited from class java.lang.Object</B></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE>equals, getClass, hashCode, notify, notifyAll, toString, wait, wait, wait</CODE></TD>
</TR>
</TABLE>
&nbsp;
<P>

<!-- ============ FIELD DETAIL =========== -->


<!-- ========= CONSTRUCTOR DETAIL ======== -->

<A NAME="constructor_detail"><!-- --></A>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=1><FONT SIZE="+2">
<B>Constructor Detail</B></FONT></TD>
</TR>
</TABLE>

<A NAME="SpriteCanvas(int, int)"><!-- --></A><H3>
SpriteCanvas</H3>
<PRE>
public <B>SpriteCanvas</B>(int&nbsp;numPalettes,
                    int&nbsp;numPatterns)</PRE>
<DL>
<DD>SpriteCanvas constructor<DD><DL>
<DT><B>Parameters:</B><DD><CODE>numPalettes</CODE> - Palette entry count<DD><CODE>numPatterns</CODE> - Sprite data count<DT><B>Throws:</B><DD><CODE>IllegalArgumentException</CODE> - if numPalettes or numPatterns is outside the 
 range of 1 to 256.</DL>
</DD>
</DL>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=1><FONT SIZE="+2">
<B>Method Detail</B></FONT></TD>
</TR>
</TABLE>

<A NAME="createFrameBuffer(int, int)"><!-- --></A><H3>
createFrameBuffer</H3>
<PRE>
public void <B>createFrameBuffer</B>(int&nbsp;fw,
                              int&nbsp;fh)</PRE>
<DL>
<DD>Creates a frame buffer.

 A frame buffer of the size designated by parameters fw and fh is created 
 internally.
 Make sure fw and fh are no larger than the real screen size.
 Only one frame buffer can exist in the system at one time.<DD><DL>
<DT><B>Parameters:</B><DD><CODE>fw</CODE> - Frame buffer width<DD><CODE>fh</CODE> - Frame buffer height<DT><B>Throws:</B><DD><CODE>IllegalStateException</CODE> - if the frame buffer already exists.<DD><CODE>IllegalArgumentException</CODE> - if the frame buffer size is larger than the 
 real screen.<DD><CODE>RuntimeException</CODE> - if the native sprite function failed to create a 
 frame buffer.</DL>
</DD>
</DL>
<HR>

<A NAME="disposeFrameBuffer()"><!-- --></A><H3>
disposeFrameBuffer</H3>
<PRE>
public void <B>disposeFrameBuffer</B>()</PRE>
<DL>
<DD>Terminates use of the sprite function.
 If no frame buffer was created, does nothing.</DL>
<HR>

<A NAME="getVirtualWidth()"><!-- --></A><H3>
getVirtualWidth</H3>
<PRE>
public static int <B>getVirtualWidth</B>()</PRE>
<DL>
<DD>Gets the virtual screen width.<DD><DL>
<DT><B>Returns:</B><DD>int - Virtual screen width</DL>
</DD>
</DL>
<HR>

<A NAME="getVirtualHeight()"><!-- --></A><H3>
getVirtualHeight</H3>
<PRE>
public static int <B>getVirtualHeight</B>()</PRE>
<DL>
<DD>Gets the virtual screen height.<DD><DL>
<DT><B>Returns:</B><DD>int - Virtual screen height</DL>
</DD>
</DL>
<HR>

<A NAME="setPalette(int, int)"><!-- --></A><H3>
setPalette</H3>
<PRE>
public void <B>setPalette</B>(int&nbsp;index,
                       int&nbsp;palette)</PRE>
<DL>
<DD>Sets a palette entry.

 A palette entry is a 24-bit color value.<DD><DL>
<DT><B>Parameters:</B><DD><CODE>index</CODE> - Palette index<DD><CODE>palette</CODE> - Palette entry<DT><B>Throws:</B><DD><CODE>ArrayIndexOutOfBoundsException</CODE> - if the palette index exceeds the value 
                                        designated in the constructor.<DD><CODE>RuntimeException</CODE> - if the setting operation failed in the native sprite 
                          function.</DL>
</DD>
</DL>
<HR>

<A NAME="setPattern(int, byte[])"><!-- --></A><H3>
setPattern</H3>
<PRE>
public void <B>setPattern</B>(int&nbsp;index,
                       byte[]&nbsp;data)</PRE>
<DL>
<DD>Sets sprite data.

 Pass sprite data as a byte array of 64 8-by-8-pixel palette index values.<DD><DL>
<DT><B>Parameters:</B><DD><CODE>index</CODE> - Sprite data index<DD><CODE>data</CODE> - Sprite data<DT><B>Throws:</B><DD><CODE>ArrayIndexOutOfBoundsException</CODE> - if the sprite data index exceeds the 
                                        value designated in the constructor.<DD><CODE>IllegalArgumentException</CODE> - if the array size is not 64.<DD><CODE>RuntimeException</CODE> - if the setting operation failed in the native sprite 
                          function.</DL>
</DD>
</DL>
<HR>

<A NAME="createCharacterCommand(int, boolean, int, boolean, boolean, int)"><!-- --></A><H3>
createCharacterCommand</H3>
<PRE>
public static short <B>createCharacterCommand</B>(int&nbsp;offset,
                                           boolean&nbsp;transparent,
                                           int&nbsp;rotation,
                                           boolean&nbsp;isUpsideDown,
                                           boolean&nbsp;isRightsideLeft,
                                           int&nbsp;patternNo)</PRE>
<DL>
<DD>Creates sprite processing commands.

 Image processing designated in the sprite processing commands is performed in 
 the order Rotate, Flip vertically, Flip horizontally.<DD><DL>
<DT><B>Parameters:</B><DD><CODE>offset</CODE> - Palette index offset (0 to 7)<DD><CODE>transparent</CODE> - Transparent color use (false: transparent color not used; 
                    true: transparent color used)<DD><CODE>rotation</CODE> - Clockwise rotation (0: no rotation; 1: 90 degrees; 2: 180 
                 degrees; 3: 270 degrees)<DD><CODE>isUpsideDown</CODE> - Vertical flip (false: no flip; true: flip)<DD><CODE>isRightsideLeft</CODE> - Horizontal flip (false: no flip; true: flip)<DD><CODE>patternNo</CODE> - Sprite data index<DT><B>Throws:</B><DD><CODE>IllegalArgumentException</CODE> - if an illegal value is designated.</DL>
</DD>
</DL>
<HR>

<A NAME="drawSpriteChar(short, short, short)"><!-- --></A><H3>
drawSpriteChar</H3>
<PRE>
public void <B>drawSpriteChar</B>(short&nbsp;command,
                           short&nbsp;x,
                           short&nbsp;y)</PRE>
<DL>
<DD>Draws a sprite in the frame buffer.

 Designate in the command parameter the sprite processing commands created 
 using createCharacterCommand().<DD><DL>
<DT><B>Parameters:</B><DD><CODE>command</CODE> - Sprite processing command<DD><CODE>x</CODE> - The x coordinate for sprite drawing<DD><CODE>y</CODE> - The y coordinate for sprite drawing<DT><B>Throws:</B><DD><CODE>IllegalArgumentException</CODE> - if the sprite data index set in the command 
       parameter exceeds the value designated in the constructor.<DD><CODE>IllegalStateException</CODE> - if the frame buffer was not yet created.<DD><CODE>RuntimeException</CODE> - if the drawing operation failed in the native sprite 
                          function.</DL>
</DD>
</DL>
<HR>

<A NAME="drawBackground(short, short, short)"><!-- --></A><H3>
drawBackground</H3>
<PRE>
public void <B>drawBackground</B>(short&nbsp;command,
                           short&nbsp;x,
                           short&nbsp;y)</PRE>
<DL>
<DD>Draws a sprite in the virtual screen.

 <p>
 Designate in the command parameter the sprite processing commands created 
 using createCharacterCommand(). Note that transparency settings in the 
 commands are ignored in the case of virtual screen drawing.
 </p><p>
 Drawing does not take place if the SpriteCanvas object has not been set to 
 current Displayable using the Display object setCurrent() method.
 </p><DD><DL>
<DT><B>Parameters:</B><DD><CODE>command</CODE> - Sprite processing command<DD><CODE>x</CODE> - The x coordinate for sprite drawing (8-pixel units)<DD><CODE>y</CODE> - The y coordinate for sprite drawing (8-pixel units)<DT><B>Throws:</B><DD><CODE>IllegalArgumentException</CODE> - if the sprite data index exceeds the value 
               designated in the constructor.<DD><CODE>RuntimeException</CODE> - if the drawing operation failed in the native sprite 
               function.</DL>
</DD>
</DL>
<HR>

<A NAME="copyArea(int, int, int, int, int, int)"><!-- --></A><H3>
copyArea</H3>
<PRE>
public void <B>copyArea</B>(int&nbsp;sx,
                     int&nbsp;sy,
                     int&nbsp;fw,
                     int&nbsp;fh,
                     int&nbsp;tx,
                     int&nbsp;ty)</PRE>
<DL>
<DD>Transfers a rectangular area of the virtual screen to the frame buffer.

 <p>
 The frame buffer contents are overwritten.
 </p><p>
 Transfer does not take place if the SpriteCanvas object has not been set to 
 current Displayable using the Display object setCurrent() method.
 </p><DD><DL>
<DT><B>Parameters:</B><DD><CODE>sx</CODE> - Upper left corner of rectangle (x coordinate on virtual screen)<DD><CODE>sy</CODE> - Upper left corner of rectangle (y coordinate on virtual screen)<DD><CODE>fw</CODE> - Width of the rectangular area<DD><CODE>fh</CODE> - Height of the rectangular area<DD><CODE>tx</CODE> - Destination x coordinate (in frame buffer)<DD><CODE>ty</CODE> - Destination y coordinate (in frame buffer)<DT><B>Throws:</B><DD><CODE>IllegalStateException</CODE> - if the frame buffer was not yet created.<DD><CODE>IllegalArgumentException</CODE> - if sx or sy is a negative value.<DD><CODE>IllegalArgumentException</CODE> - if fw or fh is larger than the frame buffer size.<DD><CODE>RuntimeException</CODE> - if the operation failed in the native sprite function.</DL>
</DD>
</DL>
<HR>

<A NAME="copyFullScreen(int, int)"><!-- --></A><H3>
copyFullScreen</H3>
<PRE>
public void <B>copyFullScreen</B>(int&nbsp;tx,
                           int&nbsp;ty)</PRE>
<DL>
<DD>Copies the entire virtual screen to a designated position on the virtual screen.

 <p>
 Copying does not take place if the SpriteCanvas object has not been set to 
 current Displayable using the Display object setCurrent() method.
 </p><DD><DL>
<DT><B>Parameters:</B><DD><CODE>tx</CODE> - Destination x coordinate<DD><CODE>ty</CODE> - Destination y coordinate<DT><B>Throws:</B><DD><CODE>RuntimeException</CODE> - if the operation failed in the native sprite function.</DL>
</DD>
</DL>
<HR>

<A NAME="drawFrameBuffer(int, int)"><!-- --></A><H3>
drawFrameBuffer</H3>
<PRE>
public void <B>drawFrameBuffer</B>(int&nbsp;tx,
                            int&nbsp;ty)</PRE>
<DL>
<DD>Transfers the frame buffer contents to the real screen.<DD><DL>
<DT><B>Parameters:</B><DD><CODE>tx</CODE> - Destination x coordinate (on the real screen)<DD><CODE>ty</CODE> - Destination y coordinate (on the real screen)<DT><B>Throws:</B><DD><CODE>IllegalStateException</CODE> - if the frame buffer was not yet created.<DD><CODE>RuntimeException</CODE> - if the transfer operation failed in the native 
 sprite function.</DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>

<!-- ========== START OF NAVBAR ========== -->
<A NAME="navbar_bottom"><!-- --></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../../index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;PREV CLASS&nbsp;
&nbsp;NEXT CLASS</FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../../../index.html" TARGET="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="SpriteCanvas.html" TARGET="_top"><B>NO FRAMES</B></A></FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY: &nbsp;INNER&nbsp;|&nbsp;<A HREF="#fields_inherited_from_class_javax.microedition.lcdui.Canvas">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL: &nbsp;FIELD&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<!-- =========== END OF NAVBAR =========== -->

<HR>
Copyright 2002,2003 Aplix Corporation. All rights reserved.  Aplix Confidential and Restricted.
</BODY>
</HTML>
