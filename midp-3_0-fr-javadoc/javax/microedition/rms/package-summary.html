<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.5.0_20) on Mon Nov 02 17:27:40 PST 2009 -->
<TITLE>
javax.microedition.rms (Mobile Information Device Profile 3.0)
</TITLE>

<META NAME="keywords" CONTENT="javax.microedition.rms package">

<LINK REL ="stylesheet" TYPE="text/css" HREF="../../../stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    parent.document.title="javax.microedition.rms (Mobile Information Device Profile 3.0)";
}
</SCRIPT>
<NOSCRIPT>
</NOSCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A>
<A HREF="#skip-navbar_top" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Package</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <FONT CLASS="NavBarFont1">Class</FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-use.html"><FONT CLASS="NavBarFont1"><B>Use</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<strong>MIDP3.0</strong></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../javax/microedition/pki/package-summary.html"><B>PREV PACKAGE</B></A>&nbsp;
&nbsp;NEXT PACKAGE</FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../index.html?javax/microedition/rms/package-summary.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="package-summary.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A>
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<H2>
Package javax.microedition.rms
</H2>
The Mobile Information Device Profile provides a mechanism for
MIDlets to persistently store data and later retrieve it.
<P>
<B>See:</B>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="#package_description"><B>Description</B></A>
<P>

<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Interface Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../javax/microedition/rms/RecordComparator.html" title="interface in javax.microedition.rms">RecordComparator</A></B></TD>
<TD>An interface defining a comparator which compares two records (in an
 implementation-defined manner) to see if they match or what their relative
 sort order is.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../javax/microedition/rms/RecordEnumeration.html" title="interface in javax.microedition.rms">RecordEnumeration</A></B></TD>
<TD>An interface representing a bidirectional record store Record enumerator.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../javax/microedition/rms/RecordFilter.html" title="interface in javax.microedition.rms">RecordFilter</A></B></TD>
<TD>An interface defining a filter which examines a record to see if it matches
 (based on an application-defined criteria).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../javax/microedition/rms/RecordListener.html" title="interface in javax.microedition.rms">RecordListener</A></B></TD>
<TD>A listener interface for receiving Record Changed/Added/Deleted events from a
 record store.</TD>
</TR>
</TABLE>
&nbsp;

<P>

<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Class Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../javax/microedition/rms/RecordStore.html" title="class in javax.microedition.rms">RecordStore</A></B></TD>
<TD>A class representing a record store.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../javax/microedition/rms/RecordStoreInfo.html" title="class in javax.microedition.rms">RecordStoreInfo</A></B></TD>
<TD>A class representing information about a RecordStore,
 including authorization mode, encryption status, writeable status, and size
 information.</TD>
</TR>
</TABLE>
&nbsp;

<P>

<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Exception Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../javax/microedition/rms/InvalidRecordIDException.html" title="class in javax.microedition.rms">InvalidRecordIDException</A></B></TD>
<TD>Thrown to indicate an operation could not be completed because the record ID
 was invalid.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../javax/microedition/rms/RecordStoreException.html" title="class in javax.microedition.rms">RecordStoreException</A></B></TD>
<TD>Thrown to indicate a general exception occurred in a record store operation.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../javax/microedition/rms/RecordStoreFullException.html" title="class in javax.microedition.rms">RecordStoreFullException</A></B></TD>
<TD>Thrown to indicate an operation could not be completed because the record
 store system storage is full.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../javax/microedition/rms/RecordStoreNotFoundException.html" title="class in javax.microedition.rms">RecordStoreNotFoundException</A></B></TD>
<TD>Thrown to indicate an operation could not be completed because the record
 store could not be found.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../javax/microedition/rms/RecordStoreNotOpenException.html" title="class in javax.microedition.rms">RecordStoreNotOpenException</A></B></TD>
<TD>Thrown to indicate that an operation was attempted on a closed record store.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../javax/microedition/rms/SecureRecordStoreException.html" title="class in javax.microedition.rms">SecureRecordStoreException</A></B></TD>
<TD>Thrown to indicate that a problem occurred during the process of Encrypting or
  Decrypting data of a Secure RecordStore.</TD>
</TR>
</TABLE>
&nbsp;

<P>
<A NAME="package_description"><!-- --></A><H2>
Package javax.microedition.rms Description
</H2>

<P>
The Mobile Information Device Profile provides a mechanism for
MIDlets to persistently store data and later retrieve it.

<p> Unless otherwise noted, passing a null argument to a
constructor or method in any class or interface in this package
MUST cause a NullPointerException to be thrown.</p>

<a name="PersistentStorage"></a>
<h2 class="section">Persistent Storage</h2>
    <p>
        The MIDP provides a mechanism for MIDlets to persistently store data
        and retrieve it later. This persistent storage mechanism, called the
        Record Management System (RMS), is modeled after a simple
        record-oriented database.
    </p>

<h3 class="section">Record Store</h3>
    <p>
        A record store consists of a collection of records that will remain
        persistent across multiple invocations of a MIDlet. The implementation is
        responsible for making its best effort to maintain the integrity of the
        MIDlet's record stores throughout the normal use of an implementation,
        including device reboots, power loss, etc. The actual process of 
        persisting record store data is the responsibility of the implementation,
        and MAY occur asynchronously, even as part of a cleanup process 
        when the device restarts.
    </p>

    <p>
        Record stores are created in platform-dependent locations, which
        are not exposed to MIDlets. The naming space for record stores
        is controlled at the MIDlet suite granularity. MIDlets within a
        MIDlet suite are allowed to create multiple record stores, as
        long as they are each given different names. LIBlet-owned record
        stores (i.e. those provisioned via <a href="packaging.html#LIBlet-Persistent-Data-URL-N"><code>LIBlet-Persistent-Data-URL-</code><i>&lt;n&gt;</i></a>) 
        will have a namespace based on the owning LIBlet. Note that multiple
        versions of the same LIBlet may exist on a device, and each of these
        LIBlet versions will have its own record store namespace. When a MIDlet suite
        is deleted from a platform, all record stores associated with
        its MIDlets MUST be deleted. When a LIBlet is deleted, all of its 
        associated record stores MUST also be deleted. MIDlets within a MIDlet suite
        can access one another's record stores directly. The RecordStore APIs
        allow for the explicit sharing of record stores if the
        MIDlet creating the RecordStore chooses to give such
        permission.
    </p>
<h4 class="section">Naming Record Stores</h4>
    <p>
        A MIDlet Suites's record stores are uniquely named using the unique name of the
        MIDlet suite plus the name of the record store. MIDlet suites
        are identified by the
        <a href="packaging.html#MIDlet-Vendor"><code class="attribute">MIDlet-Vendor</code></a>
        and
        <a href="packaging.html#MIDlet-Name"><code class="attribute">MIDlet-Name</code></a>
        attributes from the application descriptor.
    </p>
    <p>
        Record store names are case sensitive and MAY consist of any combination of
        between one and 32 Unicode characters inclusive. Record store names MUST be
        unique within the scope of a given MIDlet suite. In other words, MIDlets
        within a MIDlet suite are not allowed to create more than one record store
        with the same name; however, a MIDlet in one MIDlet suite is allowed to have a
        record store with the same name as a MIDlet in another MIDlet suite. In that
        case, the record stores are still distinct and separate.
    </p>

<h4 class="section">Provisioned Record Stores</h4>
    <p>
        Record stores MAY be created by the AMS during MIDlet suite or LIBlet installation.
        Record stores associated with the MIDlet Suite or LIBlet are created if the
        <a href="packaging.html#MIDlet-Persistent-Data-URL-N">
        <code>MIDlet-Persistent-Data-URL-&lt;n&gt;</code></a>
        or
        <a href="packaging.html#LIBlet-Persistent-Data-URL-N">
        <code>LIBlet-Persistent-Data-URL-&lt;n&gt;</code></a>
        attribute is present in their respective manifests.
        See <a href="provisioning.html#RMSDataProvisioning">RMS Data Provisioning</a>
        for more details.
    </p>

        <p>
        For MIDlet Suites, the record store created may be private or shared based
        on the value of the authmode field within the RMS data file pointed to by the
        <a href="packaging.html#MIDlet-Persistent-Data-URL-N">
        <code>MIDlet-Persistent-Data-URL-&lt;n&gt;</code></a> attribute.
        The value of the authmode field may be one of :
        <ul>
            <li>
                <A HREF="../../../javax/microedition/rms/RecordStore.html#AUTHMODE_ANY"><CODE>AUTHMODE_ANY</CODE></A>
                to allow access to any MIDlet suite,
            </li>
            <li>
                <A HREF="../../../javax/microedition/rms/RecordStore.html#AUTHMODE_APPLEVEL"><CODE>AUTHMODE_APPLEVEL</CODE></A>
                to allow access only to certain identified MIDlet suites, or
            </li>
            <li>
                <A HREF="../../../javax/microedition/rms/RecordStore.html#AUTHMODE_PRIVATE"><CODE>AUTHMODE_PRIVATE</CODE></A>
                to allow access only to the current MIDlet suite
            </li>
        </ul>
        </p>

        <p>
        For LIBlets, using the
        <a href="packaging.html#LIBlet-Persistent-Data-URL-N">
        <code>LIBlet-Persistent-Data-URL-&lt;n&gt;</code></a>
        attribute in the LIBlet manifest is the only way to create a
        record store that is owned by the LIBlet. A record store owned
        by a LIBlet MUST have its <code>authmode</code> set to
        <code><A HREF="../../../javax/microedition/rms/RecordStore.html#AUTHMODE_PRIVATE"><CODE>AUTHMODE_PRIVATE</CODE></A></code>.
        If the authmode field within the RMS data file for the LIBlet is set to any value other than 
        <code><A HREF="../../../javax/microedition/rms/RecordStore.html#AUTHMODE_PRIVATE"><CODE>AUTHMODE_PRIVATE</CODE></A></code>
        then the installation of the LIBlet MUST fail. Record stores created
        dynamically at runtime by LIBlet code are owned by the MIDlet suite
        of the execution environment in which the MIDlet is running. A
        MIDlet MAY open a <code>RecordStore</code> owned by a LIBlet it declares
        a dependency on by passing in the <code>RecordStore</code> name, LIBlet vendor, and LIBlet name to the
                <A HREF="../../../javax/microedition/rms/RecordStore.html#openRecordStore(java.lang.String, java.lang.String, java.lang.String)"><CODE>RecordStore.openRecordStore</CODE></A> (plaintext) or
                <A HREF="../../../javax/microedition/rms/RecordStore.html#openRecordStore(java.lang.String, java.lang.String, java.lang.String, java.lang.String)"><CODE>RecordStore.openRecordStore</CODE></A> (encrypted) method call.
        A MIDlet will not be able to access a LIBlet's record stores if its 
        MIDlet Suite did not declare a dependency on that LIBlet.
        </p>

        <p>
        It is possible for a provisioned RMS data file to contain no records; that is,
        the record store may be an empty record store and may be populated by a MIDlet
        at runtime. Provisioned record stores are available for use immediately upon creation.
        </p>

<h4 class="section">Shared Record Stores</h4>
    <p>
        Record store sharing is accomplished through the ability to name a
        RecordStore in another MIDlet suite, and by defining the
        accessibility rules related to the authentication of the two
        MIDlet suites.
    </p>

    <a name="RMSAppLevelAccessAuth"></a>
    <p>
        A MIDlet MAY control access to a shared record store using
        <A HREF="../../../javax/microedition/rms/RecordStore.html#AUTHMODE_APPLEVEL"><CODE>AUTHMODE_APPLEVEL</CODE></A>
        and the application level access control mechanism as described in 
        <a href="security_framework.html#AppLevelAccessAuth">Application
        Level Access Authorization</a>. If the MIDlet JAD/Manifest does not contain
        any of the access authorization attributes, the
        <A HREF="../../../javax/microedition/rms/RecordStore.html#AUTHMODE_APPLEVEL"><CODE>AUTHMODE_APPLEVEL</CODE></A> has no effect,
        and the authmode defaults to <A HREF="../../../javax/microedition/rms/RecordStore.html#AUTHMODE_ANY"><CODE>AUTHMODE_ANY</CODE></A>.
    <p>

    <p>
        Access controls are defined when record stores to be shared are
        created. Access controls are enforced when record stores are
        opened. A MIDlet suite defines access control by using access modes.
        The access modes allow private use or shareable with any other MIDlet suite.
        Shareable record stores of two kinds can be created :
        <ul>
            <li>All the other MIDlet suites have the same level of access privilege.</li>
            <li>The owning MIDlet suite identifies a set of MIDlet suites with which
            to share the record store using the application level access control.</li>
        </ul>
    </p>

    <p>
        Implementations MUST allow shared record stores to be opened concurrently
        by multiple applications. Successful updates to records MUST be visible to
        all applications when the update is complete. All <code>RecordListener</code>s
        to shared record stores must be notified after a record changes, regardless
        of the MIDlet that registered the listener and regardless of which MIDlet made
        the record update, both within and across MIDlets.
    </p>

<a name="RMSLocalEncryption"></a>
<h4 class="section">Secure Record Stores</h4>
    <p>
        An application may optionally request that a RecordStore's record data be encrypted
        on the device. If requested, the implementation MUST encrypt the records before
        they are persisted and automatically decrypt them when they are fetched.
        Implementations MUST encrypt secure record store data using either a hardware
        or software based cryptographically strong algorithm; an example is a symmetric-key cipher
        such as AES, DES, or Blowfish. The encryption key MUST be derived from the password supplied.
        Encrypted record stores are only as secure as the handling of the key;
        if a MIDlet stores the password within its code, security is not a
        reasonable expectation. For improved security, the MIDlet should ask the
        user for the password on each invocation of the MIDlet. The password is a
        <code>String</code> that consists of Unicode characters with a recommended
        minimum length of eight characters.
    </p>

    <p>
        Note: In <a href="#RMSInterchangeFormat">RMS Interchange file format</a>,
        the encryption algorithm and standards for key derivation are specified
        to ensure interoperability between devices, whereas for on-device
        encryption of record stores, the implementation may choose to use the
        same encryption standards as for the RMS interchange format or follow the
        guidelines mentioned above.
    </p>

<h4 class="section">Atomicity of RecordStore Access</h4>
    <p>
        No locking operations are provided in this API. Record store
        implementations MUST ensure that all individual record store
        operations are atomic, synchronous, and serialized so that no
        corruption occurs with multiple accesses, from within or across
        execution environments. However, if a MIDlet
        uses multiple threads to access a record store, it is the
        MIDlet's responsibility to coordinate this access, or unintended
        consequences may result. For example, if two threads in a MIDlet
        both call <code>RecordStore.setRecord()</code> concurrently on
        the same record, the record store will serialize these calls
        properly, and no RecordStore corruption will occur as a result.
        However, one of the writes will be subsequently overwritten by
        the other, which may cause problems within the
        MIDlet. Similarly, if an implementation performs transparent
        synchronization of a record store or other access, it
        is the implementation's responsibility to enforce exclusive access to
        the record store between the MIDlets and synchronization
        engine. The implementation MUST NOT serialize calls to
        RecordListeners across execution environments.  The implementation MUST call 
        the RecordListener callbacks in the order in which additions, deletions, or changes 
        took place on a record. Implementations MAY coalesce record listener callbacks 
        that resulted from multiple changes to a particular record. Implementations MUST NOT 
        discard any record listener callbacks that resulted from record additions, deletions, or changes. 
    </p>

    <p>
        This record store API uses long integers for time/date stamps,
        in the format used by <code>System.currentTimeMillis()</code>.
        The record store is time stamped with the last time it was
        modified. The record store also maintains a version, which is an
        integer that is incremented for each operation that modifies the
        contents of the record store. These are useful for
        synchronization engines as well as applications.
    </p>

<h4 class="section">Examples</h4>
    <p>
        The static method <code>RecordStore.openRecordStore</code> is overloaded 
        to enable applications to open and create different kinds of  
        RecordStores. Some code examples are given below. <br/>
                <ul>
                <li> Private RecordStore : <br/>

                <code>RecordStore rstore = RecordStore.openRecordStore ( &ldquo;MyRecordStore&rdquo;, true); <i>// create one if not found </i><br/>
                RecordStore rstore = RecordStore.openRecordStore (&ldquo;MyRecordStore&rdquo;, false); <i>// open only an existing RecordStore. </i><br/></code>
        </li>

                <li> Shared RecordStore :<br/>

                <code>int authmode = AUTHMODE_ANY; <i>// or AUTHMODE_APPLEVEL </i><br/>
                boolean writable = true;<i> // or false for read-only</i> <br/>
                RecordStore rstore = RecordStore.openRecordStore (&ldquo;MyRecordStore&rdquo;, true, AUTHMODE_ANY, writable); <br/></code>
        </li>

                <li> Private Encrypted RecordStore :<br/>

                <code>String password = getPasswordFromUser (); <br/>
                boolean writable = true; <i> // or false for read-only</i> <br/>
                RecordStore rstore = RecordStore.openRecordStore (&ldquo;MyRecordStore&rdquo;, true, AUTHMODE_PRIVATE, writable, password); <br/></code>
        </li>

                <li>Shared Encrypted RecordStore :<br/>

                <code>String password = getPasswordFromUser (); <br/>
                boolean writable = true; <i>// or false for read-only </i> <br/>
                RecordStore rstore = RecordStore.openRecordStore (&ldquo;MyRecordStore&rdquo;, true, AUTHMODE_APPLEVEL, writable, password);<br/></code>
        </li>

             <li> Shared RecordStore owned by another MIDlet Suite  or a LIBlet: <br/>

                <code>RecordStore rstore = RecordStore.openRecordStore ( &ldquo;OtherRecordStore&rdquo;, &ldquo;OtherVendor&rdquo;, &ldquo;OtherSuite&rdquo;); <br/></code>
        </li>

                <li>    
                 Encrypted Shared RecordStore owned by another MIDlet Suite  or a LIBlet: <br/>

                 <code> String password = getPasswordFromUser ();<br/>
                RecordStore rstore = RecordStore.openRecordStore ( &ldquo;OtherRecordStore&rdquo;, &ldquo;OtherVendor&rdquo;, &ldquo;OtherSuite&rdquo;, password);</code></li> 
                </ul>
    </p>

<h3 class="section">Record Tags</h3>
    <p>
        In MIDP 2.0 there was no efficient way to limit the enumeration on a subset
        of records in a record store. The RecordComparator and RecordFilter are
        applied on all the records of the record store. For a larger record
        store, finding a particular record results in call backs on the
        RecordComparator and RecordFilter for all the records in the store, which is
        a lot of overhead. The record tags provide an option to the developer
        to reduce this overhead significantly.
    </p>

    <p>
        Record tags allow MIDlet developers to associate an integer tag
        with each record. These tags are specified while calling <code>addRecord</code> or
        <code>setRecord</code> to the record store. The developer can now specify these tags
        when calling enumeration, and the implementation MUST only return those
        records for which the tags match.
    </p>

    <p>
        As an example, if a record store has 100
        records and the developer tags 10 records with the TAG value of
        10. The developer can now call enumeration with tag value 10
        and the implementation will only return those records with the tag
        value of 10. The developer has significantly reduced the number of
        records that need to be matched or compared.
    </p>

    <p>
        When records are added with the legacy <code>addRecord</code> and
        <code>setRecord</code> API's, the default value of tag MUST be 0.
    </p>

    <p>
        Tags are not required to be encrypted by the implementation when a record store is 
        locally encrypted. Since record tags may not be encrypted before being written 
        to persistent storage, MIDlet developers should avoid storing sensitive information 
        in clear text in record tags.
    </p>

<h3 class="section">Records</h3>
    <p>
        Records are arrays of bytes. Developers can use
        <code>DataInputStream</code> and <code>DataOutputStream</code>
        as well as <code>ByteArrayInputStream</code> and
        <code>ByteArrayOutputStream</code> to pack and unpack different
        data types into and out of the byte arrays.
    </p>

    <p>
        Records are uniquely identified within a given record store by
        their <code>recordId</code> , which is an integer value. This
        <code>recordId</code> is used as the primary key for the
        records. The first record created in a record store will have
        <code>recordId</code> equal to 1, and each subsequent
        <code>recordId</code> will monotonically increase by one. For
        example, if two records are added to a record store, and the
        first has a <code>recordId</code> of n, the next will have a
        <code>recordId</code> of n+1. MIDlets can create other indices
        by using the <code>RecordEnumeration</code> class.
    </p>

<h3 class="section">Persistent Data Interchange</h3>
    <p>
        Versions of the MIDP specification previous to MIDP 3.0 did not
        provide either for the provisioning or interchange of RMS record
        stores. This lack of a common RMS format resulted in limited
        application portability.
    </p>

    <p>
        MIDP 3.0 introduces support for a standalone secure
        <a href="#RMSInterchangeFormat">binary file format</a>
        that can be provisioned to a device by URL reference from
        MIDlet suite's JAD or manifest file.
    </p>

    <p>
        The <code>RecordStore</code> class supports serialization/deserialization of
        RMS data into this file format with optional encryption.
    </p>


<a name="RMSInterchangeFormat"></a>
<h4 class="section">RMS Interchange File Format</h4>
    <p>
        The RMS file format is used for persistent data provisioning as well
        as RMS interchange. Each RMS file MUST contain exactly one serialized record store.
    </p>

    <p>
        RMS data MAY be provisioned along with the application via
        standalone files and/or files embedded in the application JAR.
        RMS files are listed in the
        <a href="packaging.html#MIDlet-Persistent-Data-URL-N">
        <code>MIDlet-Persistent-Data-URL-&lt;n&gt;</code></a>
        attribute. See <a href="provisioning.html#RMSDataProvisioning">
        RMS Data Provisioning</a> for details.
    </p>

    <p>
        The recommended RMS file extension is <i>".rms"</i> and a MIME type is
        <i>"application/vnd.jcp.javame.midlet-rms"</i>.
    </p>

    <p>
        The RMS data is stored on the device in implementation specific format.
        In order for RMS data to be exchanged between implementations,
        it MUST be serialized into this implementation independent format.
    </p>

    <p>
        The following crypto algorithm, mode, padding scheme, message digest
        algorithms, and password based key derivation function MUST be supported.
    </p>
                <a name="RMSEncryptionStandards"></a>
        <ul>
            <li> Algorithms: <a href="http://www.csrc.nist.gov/publications/fips/fips197/fips-197.pdf"> AES 128-bit</a></li>
            <li> Algorithm Mode: CBC</li>
            <li> Padding Scheme: PKCS5Padding</li>
            <li> Message Digest Algorithm: SHA-1</li>
            <li> Password Based Key Derivation : <a href="http://www.ietf.org/rfc/rfc2898.txt">PBKDF2 (part of PKCS#5 v2.0)</a></li>
        </ul>

    <p> Cipher used for encryption is represented by a transformation string in
        the form of &ldquo;algorithm&rdquo; or &ldquo;algorithm/mode/padding&rdquo;
        (e.g. &ldquo;AES/CBC/PKCS5Padding&rdquo; is required to be supported).
        Note: this format is the same as defined by the <a href="http://jcp.org/en/jsr/detail?id=177">SATSA</a>
        specification for the cipher transformation string.
        The standard names for algorithm, mode, padding scheme and message digest algorithm are 
        defined in <a href="http://java.sun.com/javase/6/docs/technotes/guides/security/StandardNames.html">
        JCE specification</a>.
    </p>

    <p>
        The following tables define the format of a serialized RMS data
        file used for interchange of the RMS data.
        Both encrypted and unencrypted formats are supported. The file header contains 
        information on whether the file is encrypted or not. For an encrypted file, 
        the name of the Cipher Algorithm is placed in the Encryption Parameters portion 
        of the file and contains the name of the Cipher Algorithm used. The AMS MAY
        use this information to discover the required decryption algorithm.
    </p>

<a name="table18-1"/>
<a name="Table 18-1 : RMS Interchange File Format"/>
<table border="1">
    <tr>
        <th colspan="2">
            <p align="center">
            Table 18-1 : RMS Interchange File Format
            </p>
        </th>
    </tr>
    <tr>
        <a href="#rmsfileheader"/>
        <td>
            <p class="TableText">Header</p></a>
        </td>
        <td><p class="TableText"><i>RMS file header</i></p></td>
    </tr>
    <tr>
        <a href="#rmsencryptionparams"/>
        <td>
            <p class="TableText">EncryptionParameters</p></a>
        </td>
        <td><p class="TableText"><i>Encryption Parameters (optional). Only for encrypted files.</i></p></td>
    </tr>
    <tr>
        <a href="#rmsrecordstoredata"/>
        <td><p class="TableText">RecordStoreData</p></td>
        <td><p class="TableText"><i>Record store data stream. May be encrypted or unencrypted.</i></p></td>
    </tr>
    <tr>
        <td><p class="TableText">MessageDigestData</p></td>
        <td><p class="TableText"><i>MessageDigest for the stream consisting of EncryptionParameters and RecordStoreData</i></p></td>
    </tr>
</table>

<a name="rmsfileheader"/>
<table class="rms.exchange" border="1">
    <tr>
        <th colspan="3">
            <p class="TableText" align="center">
            Header
            </p>
        </th>
    </tr>
    <tr>
        <td>
            <p class="TableText">FileIdentifier</p>
        </td>
        <td>
            <p class="TableText">6 bytes (0x4d, 0x49, 0x44, 0x52, 0x4d, 0x53 or &ldquo;MIDRMS&rdquo;)</p>
        </td>
        <td>
            <p class="TableText"><i>A unique identifier of the file format.</i></p>
        </td>
    </tr>
    <tr>
        <td>
            <p class="TableText">VersionNumber</p>
        </td>
        <td>
            <p class="TableText">2 bytes</p>
            <p class="TableText">First byte: major version</p>
            <p class="TableText">Second byte: minor version</p>
        </td>
        <td>
            <p class="TableText"><i>RMS file format version</i>
            <br>
            For this revision of MIDP it must be 0x03, 0x00</p>
        </td>
    </tr>
    <tr>
        <td>
            <p class="TableText">Encrypted</p>
        </td>
        <td>
            <p class="TableText">1 byte (boolean)</p>
            <p class="TableText">0: plain-text (not encrypted) file</p>
            <p class="TableText">1: encrypted file.</p>
        </td>
        <td>
            <p class="TableText"><i>Encryption flag</i>
                <br>For encrypted files the EncryptionParameters section
                follows the header</p>
        </td>
    </tr>
    <tr>
        <td>
            <p class="TableText">MessageDigestAlgorithm</p>
        </td>
        <td>
            <p class="TableText">
                UTF String as specified by DataOutputStream.writeUTF
                <br>MessageDigestAlgorithmLength: 2 bytes
                <br>MessageDigestAlgorithmString: variable size
                     of <i>MessageDigestAlgorithmLength</i> bytes</p>
        </td>
        <td>
            <p class="TableText"><i>Message digest algorithm name.</i></p>
            <p class="TableText">e.g. "SHA-1"</p>
        </td>
    </tr>
</table>

<table class="rms.exchange" border="1">
    <tr>
        <a name="rmsencryptionparams"/>
        <th colspan="3">
            <p class="TableText" align="center">
            EncryptionParameters
            </p>
        </th>
    </tr>
    <tr>
        <td>
            <p class="TableText">EncryptionAlgorithm</p>
        </td>
        <td>
            <p class="TableText">UTF String as specified by DataOutputStream.writeUTF
            <br/>EncryptionAlgorithmLength: 2 bytes
            <br/>EncryptionAlgorithmString: variable size of <i>NameLength</i> bytes</p>
        </td>
        <td>
            <p class="TableText"><i>Cipher algorithm used in this file.</i></p>
            <p class="TableText">Supported values are</p>
            <ol>
                <li><p class="TableText">&ldquo;algorithm&rdquo;</p></li>
                <li><p class="TableText">&ldquo;algorithm/mode/padding&rdquo;</p></li>
            </ol>
            <p class="TableText">e.g. &ldquo;AES/CBC/PKCS5Padding&rdquo;</p>
        </td>
        </tr>
        <tr>
        <td>
            <p class="TableText">IVLength</p>
        </td>
        <td>
            <p class="TableText">4 bytes, high byte first as specified by DataOutputStream.writeInt()</p>
        </td>
        <td>
            <p class="TableText"><i>Cipher initialization vector length (if required by the cipher)
                    in bytes.</i></p>
            <p class="TableText">0: if initialization vector is not required by this algorithm</p>
        </td>
        </tr>
        <tr>
        <td>
            <p class="TableText">IV</p>
        </td>
        <td>
            <p class="TableText">Variable size of <i>IVLength</i> bytes</p>
        </td>
        <td>
            <p class="TableText"><i>Cipher initialization vector as byte array.</i></p>
            <p class="TableText">IV[0], ... IV[&lt;IVLength&gt;-1]</p>
        </td>
        </tr>
    <tr>
        <td>
            <p class="TableText">SaltLength</p>
        </td>
        <td>
            <p class="TableText">4 bytes, high byte first as specified by DataOutputStream.writeInt()</p>
        </td>
        <td>
            <p class="TableText"><i>Password salt length in bytes</i></p>
        </td>
    </tr>
    <tr>
        <td>
            <p class="TableText">Salt</p>
        </td>
        <td>
            <p class="TableText">Variable size of <i>SaltLength</i> bytes</p>
        </td>
        <td>
            <p class="TableText"><i>Password salt as byte array.</i></p>
            <p class="TableText">Salt[0], ... Salt[&lt;SaltLength&gt;-1]</p>
        </td>
    </tr>
    <tr>
        <td>
            <p class="TableText">IterationCount</p>
        </td>
        <td>
            <p class="TableText">4 bytes, high byte first as specified by DataOutputStream.writeInt()</p>
        </td>
        <td>
            <p class="TableText"><i>Password iteration count.</i></p>
            <p class="TableText">e.g. 1000</p>
        </td>
    </tr>
        <tr>
        <td>
            <p class="TableText">KeyLength</p>
        </td>
        <td>
            <p class="TableText">4 bytes, high byte first as specified by DataOutputStream.writeInt()</p>
        </td>
        <td>
            <p class="TableText"><i>Cipher key length.</i></p>
            <p class="TableText">e.g. 128 bits</p>
        </td>
        </tr>
</table>

<table class="rms.exchange" border="1">
    <a name="rmsrecorsdstoredata"/>
    <tr>
        <th class="TableText" colspan="3">
            <p align="center">
            RecordStoreData
            </p>
        </th>
    </tr>
    <tr>
        <a href="#rmsrecordstore"/>
        <td>
            <p class="TableText">RecordStore</p>
        </td>
        <td>
            <p class="TableText"><i>Record Store Attributes</i></p>
        </td>
    </tr>
    <tr>
        <td><p class="TableText">Record 1</p></td>
        <td><p class="TableText"><i>First record</i></p></td>
    </tr>
    <tr>
        <td colspan="2" align="center"><p class="TableText">...</p></td>
    </tr>
    <tr>
        <td><p class="TableText">Record N</p></td>
        <td><p class="TableText"><i>Last record</i></p></td>
    </tr>
</table>

<table class="rms.exchange" border="1">
    <a name="rmsrecorsdstore"/>
    <tr>
        <th colspan="3">
            <p class="TableText" align="center">
            RecordStore
            </p>
        </th>
    </tr>
        <tr>
        <td>
            <p class="TableText">Name</p>
        </td>
        <td>
            <p class="TableText">UTF String as specified by DataOutputStream.writeUTF</p>
            <p class="TableText">NameLength: 2 bytes</p>
            <p class="TableText">Name String: variable size of <i>NameLength</i> bytes</p>
        </td>
        <td>
            <p class="TableText"><i>Record store name</i></p>
        </td>
        </tr>
        <tr>
        <td>
            <p class="TableText">LastModified</p>
        </td>
        <td>
            <p class="TableText">8 bytes, high byte first as specified by DataOutputStream.writeLong()</p>
        </td>
        <td>
            <p class="TableText"><i>Time of last modification</i></p>
            <p class="TableText">As specified by System.currentTimeMillis()</p>
        </td>
        </tr>
    <tr>
        <td>
            <p class="TableText">Version</p>
        </td>
        <td>
            <p class="TableText">4 bytes, high byte first as specified by DataOutputStream.writeInt()</p>
        </td>
        <td>
            <p class="TableText"><i>Record store version</i></p>
        </td>
    </tr>
    <tr>
        <td>
            <p class="TableText">AuthMode</p>
        </td>
        <td>
            <p class="TableText">4 bytes, high byte first as specified by DataOutputStream.writeInt()</p>
        </td>
        <td>
            <p class="TableText"><i>Authorization mode</i></p>
            <p class="TableText">As specified by RecordStore.setMode(int, int)</p>
        </td>
    </tr>
        <tr>
        <td>
            <p class="TableText">Writeable</p>
        </td>
        <td>
            <p class="TableText">1 byte (boolean)</p>
            <p class="TableText">0: not writeable by other MIDlet suites (false)</p>
            <p class="TableText">1: writeable by other MIDlet suites (true)</p>
        </td>
        <td>
            <p class="TableText"><i>Write access</i></p>
        </td>
        </tr>
        <tr>
        <td>
            <p class="TableText">NumberOfRecords</p>
        </td>
        <td>
            <p class="TableText">4 bytes, high byte first as specified by DataOutputStream.writeInt()</p>
        </td>
        <td>
            <p class="TableText"><i>Number of records in this record store</i></p>
        </td>
        </tr>
</table>

<table class="rms.exchange" border="1">
    <tr>
        <th colspan="3">
            <p class="TableText" align="center">
            Record
            </p>
        </th>
    </tr>
        <tr>
        <td>
            <p class="TableText">RecordID</p>
        </td>
        <td>
            <p class="TableText">4 bytes, high byte first as specified by DataOutputStream.writeInt()</p>
        </td>
        <td>
            <p class="TableText"><i>ID of this Record</i></p>
        </td>
        </tr>
        <tr>
        <td>
            <p class="TableText">Tag</p>
        </td>
        <td>
            <p class="TableText">4 bytes, high byte first as specified by DataOutputStream.writeInt()</p>
        </td>
        <td>
            <p class="TableText"><i>Tag of this record</i></p>
            <p class="TableText">0: if this record has no tag</p>
        </td>
        </tr>
        <tr>
        <td>
            <p class="TableText">RecordDataSize</p>
        </td>
        <td>
            <p class="TableText">4 bytes, high byte first as specified by DataOutputStream.writeInt()</p>
        </td>
        <td>
            <p class="TableText"><i>Record size</i></p>
        </td>
        </tr>
    <tr>
        <td>
            <p class="TableText">RecordData</p>
        </td>
        <td>
            <p class="TableText">Variable size of <i>RecordDataSize</i> bytes</p>
        </td>
        <td>
            <p class="TableText"><i>Record data byte array</i></p>
            <p class="TableText">RecordData[0], ... RecordData[&lt;RecordDataSize&gt;-1]</p>
        </td>
    </tr>
</table>

<table class="rms.exchange" border="1">
    <tr>
        <th colspan="3">
            <p class="TableText" align="center">
            MessageDigest
            </p>
        </th>
    </tr>
        <tr>
        <td>
            <p class="TableText">MessageDigestLength</p>
        </td>
        <td>
            <p class="TableText">4 bytes, high byte first as specified by DataOutputStream.writeInt()</p>
        </td>
        <td>
            <p class="TableText"><i>Message digest length in bytes</i></p>
        </td>
        </tr>
    <tr>
        <td>
            <p class="TableText">MessageDigest</p>
        </td>
        <td>
            <p class="TableText">Variable size of <i>MessageDigestLength</i> bytes</p>
        </td>
        <td>
            <p class="TableText"><i>Message digest of the stream containing Encryption parameters and non-encrypted RecordStoreData
        as byte array:</i></p>
            <p class="TableText">MessageDigest[0], ... MessageDigest[&lt;MessageDigestLength&gt;-1]</p>
        </td>
        </tr>
</table>

    <p>
        Note : For Encrypted RMS Interchange Format files, the entire portion of the stream from 
        RecordStore Data to the end of the Message Digest is encrypted. 
    </p>

<h3 class="section">RMS Example</h3>
    <p>
        The following example uses the Record Management System to store and retrieve
        high scores for a game. In the example, high scores are stored in
        separate records, and sorted when necessary using a RecordEnumeration.
    </p>

<pre>   <code>
import javax.microedition.rms.*;
import java.io.DataOutputStream;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.ByteArrayInputStream;
import java.io.DataInputStream;
import java.io.EOFException;

/**
 * A class used for storing and showing game scores.
 */
public class RMSGameScores
implements RecordFilter, RecordComparator
{
    /*
     * The RecordStore used for storing the game scores.
     */
    private RecordStore recordStore = null;

    /*
     * The player name to use when filtering.
     */
    public static String playerNameFilter = null;

    /*
     * Part of the RecordFilter interface.
     */
    public boolean matches(byte[] candidate)
    throws IllegalArgumentException
    {
        // If no filter set, nothing can match it.
        if (this.playerNameFilter == null) {
            return false;
        }

        ByteArrayInputStream bais = new ByteArrayInputStream(candidate);
        DataInputStream inputStream = new DataInputStream(bais);
        String name = null;

        try {
            int score = inputStream.readInt();
            name = inputStream.readUTF();
        }
        catch (EOFException eofe) {
            System.out.println(eofe);
            eofe.printStackTrace();
        }
        catch (IOException eofe) {
            System.out.println(eofe);
            eofe.printStackTrace();
        }
        return (this.playerNameFilter.equals(name));
    }

    /*
     * Part of the RecordComparator interface.
     */
    public int compare(byte[] rec1, byte[] rec2)
    {
        // Construct DataInputStreams for extracting the scores from
        // the records.
        ByteArrayInputStream bais1 = new ByteArrayInputStream(rec1);
        DataInputStream inputStream1 = new DataInputStream(bais1);
        ByteArrayInputStream bais2 = new ByteArrayInputStream(rec2);
        DataInputStream inputStream2 = new DataInputStream(bais2);
        int score1 = 0;
        int score2 = 0;
        try {
            // Extract the scores.
            score1 = inputStream1.readInt();
            score2 = inputStream2.readInt();
        }
        catch (EOFException eofe) {
            System.out.println(eofe);
            eofe.printStackTrace();
        }
        catch (IOException eofe) {
            System.out.println(eofe);
            eofe.printStackTrace();
        }

        // Sort by score
        if (score1 &lt; score2) {
            return RecordComparator.PRECEDES;
        }
        else if (score1 &gt; score2) {
            return RecordComparator.FOLLOWS;
        }
        else {
            return RecordComparator.EQUIVALENT;
        }
    }

    /**
     * The constructor opens the underlying record store,
     * creating it if necessary.
     */
    public RMSGameScores()
    {
        //
        // Create a new record store for this example
        //
        try {
            recordStore = RecordStore.openRecordStore("scores", true);
        }
        catch (RecordStoreException rse) {
            System.out.println(rse);
            rse.printStackTrace();
        }
    }

    /**
     * Add a new score to the storage.
     *
     * @param score the score to store.
     * @param playerName the name of the play achieving this score.
     */
    public void addScore(int score, String playerName)
    {
        //
        // Each score is stored in a separate record, formatted with
        // the score, followed by the player name.
        //
        int recId;  // returned by addRecord but not used
        ByteArrayOutputStream baos = new ByteArrayOutputStream();
        DataOutputStream outputStream = new DataOutputStream(baos);
        try {
            // Push the score into a byte array.
            outputStream.writeInt(score);
            // Then push the player name.
            outputStream.writeUTF(playerName);
        }
        catch (IOException ioe) {
            System.out.println(ioe);
            ioe.printStackTrace();
        }

        // Extract the byte array
        byte[] b = baos.toByteArray();
        // Add it to the record store
        try {
            recId = recordStore.addRecord(b, 0, b.length);
        }
        catch (RecordStoreException rse) {
            System.out.println(rse);
            rse.printStackTrace();
        }
    }

    /**
     * A helper method for the printScores methods.
     */
    private void printScoresHelper(RecordEnumeration re)
    {
        try {
            while(re.hasNextElement()) {
                int id = re.nextRecordId();
                ByteArrayInputStream bais = new ByteArrayInputStream(recordStore.getRecord(id));
                DataInputStream inputStream = new DataInputStream(bais);
                try {
                    int score = inputStream.readInt();
                    String playerName = inputStream.readUTF();
                    System.out.println(playerName + " = " + score);
                }
                catch (EOFException eofe) {
                    System.out.println(eofe);
                    eofe.printStackTrace();
                }
            }
        }
        catch (RecordStoreException rse) {
            System.out.println(rse);
            rse.printStackTrace();
        }
        catch (IOException ioe) {
            System.out.println(ioe);
            ioe.printStackTrace();
        }
    }

    /**
     * This method prints all of the scores sorted by game score.
     */
    public void printScores()
    {
        try {
            // Enumerate the records using the comparator implemented
            // above to sort by game score.
            RecordEnumeration re = recordStore.enumerateRecords(null, this,
                            true);
            printScoresHelper(re);
        }
        catch (RecordStoreException rse) {
            System.out.println(rse);
            rse.printStackTrace();
        }
    }

    /**
     * This method prints all of the scores for a given player,
     * sorted by game score.
     */
    public void printScores(String playerName)
    {
        try {
            // Enumerate the records using the comparator and filter
            // implemented above to sort by game score.
            RecordEnumeration re = recordStore.enumerateRecords(this, this,
                            true);
            printScoresHelper(re);
        }
        catch (RecordStoreException rse) {
            System.out.println(rse);
            rse.printStackTrace();
        }
    }

    public static void main(String[] args)
    {
        RMSGameScores rmsgs = new RMSGameScores();
        rmsgs.addScore(100, "Alice");
        rmsgs.addScore(120, "Bill");
        rmsgs.addScore(80, "Candice");
        rmsgs.addScore(40, "Dean");
        rmsgs.addScore(200, "Ethel");
        rmsgs.addScore(110, "Farnsworth");
        rmsgs.addScore(220, "Farnsworth");
        System.out.println("All scores");
        rmsgs.printScores();
        System.out.println("Farnsworth's scores");
        RMSGameScores.playerNameFilter = "Farnsworth";
        rmsgs.printScores("Farnsworth");
    }
}
</code>
</pre>
<P>

<P>
<DL>
<DT><B>Since:</B></DT>
  <DD>MIDP 1.0</DD>
</DL>
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A>
<A HREF="#skip-navbar_bottom" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Package</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <FONT CLASS="NavBarFont1">Class</FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-use.html"><FONT CLASS="NavBarFont1"><B>Use</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<strong>MIDP3.0</strong></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../javax/microedition/pki/package-summary.html"><B>PREV PACKAGE</B></A>&nbsp;
&nbsp;NEXT PACKAGE</FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../index.html?javax/microedition/rms/package-summary.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="package-summary.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A>
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<HR>
<font size=-1><a href=mailto:jsr-271-comments@jcp.org>Send a comment or suggestion</a>Version 3.0 of Mobile Information Device Profile Specification<br>Java is a trademark or registered trademark of Sun Microsystems, Inc. in the US and other countries. Copyright 2002-2009 Motorola Inc. Portions copyright 1993-2002 Sun Microsystems, Inc. and Motorola, Inc. All Rights Reserved.</font>
</BODY>
</HTML>
