<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.5.0_20) on Mon Nov 02 17:27:40 PST 2009 -->
<TITLE>
javax.microedition.lcdui (Mobile Information Device Profile 3.0)
</TITLE>

<META NAME="keywords" CONTENT="javax.microedition.lcdui package">

<LINK REL ="stylesheet" TYPE="text/css" HREF="../../../stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    parent.document.title="javax.microedition.lcdui (Mobile Information Device Profile 3.0)";
}
</SCRIPT>
<NOSCRIPT>
</NOSCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A>
<A HREF="#skip-navbar_top" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Package</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <FONT CLASS="NavBarFont1">Class</FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-use.html"><FONT CLASS="NavBarFont1"><B>Use</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<strong>MIDP3.0</strong></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../javax/microedition/io/package-summary.html"><B>PREV PACKAGE</B></A>&nbsp;
&nbsp;<A HREF="../../../javax/microedition/lcdui/game/package-summary.html"><B>NEXT PACKAGE</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../index.html?javax/microedition/lcdui/package-summary.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="package-summary.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A>
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<H2>
Package javax.microedition.lcdui
</H2>
The APIs in the LCDUI package provide a set of features for implementing user
interfaces in MIDP applications.
<P>
<B>See:</B>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="#package_description"><B>Description</B></A>
<P>

<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Interface Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../javax/microedition/lcdui/Choice.html" title="interface in javax.microedition.lcdui">Choice</A></B></TD>
<TD>Choice defines an API for a user interface components implementing selection
 from predefined number of choices.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../javax/microedition/lcdui/CommandLayoutPolicy.html" title="interface in javax.microedition.lcdui">CommandLayoutPolicy</A></B></TD>
<TD>This interface is used to implement exact placement of commands.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../javax/microedition/lcdui/CommandListener.html" title="interface in javax.microedition.lcdui">CommandListener</A></B></TD>
<TD>This interface is used by applications which need to receive high-level
 events from the implementation.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../javax/microedition/lcdui/DisplayListener.html" title="interface in javax.microedition.lcdui">DisplayListener</A></B></TD>
<TD>The <code>DisplayListener</code> interface defines a series of methods that
 are called in response to <code>Display</code> events.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../javax/microedition/lcdui/ItemCommandListener.html" title="interface in javax.microedition.lcdui">ItemCommandListener</A></B></TD>
<TD>A listener type for receiving notification of commands that have been invoked
 on <A HREF="../../../javax/microedition/lcdui/Item.html" title="class in javax.microedition.lcdui"><CODE>Item</CODE></A> objects.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../javax/microedition/lcdui/ItemLayoutHint.html" title="interface in javax.microedition.lcdui">ItemLayoutHint</A></B></TD>
<TD>ItemLayoutHint is an interface to identify classes containing hints
 that control the layout of Items by subclasses of 
 <A HREF="../../../javax/microedition/lcdui/FormLayoutPolicy.html" title="class in javax.microedition.lcdui"><CODE>FormLayoutPolicy</CODE></A>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../javax/microedition/lcdui/ItemStateListener.html" title="interface in javax.microedition.lcdui">ItemStateListener</A></B></TD>
<TD>This interface is used by applications that need to receive events indicating
 changes in the internal state of the interactive items within a
 <A HREF="../../../javax/microedition/lcdui/Form.html" title="class in javax.microedition.lcdui"><CODE>Form</CODE></A> screen.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../javax/microedition/lcdui/ItemTraversalListener.html" title="interface in javax.microedition.lcdui">ItemTraversalListener</A></B></TD>
<TD>This interface is used by applications that need to receive events indicating
 changes in focus for <code>Items</code> in a <A HREF="../../../javax/microedition/lcdui/Form.html" title="class in javax.microedition.lcdui"><CODE>Form</CODE></A> screen.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../javax/microedition/lcdui/KeyListener.html" title="interface in javax.microedition.lcdui">KeyListener</A></B></TD>
<TD>Classes implementing this interface provide methods that are called when 
 user of the device will generate key events, for example, pressing the 
 keys available in a system keypad or keyboard.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../javax/microedition/lcdui/NotificationListener.html" title="interface in javax.microedition.lcdui">NotificationListener</A></B></TD>
<TD>
 This interface is used by applications that need to receive events indicating changes
 in the state of a <code>Notification</code>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../javax/microedition/lcdui/TabListener.html" title="interface in javax.microedition.lcdui">TabListener</A></B></TD>
<TD>This interface is used to receive events related to changes on a 
 <A HREF="../../../javax/microedition/lcdui/TabbedPane.html" title="class in javax.microedition.lcdui"><CODE>TabbedPane</CODE></A>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../javax/microedition/lcdui/TextEditorChangeListener.html" title="interface in javax.microedition.lcdui">TextEditorChangeListener</A></B></TD>
<TD>
 A listener for receiving notification of content changes and other editor events
 that have been invoked on <code>TextEditor</code> objects.</TD>
</TR>
</TABLE>
&nbsp;

<P>

<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Class Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../javax/microedition/lcdui/Alert.html" title="class in javax.microedition.lcdui">Alert</A></B></TD>
<TD>An alert is a screen that shows data to the user and waits for a certain
 period of time before proceeding to the next <code>Displayable</code>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../javax/microedition/lcdui/AlertType.html" title="class in javax.microedition.lcdui">AlertType</A></B></TD>
<TD>The <code>AlertType</code> provides an indication of the nature of alerts.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../javax/microedition/lcdui/AnimatedImage.html" title="class in javax.microedition.lcdui">AnimatedImage</A></B></TD>
<TD>An AnimatedImage is a special type of Image that encapsulates a series frames
 and the length of time that each frame should be shown.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../javax/microedition/lcdui/Canvas.html" title="class in javax.microedition.lcdui">Canvas</A></B></TD>
<TD>The <code>Canvas</code> class is a base class for writing applications that
 need to handle low-level events and to issue graphics calls for drawing to
 the display.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../javax/microedition/lcdui/CanvasItem.html" title="class in javax.microedition.lcdui">CanvasItem</A></B></TD>
<TD>
 CanvasItem abstracts the generic features of its subclasses, such as <A HREF="../../../javax/microedition/lcdui/TextEditor.html" title="class in javax.microedition.lcdui"><CODE>TextEditor</CODE></A> 
 component.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../javax/microedition/lcdui/ChoiceGroup.html" title="class in javax.microedition.lcdui">ChoiceGroup</A></B></TD>
<TD>A <code>ChoiceGroup</code> is a group of selectable elements intended to be
 placed within a <A HREF="../../../javax/microedition/lcdui/Form.html" title="class in javax.microedition.lcdui"><CODE>Form</CODE></A>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../javax/microedition/lcdui/Command.html" title="class in javax.microedition.lcdui">Command</A></B></TD>
<TD>The <code>Command</code> class is a construct that encapsulates the
 semantic information of an action.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../javax/microedition/lcdui/CustomItem.html" title="class in javax.microedition.lcdui">CustomItem</A></B></TD>
<TD>A CustomItem is customizable by subclassing to introduce new visual and
 interactive elements into <code>Forms</code>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../javax/microedition/lcdui/DateField.html" title="class in javax.microedition.lcdui">DateField</A></B></TD>
<TD>A <code>DateField</code> is an editable component for presenting date and
 time (calendar) information that may be placed into a <code>Form</code>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../javax/microedition/lcdui/Display.html" title="class in javax.microedition.lcdui">Display</A></B></TD>
<TD>The <code>Display</code> class provides a MIDlet with access to the
 device's user interface hardware resources.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../javax/microedition/lcdui/Displayable.html" title="class in javax.microedition.lcdui">Displayable</A></B></TD>
<TD>An object that has the capability of being placed on the display.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../javax/microedition/lcdui/FileSelector.html" title="class in javax.microedition.lcdui">FileSelector</A></B></TD>
<TD>The <code>FileSelector</code> class allows
 the user to select a file from file system to be loaded, saved, or to select
 a directory.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../javax/microedition/lcdui/Font.html" title="class in javax.microedition.lcdui">Font</A></B></TD>
<TD>The <code>Font</code> class represents fonts, which are used to render text
 in a visible way.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../javax/microedition/lcdui/Form.html" title="class in javax.microedition.lcdui">Form</A></B></TD>
<TD>A <code>Form</code> is a <code>Screen</code> that contains an arbitrary
 mixture of items: images, read-only text fields, editable text fields,
 editable date fields, gauges, choice groups, and custom items.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../javax/microedition/lcdui/FormLayoutPolicy.html" title="class in javax.microedition.lcdui">FormLayoutPolicy</A></B></TD>
<TD>FormLayoutPolicy is subclassed to provide custom layout algorithms.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../javax/microedition/lcdui/Gauge.html" title="class in javax.microedition.lcdui">Gauge</A></B></TD>
<TD>Implements a graphical display, such as a bar graph, of an integer value.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../javax/microedition/lcdui/Graphics.html" title="class in javax.microedition.lcdui">Graphics</A></B></TD>
<TD>Provides simple 2D geometric rendering capability.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../javax/microedition/lcdui/IdleItem.html" title="class in javax.microedition.lcdui">IdleItem</A></B></TD>
<TD>This class represents a dedicated UI component that can be used to render 
 content to the idle screen.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../javax/microedition/lcdui/Image.html" title="class in javax.microedition.lcdui">Image</A></B></TD>
<TD>The <code>Image</code> class is used to hold graphical image data.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../javax/microedition/lcdui/ImageItem.html" title="class in javax.microedition.lcdui">ImageItem</A></B></TD>
<TD>An item that can contain an image.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../javax/microedition/lcdui/Item.html" title="class in javax.microedition.lcdui">Item</A></B></TD>
<TD>A superclass for components that can be added to a <A HREF="../../../javax/microedition/lcdui/Form.html" title="class in javax.microedition.lcdui"><CODE>Form</CODE></A>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../javax/microedition/lcdui/List.html" title="class in javax.microedition.lcdui">List</A></B></TD>
<TD>A <code>Screen</code> containing list of choices.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../javax/microedition/lcdui/Menu.html" title="class in javax.microedition.lcdui">Menu</A></B></TD>
<TD>
 A visual container for <code>Commands</code> and other <code>Menus</code>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../javax/microedition/lcdui/Notification.html" title="class in javax.microedition.lcdui">Notification</A></B></TD>
<TD>Represents a small unobtrusive informational note to be shown to the user.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../javax/microedition/lcdui/NotificationType.html" title="class in javax.microedition.lcdui">NotificationType</A></B></TD>
<TD>Represents the Notification type (or category) used for
 grouping, sorting and filtering <A HREF="../../../javax/microedition/lcdui/Notification.html" title="class in javax.microedition.lcdui"><CODE>Notification</CODE></A> objects of the same type.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../javax/microedition/lcdui/ScalableImage.html" title="class in javax.microedition.lcdui">ScalableImage</A></B></TD>
<TD>A ScalableImage object encapsulates vector graphics content.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../javax/microedition/lcdui/Screen.html" title="class in javax.microedition.lcdui">Screen</A></B></TD>
<TD>The common superclass of all high-level user interface classes.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../javax/microedition/lcdui/Spacer.html" title="class in javax.microedition.lcdui">Spacer</A></B></TD>
<TD>A blank, non-interactive item that has a settable minimum size.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../javax/microedition/lcdui/StringItem.html" title="class in javax.microedition.lcdui">StringItem</A></B></TD>
<TD>An item that can contain a string.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../javax/microedition/lcdui/TabbedPane.html" title="class in javax.microedition.lcdui">TabbedPane</A></B></TD>
<TD>
 TabbedPane is a <A HREF="../../../javax/microedition/lcdui/Screen.html" title="class in javax.microedition.lcdui"><CODE>Screen</CODE></A> subclass that presents a series of
 <A HREF="../../../javax/microedition/lcdui/Screen.html" title="class in javax.microedition.lcdui"><CODE>Screens</CODE></A> to the users and allows them to navigate between screens
 by selecting the corresponding tab.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../javax/microedition/lcdui/TableLayoutPolicy.html" title="class in javax.microedition.lcdui">TableLayoutPolicy</A></B></TD>
<TD>TableLayoutPolicy displays the Items in a Form aligned in columns.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../javax/microedition/lcdui/Text.html" title="class in javax.microedition.lcdui">Text</A></B></TD>
<TD>The <tt>Text</tt> class is used to layout and render text within a specific
 area.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../javax/microedition/lcdui/TextBox.html" title="class in javax.microedition.lcdui">TextBox</A></B></TD>
<TD>The <code>TextBox</code> class is a <code>Screen</code> that allows the
 user to enter and edit text.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../javax/microedition/lcdui/TextEditor.html" title="class in javax.microedition.lcdui">TextEditor</A></B></TD>
<TD>
 A <code>TextEditor</code> is an editable text component that is drawn on a
 parent object; in LCDUI <A HREF="../../../javax/microedition/lcdui/Canvas.html" title="class in javax.microedition.lcdui"><CODE>Canvas</CODE></A> or <A HREF="../../../javax/microedition/lcdui/CustomItem.html" title="class in javax.microedition.lcdui"><CODE>CustomItem</CODE></A>
 (including <A HREF="../../../javax/microedition/lcdui/IdleItem.html" title="class in javax.microedition.lcdui"><CODE>IdleItem</CODE></A>).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../javax/microedition/lcdui/TextField.html" title="class in javax.microedition.lcdui">TextField</A></B></TD>
<TD>A <code>TextField</code> is an editable text component that may be placed
 into a <A HREF="../../../javax/microedition/lcdui/Form.html" title="class in javax.microedition.lcdui"><CODE>Form</CODE></A>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../javax/microedition/lcdui/Ticker.html" title="class in javax.microedition.lcdui">Ticker</A></B></TD>
<TD>Implements a &quot;ticker-tape&quot;, a piece of text that runs continuously
 across the display.</TD>
</TR>
</TABLE>
&nbsp;

<P>

<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Exception Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../javax/microedition/lcdui/DisplayCapabilityException.html" title="class in javax.microedition.lcdui">DisplayCapabilityException</A></B></TD>
<TD>
 Indicates that a Display's capabilities are insufficient for the requested
 operation.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../javax/microedition/lcdui/FontFormatException.html" title="class in javax.microedition.lcdui">FontFormatException</A></B></TD>
<TD>
 Indicates that a font format is not supported, or that font data is invalid
 or is not conformant with the specified font format
 (OpenType with TrueType outlines).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../javax/microedition/lcdui/NotificationException.html" title="class in javax.microedition.lcdui">NotificationException</A></B></TD>
<TD>
 Indicates that an operation on a Notification has failed.</TD>
</TR>
</TABLE>
&nbsp;

<P>
<A NAME="package_description"><!-- --></A><H2>
Package javax.microedition.lcdui Description
</H2>

<P>
The APIs in the LCDUI package provide a set of features for implementing user
interfaces in MIDP applications.

<p>
    Unless otherwise noted, passing a null argument to a
    constructor or method in any class or interface in this package
    MUST cause a NullPointerException to be thrown.
</p>

<h2 class="section">User Interface</h2>
    <p>
        The User Interface features in MIDP have been specifically designed with mobile
        information devices in mind (i.e., mobile phones and pagers). These
        devices differ from desktop systems in many ways, especially how the
        user interacts with them. The following UI-related requirements are
        important when designing the user interface API:
    </p>
        <ul>
            <li>
                The devices and applications should be useful to users who are
                not necessarily experts in using computers.
            </li>
            <li>
                The devices and applications should be useful in situations
                where the user cannot pay full attention to the application. For
                example, many phone-type devices will be operated with one hand.
            </li>
            <li>
                The form factors and UI concepts of the device differ between
                devices, especially from desktop systems. For example, the display
                sizes are smaller, and the input devices do not always include pointing
                devices.
            </li>
            <li>
                The applications run on MIDs should have UIs that are compatible
                with the native applications so that the user finds them easy to use.
            </li>
        </ul>
    <p>
        In addition, these devices may have limited memory and processing power.
        Since the user interface is a primary consumer of such resources,
        the API's have been designed to avoid the creation of garbage objects and
        other performance issues wherever possible.
    </p>

<h2 class="section">Structure of the MIDP UI API</h2>
    <p>
        The API is logically composed of two sets of APIs: the high-level and
        the low-level.
    </p>
    <p>
        The high-level API is designed for applications where portability across
        devices is important. To achieve this portability, the high-level API
        employs a high level of abstraction and provides less control
        over the look and feel of the user interface. This abstraction is further
        manifested in the following ways:
    </p>
        <ul>
            <li>
                The actual drawing to the MID's display is performed by the
                implementation. Applications have limited influence over the visual appearance (e.g.,
                shape, color, font, etc.) of the components.
            </li>
            <li>
                Navigation, scrolling, and other primitive interaction is
                encapsulated by the implementation, and the application does not have control over
                these interactions.
            </li>
            <li>
                Applications cannot access concrete input devices like specific
                individual keys.
            </li>
        </ul>
    <p>
        In other words, when using the high-level API, it is assumed that
        the underlying implementation will do the necessary adaptation to the
        device's hardware and native UI style. The classes that provide the
        high-level API are the subclasses of <A HREF="../../../javax/microedition/lcdui/Screen.html" title="class in javax.microedition.lcdui"><CODE>Screen</CODE></A>.
    </p>
    <p>
        The low-level API, on the other hand, provides very little
        abstraction. This API is designed for applications that need precise
        placement and control of graphic elements, as well as access to
        low-level input events. A typical example of such an application
        would be a game.
    </p>
    <p>Using the low-level API, an application can:</p>
        <ul>
            <li> Have full control of what is drawn on the display.</li>
            <li> Listen for primitive events from keys and touchscreens.</li>
        </ul>
    <p>
        The classes that provide the low-level API are <A HREF="../../../javax/microedition/lcdui/Canvas.html" title="class in javax.microedition.lcdui"><CODE>Canvas</CODE></A> and <A HREF="../../../javax/microedition/lcdui/Graphics.html" title="class in javax.microedition.lcdui"><CODE>Graphics</CODE></A>.
    </p>
    <p>
        Applications that program to the low-level API are not guaranteed
        to be portable, since use of the low-level API involves
        details that are specific to a particular device. It is recommended
        that applications using low-level API be written such that they can
        adapt to different device characteristics
        wherever possible. This means that the applications
        should not directly assume the existence of any keys other than those
        defined in the <code>Canvas</code> class, and they should not depend
        on a specific screen size. Rather, the application game-key event
        mapping mechanism should be used instead of concrete keys, and the
        application should inquire about the size of the display and adjust
        itself accordingly.
    </p>

<h3 class="section"> Class Hierarchy</h3>
    <p>
        The <code>Display</code> class represents a given MIDlet's use of a particular display
        device and it also provides methods to retrieve information about that display device's capabilities.
        For each active <code>MIDlet</code>, a <code>Display</code> object may be obtained for each display
        device; a primary <code>Display</code> object is provided for accessing the device's main display.
        In addition to the primary Display, there may be other display hardware that is an integral
        part of device, such as the second screen on the outside of the mobile phone's flip; these display hardware
        are classified as Built-In displays. There may be other display resources that are available to the device
        via a suitable connection, these are classified as Auxiliary displays.

        In addition to the primary Display, one or more Built-in and Auxiliary displays may be available to the MIDlet.
        The <A HREF="../../../javax/microedition/lcdui/Display.html" title="class in javax.microedition.lcdui"><CODE>Display</CODE></A> class provides more details on accessing Displays.
    </p>

    <p>
        The <code>Display</code> class is also responsible for controlling access to a display device
        if multiple <code>MIDlets</code> are trying to use simultaneously. Display objects have a state that
        indicates their relative priority for using the display device.
    </p>

    <p>
        The main abstraction of the UI is a <code>Displayable</code>
        object, which encapsulates device-specific graphics rendering with user
        input. Only one <code>Displayable</code> may be shown at a time on a given <code>Display</code>,
        and the user can see and interact with only contents of that <code>Displayable</code>.
        A <code>Displayable</code> is made visible by calling the <code>setCurrent()</code>
        method of the appropriate <code>Display</code>. When a <code>Displayable</code> is made current,
        it replaces the previous <code>Displayable</code>.
    </p>

    <p>
        The <code>Screen</code> class is a subclass of <code>Displayable</code>
        that takes care of all user interaction with high-level user interface
        component. The <code>Screen</code> subclasses handle rendering,
        interaction, traversal, and scrolling, with only higher-level events
        being passed on to the application.
    </p>
    <p>
        The rationale behind this design is based on the different display
        and input solutions found in MIDP devices. These differences imply that
        the component layout, scrolling, and focus traversal will be
        implemented differently on different devices. If an application were
        required to be aware of these issues, portability would be compromised.
        Simple screenfuls also organize the user interface into manageable
        pieces, resulting in user interfaces that are easy to use and learn.
    </p>
    <p> There are three categories of <code>Displayable</code> objects: </p>
        <ul>
            <li>
                Screens that encapsulate a complex user interface component
                (e.g., classes <code>List</code> or <code>TextBox</code>). The
                structure of these screens is predefined, and the application cannot
                add other components to these screens.
            </li>
            <li>
                Generic screens (instances of the <code>Form</code> class) that
                can contain <code>Item</code> objects to represent user interface
                components. The application can populate <code>Form</code> objects
                with an arbitrary number of text, image, and other components; however,
                it is recommended that <code>Form</code> objects be kept simple and
                that they should be used to contain only a few, closely-related user
                interface components.
            </li>
            <li>
                Screens that are used in context of the low-level API (i.e.,
                subclasses of class <code>Canvas</code>).
            </li>
        </ul>
    <p>
        Each <code>Displayable</code> can have a title, a <code>Ticker</code>
        and a set of <code>Commands</code> attached to it.
    </p>

<h3 class="section">Class Overview</h3>
    <p>
        Many applications will utilize screens with predefined structures like <code>List</code>,
        <code>TextBox</code>, and <code>Alert</code>. These classes are used in the following ways:
    </p>
        <ul>
            <li>
                <code>List</code> is used when the user should select from a
                predefined set of choices.
            </li>
            <li>
                <code>TextBox</code> is used when asking textual input.
            </li>
            <li>
                <code>Alert</code> is used to display temporary messages
                containing text and images.
            </li>
        </ul>
    <p>
        A special class <code>Form</code> is defined for cases where
        screens with a predefined structure are not sufficient. For example, an
        application may have two <code>TextFields</code>, or a <code>TextField</code>
        and a simple <code>ChoiceGroup</code>. Although the <code>Form</code>
        class allows creation of arbitrary combinations of components, developers
        should keep the limited display size in mind and create only simple <code>Forms</code>.
    </p>
    <p>
        <code>Form</code> is designed to contain a small number of closely
        related UI elements. These elements are the subclasses of <code>Item</code>:
        <code>ImageItem</code>, <code>StringItem</code>, <code>TextField</code>,
        <code>ChoiceGroup</code>, <code>Gauge</code>, and <code>CustomItem</code>.
        The classes <code>ImageItem</code> and <code>StringItem</code> are
        convenience classes that make certain operations with <code>Form</code>
        and <code>Alert</code> easier. By subclassing <code>CustomItem</code>
        application developers can introduce <code>Items</code> with a new
        visual representation and interactive elements. If the components do
        not all fit on the screen, the implementation may either make the form
        scrollable or implement some components so that they can either popup
        in a new screen or expand when the user edits the element.
    </p>
    <p>
        A default layout scheme is provided for laying out the <code>Items</code> in
        a <code>Form</code>, but the developer may implement a custom layout scheme by
        creating a subclass of <code>FormLayoutPolicy</code>.
    </p>

<h3 class="section"> Interplay with Application Manager</h3>
    <p>
        The user interface, like any other resource in the API, is to be
        controlled according to the principle of MIDP application management.
        The UI may assume the following conditions from the application management
        software:
    </p>
    <ul>
        <li>
            <code>getDisplay()</code> and <code>getDisplays()</code> are callable starting from
            the <code>MIDlet</code>'s constructor until <code>destroyApp()</code> has returned.
        </li>
        <li>
            The <code>Display</code> objects for built-in  display devices are the same until
            <code>destroyApp()</code> is called.
        </li>
        <li>
            The <code>Displayable</code> object set by <code>setCurrent()</code>
            is not changed by the application manager.
        </li>
    </ul>

    <p>
        The application manager assumes the following application behavior with respect to
        the <code>MIDlet</code> events :
    </p>
    <ul>
        <li>
            The application may call <code>setCurrent()</code> to display its first
            screen at any point after its constructor has been called. However, the
            <code>Displayable</code> will be shown by the application manager only after
            <code> startApp()</code> returns.
        </li>
        <li>
            <code>destroyApp</code> - The application should release resources and objects.
        </li>
    </ul>

<a name="events"></a>
<h2 class="section">Event Handling</h2>
    <p>
        User interaction generates events, and the implementation notifies the
        application of the events by making corresponding callbacks. There are
        four kinds of UI callbacks:
    </p>
    <ul>
        <li>
            Abstract commands that are part of the high-level API
        </li>
        <li>
            Low-level events that represent single key presses and releases
            (and pointer events, if a pointer is available)
        </li>
        <li>
            Calls to the <code>paint()</code> method of a <code>Canvas</code>
            class
        </li>
        <li>
            Calls to a <code>Runnable</code> object's <code>run()</code>
            method requested by a call to <code>callSerially()</code> of class <code>Display</code>
        </li>
    </ul>
    <p>
        All UI callbacks are serialized, so they will never occur in
        parallel. That is, the implementation will never call an callback
        before a prior call to <em>any</em> other callback has returned. This
        property enables applications to be assured that processing of a
        previous user event will have completed before the next event is
        delivered. If multiple UI callbacks are pending, the next is called as
        soon as possible after the previous UI callback returns. The
        implementation also guarantees that the call to <code>run()</code>
        requested by a call to <code>callSerially()</code> is made after any
        pending repaint requests have been satisfied.
    </p>

    <p>
        There is one exception to the callback serialization rule, which
        occurs when the <A HREF="../../../javax/microedition/lcdui/Canvas.html#serviceRepaints()"><CODE>Canvas.serviceRepaints</CODE></A> method is called. This method causes the <code>Canvas.paint</code>
        method to be called and waits for it to complete. This occurs even if
        the caller of <code>serviceRepaints</code> is itself within an active
        callback. There is further discussion of this issue <a href="#concurrency">below</a>.
     </p>

     <p>
        The following callbacks are all serialized with respect to each other :
     </p>
    <ul>
        <li> <A HREF="../../../javax/microedition/lcdui/Canvas.html#hideNotify()"><CODE>Canvas.hideNotify</CODE></A> </li>
        <li> <A HREF="../../../javax/microedition/lcdui/Canvas.html#keyPressed(int)"><CODE>Canvas.keyPressed</CODE></A> </li>
        <li> <A HREF="../../../javax/microedition/lcdui/Canvas.html#keyRepeated(int)"><CODE>Canvas.keyRepeated</CODE></A> </li>
        <li> <A HREF="../../../javax/microedition/lcdui/Canvas.html#keyReleased(int)"><CODE>Canvas.keyReleased</CODE></A> </li>
        <li> <A HREF="../../../javax/microedition/lcdui/Canvas.html#paint(javax.microedition.lcdui.Graphics)"><CODE>Canvas.paint</CODE></A> </li>
        <li> <A HREF="../../../javax/microedition/lcdui/Canvas.html#pointerDragged(int, int)"><CODE>Canvas.pointerDragged</CODE></A> </li>
        <li> <A HREF="../../../javax/microedition/lcdui/Canvas.html#pointerPressed(int, int)"><CODE>Canvas.pointerPressed</CODE></A> </li>
        <li> <A HREF="../../../javax/microedition/lcdui/Canvas.html#pointerReleased(int, int)"><CODE>Canvas.pointerReleased</CODE></A> </li>
        <li> <A HREF="../../../javax/microedition/lcdui/Canvas.html#showNotify()"><CODE>Canvas.showNotify</CODE></A> </li>
        <li> <A HREF="../../../javax/microedition/lcdui/Canvas.html#sizeChanged(int, int)"><CODE>Canvas.sizeChanged</CODE></A> </li>
        <li> <A HREF="../../../javax/microedition/lcdui/CommandListener.html#commandAction(javax.microedition.lcdui.Command, javax.microedition.lcdui.Displayable)"><CODE>CommandListener.commandAction</CODE></A> </li>
        <li> <A HREF="../../../javax/microedition/lcdui/CustomItem.html#getMinContentHeight()"><CODE>CustomItem.getMinContentHeight</CODE></A> </li>
        <li> <A HREF="../../../javax/microedition/lcdui/CustomItem.html#getMinContentWidth()"><CODE>CustomItem.getMinContentWidth</CODE></A> </li>
        <li> <A HREF="../../../javax/microedition/lcdui/CustomItem.html#getPrefContentHeight(int)"><CODE>CustomItem.getPrefContentHeight</CODE></A> </li>
        <li> <A HREF="../../../javax/microedition/lcdui/CustomItem.html#getPrefContentWidth(int)"><CODE>CustomItem.getPrefContentWidth</CODE></A> </li>
        <li> <A HREF="../../../javax/microedition/lcdui/CustomItem.html#hideNotify()"><CODE>CustomItem.hideNotify</CODE></A> </li>
        <li> <A HREF="../../../javax/microedition/lcdui/CustomItem.html#keyPressed(int)"><CODE>CustomItem.keyPressed</CODE></A> </li>
        <li> <A HREF="../../../javax/microedition/lcdui/CustomItem.html#keyRepeated(int)"><CODE>CustomItem.keyRepeated</CODE></A> </li>
        <li> <A HREF="../../../javax/microedition/lcdui/CustomItem.html#keyReleased(int)"><CODE>CustomItem.keyReleased</CODE></A> </li>
        <li> <A HREF="../../../javax/microedition/lcdui/CustomItem.html#paint(javax.microedition.lcdui.Graphics, int, int)"><CODE>CustomItem.paint</CODE></A> </li>
        <li> <A HREF="../../../javax/microedition/lcdui/CustomItem.html#pointerDragged(int, int)"><CODE>CustomItem.pointerDragged</CODE></A> </li>
        <li> <A HREF="../../../javax/microedition/lcdui/CustomItem.html#pointerPressed(int, int)"><CODE>CustomItem.pointerPressed</CODE></A> </li>
        <li> <A HREF="../../../javax/microedition/lcdui/CustomItem.html#pointerReleased(int, int)"><CODE>CustomItem.pointerReleased</CODE></A> </li>
        <li> <A HREF="../../../javax/microedition/lcdui/CustomItem.html#showNotify()"><CODE>CustomItem.showNotify</CODE></A> </li>
        <li> <A HREF="../../../javax/microedition/lcdui/CustomItem.html#sizeChanged(int, int)"><CODE>CustomItem.sizeChanged</CODE></A> </li>
        <li> <A HREF="../../../javax/microedition/lcdui/CustomItem.html#traverse(int, int, int, int[])"><CODE>CustomItem.traverse</CODE></A> </li>
        <li> <A HREF="../../../javax/microedition/lcdui/CustomItem.html#traverseOut()"><CODE>CustomItem.traverseOut</CODE></A> </li>
        <li> <A HREF="../../../javax/microedition/lcdui/Displayable.html#sizeChanged(int, int)"><CODE>Displayable.sizeChanged</CODE></A> </li>
        <li> <A HREF="../../../javax/microedition/lcdui/DisplayListener.html#displayAdded(javax.microedition.lcdui.Display)"><CODE>DisplayListener.displayAdded</CODE></A> </li>
        <li> <A HREF="../../../javax/microedition/lcdui/DisplayListener.html#displayStateChanged(javax.microedition.lcdui.Display, int)"><CODE>DisplayListener.displayStateChanged</CODE></A> </li>
        <li> <A HREF="../../../javax/microedition/lcdui/DisplayListener.html#hardwareStateChanged(javax.microedition.lcdui.Display, int)"><CODE>DisplayListener.hardwareStateChanged</CODE></A> </li>
        <li> <A HREF="../../../javax/microedition/lcdui/DisplayListener.html#orientationChanged(javax.microedition.lcdui.Display, int)"><CODE>DisplayListener.orientationChanged</CODE></A> </li>
        <li> <A HREF="../../../javax/microedition/lcdui/DisplayListener.html#sizeChanged(javax.microedition.lcdui.Display, int, int)"><CODE>DisplayListener.sizeChanged</CODE></A> </li>
        <li> <A HREF="../../../javax/microedition/lcdui/FormLayoutPolicy.html#doLayout(int, int, int, int, int[])"><CODE>FormLayoutPolicy.doLayout</CODE></A> </li>
        <li> <A HREF="../../../javax/microedition/lcdui/IdleItem.html#addedToDisplay(javax.microedition.lcdui.Display)"><CODE>IdleItem.addedToDisplay</CODE></A> </li>
        <li> <A HREF="../../../javax/microedition/lcdui/IdleItem.html#removedFromDisplay(javax.microedition.lcdui.Display)"><CODE>IdleItem.removedFromDisplay</CODE></A> </li>
        <li> <A HREF="../../../javax/microedition/lcdui/ItemCommandListener.html#commandAction(javax.microedition.lcdui.Command, javax.microedition.lcdui.Item)"><CODE>ItemCommandListener.commandAction</CODE></A> </li>
        <li> <A HREF="../../../javax/microedition/lcdui/ItemStateListener.html#itemStateChanged(javax.microedition.lcdui.Item)"><CODE>ItemStateListener.itemStateChanged</CODE></A> </li>
        <li> <A HREF="../../../javax/microedition/lcdui/ItemTraversalListener.html#itemTraversedIn(javax.microedition.lcdui.Item)"><CODE>ItemTraversalListener.itemTraversedIn</CODE></A> </li>
        <li> <A HREF="../../../javax/microedition/lcdui/ItemTraversalListener.html#itemTraversedOut(javax.microedition.lcdui.Item)"><CODE>ItemTraversalListener.itemTraversedOut</CODE></A> </li>
        <li> <code>Runnable.run</code> resulting from a call to <A HREF="../../../javax/microedition/lcdui/Display.html#callSerially(java.lang.Runnable)"><CODE>Display.callSerially</CODE></A> </li>
        <li> <A HREF="../../../javax/microedition/lcdui/TabListener.html#tabChangeEvent(javax.microedition.lcdui.Screen)"><CODE>TabListener.tabChangeEvent</CODE></A> </li>
    </ul>

    <p>
        Note that <code>java.util.Timer</code> events are not considered
        UI events. <code>Timer</code> callbacks may run concurrently with UI event
        callbacks, although <code>java.util.TimerTask</code> callbacks
        scheduled on the same <code>Timer</code> are serialized with each
        other. Applications that use timers must guard their data structures
        against concurrent access from timer threads and UI event callbacks.
        Alternatively, applications may have their timer callbacks use <A HREF="../../../javax/microedition/lcdui/Display.html#callSerially(java.lang.Runnable)"><CODE>Display.callSerially</CODE></A> so
        that work triggered by timer events can be serialized with the UI event
        callbacks.
    </p>


<h3 class="section"> Abstract Commands</h3>
<!-- <p>NOTE: This section needs to be updated based on the new Command APIs</p> -->

    <p>
        Since MIDP UI is highly abstract, it does not dictate any concrete
        user interaction technique like soft buttons or menus. Also, low-level
        user interactions such as traversal or scrolling are not visible to the
        application. MIDP applications define <code>Commands</code> , and the
        implementation may manifest these via either soft buttons, menus, or
        whatever mechanisms are appropriate for that device.
    </p>

    <p>
        <code>Commands</code> are installed to a <code>Displayable</code>
        (<code>Canvas</code> or <code> Screen</code>) with a method <code>addCommand</code>
        of class <code>Displayable</code>. There are two methods for deciding
        where <code>Commands</code> are placed: <em>native style</em> (default) and
        <em>exact placement</em> (introduced in MIDP 3.0).
    </p>

    <p>
        The native style of the device may assume that certain types of
        commands are placed on standard places. For example, the "go-back"
        operation may always be mapped to the right soft button. The <code>Command</code>
        class allows the application to communicate such a semantic meaning to
        the implementation so that these standard mappings can be effected.
    </p>

    <p>
        The exact placement method lets the  application developer
        specify exact placement of <code>Command</code>s and <code>Menu</code>s on a
        <code>Displayable</code>, when this is  appropriate (for example, placement of
        soft buttons on a screen, or associating a
        <code>Command</code> with an offscreen key).
        The normal placements of commands are available from a Display.
        The available placements for soft keys and the location of the labels
        can be retrieved from the Displayable. The choice of exact placement is made by
        the <code>Displayable</code> object adding the <code>Command</code> or <code>Menu</code>object by
        adding an optional <code>placement</code> attribute to the
        <code>addCommand() or addMenu()</code> method.
    </p>

    <p>
        The implementation does not actually implement any of the semantics
        of the <code>Command</code>. The attributes of a <code>Command</code>
        are used only for mapping it onto the user interface. The actual
        semantics of a <code>Command</code> are always implemented by the
        application in a <code>CommandListener</code>.
    </p>

    <p>
        In MIDP 3.0 <code>Command</code>s are <em>mutable</em>, and its
        attributes may change at any time. It is up to the implementation
        to act as soon as possible on the change.
    </p>

    <p><code>Command</code> objects have attributes:</p>
        <ul>
            <li>
                Label: Shown to the user as a hint. A single <code>Command</code>
                can have two versions of labels: short and long. The implementation
                decides whether the short or long version is appropriate for a given
                situation. For example, an implementation can choose to use a short
                version of a given <code>Command</code> near a soft button and the
                long version of the <code>Command</code> in a menu.
            </li>
            <li>
                Type: The purpose of a command. The implementation will use the
                command type for placing the command appropriately within the device's
                user interface. <code>Commands</code> with similar types may, for
                example, be found near each other in certain dedicated place in the
                user interface. Often, devices will have policy for placement and
                presentation of certain operations. For example, a "backward
                navigation" command might be always placed on the right soft key on a
                particular device, but it might be placed on the left soft key on a
                different device. The <code>Command</code> class provides fixed set of
                command types that provide <code>MIDlet</code> the capability to tell
                the device implementation the intent of a <code>Command</code>. The
                application can use the <code>BACK</code> command type for commands
                that perform backward navigation. On the devices mentioned above, this
                type information would be used to assign the command to the appropriate
                soft key.
            </li>
            <li>
                Priority: Defines the relative importance between <code>Commands</code>
                of the same type. A command with a lower priority value is more
                important than a command of the same type but with a higher priority
                value. If possible, a more important command is presented before, or is
                more easily accessible, than a less important one.
            </li>
            <li>
                Enabled: Used to enable/disable a <code>Command</code> that is disabled
                will typically remain visible, but greyed out, and cannot be chosen.
            </li>
        </ul>

<h3 class="section">Device-Provided Operations</h3>
    <p>
        In many high-level UI classes there are also some additional
        operations available in the user interface. The additional operations
        are not visible to applications, only to the end-user. The set of
        operations available depends totally on the user interface design of
        the specific device. For example, an operation that allows the user to
        change the mode for text input between alphabetic and numeric is needed
        in devices that have only an ITU-T keypad. More complex input systems
        will require additional operations. Some of operations available are
        presented in the user interface in the same way the application-defined
        commands are. End-users need not understand which operations are
        provided by the application and which provided by the system. Not all
        operations are available in every implementation. For example, a system
        that has a word-lookup-based text input scheme will generally provide
        additional operations within the <code>TextBox</code> class. A system
        that lacks such an input scheme will also lack the corresponding
        operations. Availability of various text input
        modes (for example, predictive input and numbers-only input) SHOULD be
        consistent across Java and native applications. This means, for
        example, that if predictive text input mode is available in native
        applications, it SHOULD also be available in Java applications.
    </p>
    <p>
        Some operations are available on all devices, but the way the
        operation is implemented may differ greatly from device to device.
        Examples of this kind of operation are: the mechanism used to navigate
        between <code>List</code> elements and <code>Form</code> items, the
        selection of <code>List</code> elements, moving an insertion position
        within a text editor, and so forth. Some devices do not allow the
        direct editing of the value of an <code>Item</code>, but instead
        require the user to switch to an off-screen editor. In such devices,
        there must be a dedicated selection operation that can be used to
        invoke the off-screen editor. The selection of a <code>List</code>
        elements could be, for example, implemented with a dedicated "Go" or
        "Select" or some other similar key. Some devices have no dedicated
        selection key and must select elements using some other means.
    </p>
    <p>
        On devices where the selection operation is performed using a
        dedicated select key, this key will often not have a label displayed
        for it. It is appropriate for the implementation to use this key in
        situations where its meaning is obvious. For example, if the user is
        presented with a set of mutually exclusive options, the selection key
        will obviously select one of those options. However, in a device that
        doesn't have a dedicated select key, it is likely that the selection
        operation will be performed using a soft key that requires a label. The
        ability to set the select-command for a <code>List</code> of type <code>IMPLICIT</code>
        and the ability to set the default command for an <code>Item</code>
        are provided so that the application can set the label for this
        operation and so it can receive notification when this operation occurs.
    </p>

<h3 class="section">Jog Dial Interaction</h3>
    <p>
        A device may have a 3-way or 5-way jog dial as a control mechanism.
        A 3-way jog dial is usually a wheel that rotates in two directions (to
        indicate scrolling) and can also be pressed (to indicate a selection).
        A 5-way jog dial is typically similar to a 3-way jog dial with the
        added possibility to tilt the wheel sideways. A jog dial wheel might
        have the ability to be rolled several steps in each direction.
        Alternatively, a jog dial wheel might only have the ability to be
        rotated by a limited angle, returning to the base position when
        released. When MIDP is implemented on a device with a jog dial, the
        requirements are as follows:
    </p>
        <ul>
            <li>
                An implementation MUST generate key press events in response to
                jog dial movements. An implementation MAY reuse key codes assigned to
                device keys with functions similar to jog dial functions (for example,
                key codes assigned to cursor keys can also be used for jog dial
                events). However, an implementation MAY choose to use unique key codes
                for jog dial events.  Key events generated by directional movements
                may use different key codes to reflect different spatial orientations.
            </li>
            <li>
                An implementation MUST map key press events generated by jog dial
                movements to game actions via the Canvas.getGameAction() method.
                The mapping of game actions MUST always be natural in relation
                to the spatial orientation of the device (that is, UP events are
                always generated when the jog dial is rolled upwards from the user
                point of view).  Consequently, an implementation MAY need to alter its
                mapping of key events to game actions depending on the spatial orientation
                of the device.  In the same vein, a clamshell device MAY generate different
                jog dial events when the clamshell is in OPEN or CLOSED mode.
            </li>
            <li>
                Since the mapping of key events and game actions may change in response to
                orientation changes, application should call Canvas.getGameAction() for each
                event to ensure that the current mapping is used.   Applications may also register a
                DisplayListener to be notified when the orientation changes and the key
                code mappings may be revised.
            </li>
            <li>
                A 3-way jog dial MUST generate key events with key codes mapping
                to game actions UP, DOWN and FIRE, or game actions LEFT, RIGHT and FIRE,
                depending on the relative orientation currently in effect.
            </li>
            <li>
                A 5-way jog dial MUST generate key events with key codes mapping
                to game actions UP, DOWN, LEFT, RIGHT and FIRE.
            </li>
            <li>
                A jog dial MAY also be used to control high level UI objects.
            </li>
        </ul>
    <p>
        Note: Depending on the mechanics of the jog wheel, the
        implementation is not necessarily able to generate key repeat events for some
        movements (for example, when the wheel is rotated).
    </p>

<h3 class="section"> High-Level API for Events</h3>
    <p>
        The handling of events in the high-level API is based on a listener
        model. <code>Screens</code> and <code>Canvases</code> may have
        listeners for commands. An object willing to be a listener should
        implement an interface <code>CommandListener</code> that has one
        method :
    </p>
    <p>
    <table border="2" bgcolor="silver">
        <tr>
            <td rowspan="1" colspan="1">
                <pre><code>
void commandAction(Command c, Displayable d);
                </code></pre>
            </td>
        </tr>
    </table>
    </p>
    <p>
        The application gets these events if the <code>Screen</code> or <code>Canvas</code>
        has attached <code>Commands</code> and if there is a registered
        listener. A unicast-version of the listener model is adopted, so the <code>Screen</code>
        or <code>Canvas</code> can have one listener at a time.
    </p>
    <p>
        There is also a listener interface for state changes of the <code>Items</code>
        in a <code>Form</code> . The method</p>
    <p>
        <table border="2" bgcolor="silver">
            <tr>
            <td rowspan="1" colspan="1">
                <pre><code>
void itemStateChanged(Item item);
                </code></pre>
            </td>
            </tr>
        </table>
    </p>
    <p>
        defined in interface <code>ItemStateListener</code> is called when
        the value of an interactive <code>Gauge</code> , <code>ChoiceGroup</code>,
        or <code>TextField</code> changes. It is not expected that the
        listener will be called after every change. However, if the value of an
        Item has been changed, the listener will be called for the change
        sometime before it is called for another item or before a command is
        delivered to the <code>Form's</code> <code>CommandListener</code>. It
        is suggested that the change listener is called at least after focus
        (or equivalent) is lost from field. The listener should only be called
        if the field's value has actually changed.
    </p>

    <p>
        A listener interface is also provided for events related to focus
        traversal between <code>Items</code> in a <code>Form</code>. The methods
    </p>
    <p>
        <table border="2" bgcolor="silver">
                <tr>
                    <td rowspan="1" colspan="1">
                        <pre><code>
void itemTraverseIn(Item item);
void itemTraverseOut(Item item);
                        </code></pre>
                    </td>
            </tr>
        </table>
    </p>
    <p>
        defined in interface <code>ItemTraversalListener</code> are called when an Item
        gains or loses focus, respectively.
    </p>

<h3 class="section"> Low-Level API for Events</h3>
    <p>
        Low-level graphics and events have the following methods to handle
        low-level key events :
    </p>
    <p>
        <table border="2" bgcolor="silver">
            <tr>
                <td rowspan="1" colspan="1">
                <pre><code>
public void keyPressed(int keyCode);
public void keyReleased(int keyCode);
public void keyRepeated(int keyCode);
                </code></pre>
                </td>
            </tr>
        </table>
    </p>
    <p>
        The API requires that there be standard key codes for the ITU-T
        keypad (0-9, *, #), but no keypad layout is required by the API.
        Although an implementation may provide additional keys, applications
        relying on these keys are not portable.
    </p>
    <p>
        In addition, the class <code>Canvas</code> has methods for
        handling abstract game events. An implementation maps all these key
        events to suitable keys on the device. For example, a device with
        four-way navigation and a select key in the middle could use those
        keys, but a simpler device may use certain keys on the numeric keypad
        (e.g., <code>2</code>, <code>4</code>, <code>5</code>, <code>6</code>,
        <code>8</code>). These game events allow development of portable
        applications that use the low-level events. The API defines a set of
        abstract key-events: <code>UP</code>, <code>DOWN</code>, <code>LEFT</code>,
        <code>RIGHT</code>, <code>FIRE</code>, <code>GAME_A</code>, <code>GAME_B</code>,
        <code>GAME_C</code>, and <code>GAME_D</code>.
    </p>
    <p>
        An application can get the mapping of the key events to abstract
        key events by calling :
    </p>
    <p>
        <table border="2" bgcolor="silver">
            <tr>
                <td rowspan="1" colspan="1">
                <pre><code>
public static int getGameAction(int keyCode);
                </code></pre>
                </td>
            </tr>
        </table>
    </p>
    <p>
        If the logic of the application is based on the values returned by
        this method, the application is portable and run regardless of the
        keypad design.
    </p>
    <p>
        It is also possible to map an abstract event to a key with :
    </p>
    <p>
        <table border="2" bgcolor="silver">
            <tr>
                <td rowspan="1" colspan="1">
                <pre><code>
public static int getKeyCode(int gameAction);
                </code></pre>
                </td>
            </tr>
        </table>
    </p>
    <p>
        where <code>gameAction</code> is <code>UP</code>,<code>DOWN</code>,
        <code>LEFT</code>, <code>RIGHT</code>, <code>FIRE</code>, etc. On
        some devices, more than one key is mapped to the same action, in
        which case the <code>getKeyCode</code> method will return just one of
        them. Properly-written applications should map the key code to an
        abstract key event and make decisions based on the result.
    </p>
    <p>
        The mapping between keys and abstract events does not change during
        the execution of the game.
    </p>
    <p>
        The following is an example of how an application can use game
        actions to interpret keystrokes.
    </p>
    <p>
        <table border="2" bgcolor="silver">
            <tr>
                <td rowspan="1" colspan="1">
                <pre><code>
class MovingBlocksCanvas extends Canvas {
        public void keyPressed(int keyCode) {
                int action = getGameAction(keyCode);
                switch (action) {
                        case LEFT:
                                moveBlockLeft();
                                break;
                        case RIGHT:
                                ...
                }
        }
}
                </code></pre>
                </td>
            </tr>
        </table>
    </p>
    <p>
        The low-level API also has support for pointer events, but since
        the following input mechanisms may not be present in all devices, the
        following callback methods may never be called in some devices :
    </p>
    <p>
        <table border="2" bgcolor="silver">
            <tr>
                <td rowspan="1" colspan="1">
                <pre><code>
public void pointerPressed(int x, int y);
public void pointerReleased(int x, int y);
public void pointerDragged(int x, int y);
                </code></pre>
                </td>
            </tr>
        </table>
    </p>
    <p>
        The application may check whether the pointer is available by
        calling the following methods of class <code>Canvas</code> :
    </p>
    <p>
        <table border="2" bgcolor="silver">
            <tr>
                <td rowspan="1" colspan="1">
                <pre><code>
public static boolean hasPointerEvents();
public static boolean hasPointerMotionEvents();
                </code></pre>
                </td>
            </tr>
        </table>
    </p>
    <p>
        Some devices may support multi-touch user interfaces (i.e. they can detect and track
        multiple simultaneous touch points instead of a single 'pointer' location).  Since
        applications cannot distinguish between the different touch points using the MIDP APIs,
        the delivery of multiple simultaneous touch events has the potential to cause unpredictable
        behavior.  Therefore, implementations MUST NOT deliver secondary touch events to MIDlets
        using the MIDP APIs; only the primary touch event and its corresponding drag and release
        events are to be delivered using the MIDP APIs.
    </p>

<h3 class="section"> Interplay of High-Level Commands and the Low-Level API</h3>
    <p>
        The class <code>Canvas</code> , which is used for low-level events
        and drawing, is a subclass of <code>Displayable</code> , and
        applications can attach <code>Commands</code> to it. This is useful
        for jumping to an options setup <code>Screen</code> in the middle of a
        game. Another example could be a map-based navigation application where
        keys are used for moving in the map but commands are used for
        higher-level actions.
    </p>
    <p>
        Some devices may not have the means to invoke commands when <code>Canvas</code>
        and the low-level event mechanism are in use. In that case, the
        implementation may provide a means to switch to a command mode and
        back. This command mode might pop up a menu over the contents of the <code>Canvas</code>.
        In this case, the <code>Canvas</code> methods <code>hideNotify()</code>
        and <code>showNotify()</code> will be called to indicate when the <code>Canvas</code>
        has been obscured and unobscured, respectively.
    </p>
    <p>
        The <code>Canvas</code> may have a title and a <code>Ticker</code>
        like the <code>Screen</code> objects. However, <code>Canvas</code>
        also has a full-screen mode where the title and the <code>Ticker</code>
        are not displayed. Setting this mode indicates that the application
        wishes for the <code>Canvas</code> to occupy as much of the physical
        display as is possible. In this mode, the title may be reused by the
        implementation as the title for pop-up menus. In normal (not
        full-screen) mode, the appearance of the <code>Canvas</code> should be
        similar to that of <code>Screen</code> classes, so that visual
        continuity is retained when the application switches between low-level <code>Canvas</code>
        objects and high-level <code>Screen</code> objects.
    </p>

<h2 class="section">Graphics and Text in Low-Level API</h2>
<h3 class="section"> The Redrawing Scheme</h3>
    <p>
        Repainting is done automatically for all <code>Screens</code> ,
        but not for <code>Canvas</code> ; therefore, developers utilizing the
        low-level API must ; understand its repainting scheme.
    </p>
    <p>
        In the low-level API, repainting of <code>Canvas</code> is done
        asynchronously so that several repaint requests may be implemented
        within a single call as an optimization. This means that the
        application requests the repainting by calling the method <code>repaint()</code>
        of class <code>Canvas</code>. The actual drawing is done in the
        method <code>paint() </code> -- which is provided by the subclass <code>Canvas
        </code> -- and does not necessarily happen synchronously to <code>repaint()</code>.
        It may happen later, and several repaint requests may cause one
        single call to <code>paint()</code> . The application can flush the
        repaint requests by calling <code>serviceRepaints()</code>.
    </p>
    <p>
        As an example, assume that an application moves a box of width <code>
        wid</code> and height <code>ht</code> from coordinates (<code>x1,y1</code>)
        to coordinates (<code>x2,y2</code>), where <code>x2&gt;x1</code>
        and <code>y2&gt;y1</code> :
    </p>
    <p>
        <table border="2" bgcolor="silver">
            <tr>
                <td rowspan="1" colspan="1">
                <pre><code>

    // move coordinates of box
    box.x = x2;
    box.y = y2;

    // ensure old region repainted (with background)
    canvas.repaint(x1,y1, wid, ht);

    // make new region repainted
    canvas.repaint(x2,y2, wid, ht);

    // make everything really repainted
    canvas.serviceRepaints();
                </code> </pre>
                <br>
                </td>
            </tr>
        </table>
    </p>
    <p>
        The last call causes the repaint thread to be scheduled. The
        repaint thread finds the two requests from the event queue and repaints
        the region that is a union of the repaint area :
    </p>
    <p>
        <table border="2" bgcolor="silver">
            <tr>
                <td rowspan="1" colspan="1">
                <pre><code>
graphics.clipRect(x1,y1, (x2-x1+wid), (y2-y1+ht));
canvas.paint(graphics);
                </code></pre>
                </td>
            </tr>
        </table>
    </p>
    <p>
        In this imaginary part of an implementation, the call
        <code> canvas.paint()</code> causes the application-defined
        <code>paint()</code> method to be called.
    </p>

<h3 class="section"> Drawing Model</h3>
    <p>
        All implementations MUST support double-buffered graphics.
        Graphics may be rendered either to the display's offscreen buffer or to an
        off-screen image buffer. The destination of rendered graphics depends
        on the origin of the <code>Graphics</code> object. A <code>Graphics</code> object for rendering
        to the display is passed to the <code>Canvas</code> or <code>CustomItem</code>
        object's <code>paint()</code> method. This is the only way to obtain a graphics object whose
        destination is the display. Furthermore, applications may draw by using
        this <code>Graphics</code> object only for the duration of the <code>paint()</code>
        method.
    </p>
    <p>
        A <code>Graphics</code> object for rendering to an off-screen <code>Image</code> buffer may
        be obtained by calling the <code>getGraphics()</code> method on the
        desired <code>Image</code>. These <code>Graphics</code> objects may be held indefinitely by the
        application, and rendering operations may be performed with them at
        any time.
    </p>
    <p>
        A 32-bit color model is provided with 8 bits each for the red,
        green, blue, and alpha components of a color. Not all devices support 32-bit
        resolution, so they will map colors and alpha values requested by the application into
        values available on the device. Facilities are provided in the <code>Display</code>
        class for obtaining device characteristics, such as whether color is
        available and how many distinct colors or gray levels are available. This enables
        applications to adapt their behavior to a device without compromising
        device independence.
    </p>

    <p>
        The <code>Graphics</code> class has a current color and alpha level. These two values
        can be set with the following methods :
    </p>
    <p>
    <table border="2" bgcolor="silver">
        <tr>
            <td rowspan="1" colspan="1">
            <pre><code>
    Graphics.setAlpha(int alpha)
    Graphics.setAlphaColor(int ARGB)
    Graphics.setAlphaColor(int alpha, int red, int green, int blue)
    Graphics.setColor(int RGB)
    Graphics.setColor(int red, int green, int blue)
    Graphics.setGrayscale(int graylevel)
            </code></pre>
            </td>
        </tr>
    </table>
    </p>

    <p>
        All geometric rendering, including lines, rectangles, text, and arcs, uses the current
        color and alpha. There is no background color; painting of any background must be performed
        explicitly by the application.
    </p>
    <p>
        Two Porter-Duff blending modes are supported by the <code>Graphics</code> class.
        <code>SRC_OVER</code> is the default blending mode and blends the source
        pixel's color value on top of the destination pixel. If the source pixel is fully opaque,
        the destination pixel is effectively replaced with the source pixel. If the
        source pixel is fully transparent, the destination pixel is unchanged. If
        the source pixel is partially transparent, its color is blended with the
        color of the destination pixel. The opacity of the destination pixel cannot
        be reduced using this blending mode, and thus it is available for Graphics objects.
    </p>
    <p>
        The <code>SRC</code> blending mode replaces the destination pixel with the
        source pixel's value, regardless of the source pixel's opacity. Both the color and
        the alpha value of the destination pixel are replaced with those of the source pixel,
        thus allowing the opacity of the destination pixel to be decreased as well as increased. For
        this reason, the <code>SRC</code> blending mode can only be used for Graphics objects
        that render to an Image with an alpha channel.
    </p>

<h3 class="section">Coordinate System</h3>
    <p>
        The origin <code>(0,0)</code> of the available drawing area and
        images is in the upper-left corner of the display. The numeric values
        of the x-coordinates monotonically increase from left to right, and the
        numeric values of the y-coordinates monotonically increase from top to
        bottom. Applications may assume that horizontal and vertical distances
        in the coordinate system represent equal distances on the actual device
        display. If the shape of the pixels of the device is significantly
        different from square, the implementation of the UI will do the
        required coordinate transformation. A facility is provided for
        translating the origin of the coordinate system. All coordinates are
        specified as integers.
    </p>
    <p>
        The coordinate system represents locations between pixels, not the
        pixels themselves. Therefore, the first pixel in the upper left corner
        of the display lies in the square bounded by coordinates <code>(0,0),
        (1,0), (0,1), (1,1)</code>.
    </p>
    <p>
        An application may inquire about the available drawing area by
        calling the following methods of <code>Canvas</code> :
    </p>
    <p>
    <table border="2" bgcolor="silver">
        <tr>
            <td rowspan="1" colspan="1">
            <pre><code>
public int getWidth();
public int getHeight();</code></pre>
            <br>
            </td>
        </tr>
    </table>
    </p>

<h3 class="section">Font Support</h3>
    <p>
        Each implementation MAY support a different set of system installed fonts.
        When an application requests a <code>Font</code> using a specific name, style
        and pixel size, the implementation will return a <code>Font</code> that most
        closely matches the request. An application may also use the
        <A HREF="../../../javax/microedition/lcdui/Font.html" title="class in javax.microedition.lcdui"><CODE>Font</CODE></A> class to query the list of
        available fonts.
    </p>
    <p>
        To improve portability across devices, applications may use the following
        abstract attributes to request an appropriate <code>Font</code> without knowledge
        of the specific names or pixel sizes that are available on the device :
    </p>
    <ul>
        <li> Size: <code>SMALL</code>, <code>MEDIUM</code>, <code>LARGE</code>.</li>
        <li> Face: <code>PROPORTIONAL</code>, <code>MONOSPACE</code>, <code>SYSTEM</code>.</li>
        <li> Style: <code>PLAIN</code>, <code>BOLD</code>, <code>ITALIC</code>, <code>UNDERLINED</code>.</li>
    </ul>
    <p>
        However, if an application needs to have complete control over text layout
        and appearance, it may use custom fonts that are loaded via an <code>InputStream</code>.
        Custom fonts may be packaged in the application's JAR and accessed as a named
        resource for this purpose. The application may also download a custom font, but
        it is responsible for persistently storing the font data on the device if required.
        Implementations MUST NOT automatically store downloaded font data between MIDlet
        invocations, and making downloaded fonts persistent (if needed) is solely
        an application's responsibility.
    </p>
    <p>
        All implementations MUST support OpenType fonts with TrueType outlines. Implementations
        SHOULD support TrueType hinting and MAY support advanced typographic functions.
        Support for other font formats is optional.
    </p>

 <a name="downloadablefonts"></a>
 <h4 class="section">Downloadable Fonts</h4>
     <p>
         MIDlets can use also custom fonts for the rendering of text content. Fonts
         may be packaged in a MIDlet suite's JAR or in the JARs of the LIBlets a MIDlet
         suite depends on. Fonts can also be downloaded at runtime and
         stored on the device in persistent storage for subsequent use (if required by the application).
         Implementations MUST NOT retain downloaded fonts between MIDlet invocations,
         but applications can store downloaded fonts in RMS Record Stores.
         It is the responsibility of a MIDlet to prepare and instantiate the fonts
         downloaded at runtime (and/or stored in RMS) by explicitly referencing
         a font resource using the
         <A HREF="../../../javax/microedition/lcdui/Font.html#createFont(java.io.InputStream)"><CODE>Font.createFont</CODE></A>
         method. Implementations MUST make all individual fonts available (whether downloaded or packaged)
         to a MIDlet at runtime if the individual font file size
         does not exceed 200KB. Any individual fonts with a file size that exceeds 200KB
         MAY be discarded by an implementation.
     </p>
     <p>
         Fonts that are packaged within a MIDlet Suite JAR or present in dependent
         LIBlet JARs SHOULD be declared using <code>MIDlet-Font</code>
         or <code>LIBlet-Font</code> attribute in their
         respective JAR manifests. Implementations MUST prepare all declared fonts for
         later instantiation; any such font can then be instantiated using static
         method calls (e.g.
         <A HREF="../../../javax/microedition/lcdui/Font.html#getFont(java.lang.String, int, int)"><CODE>Font.getFont</CODE></A>
         method). Fonts that are packaged but not declared in a JAR manifest will not be
         prepared by the implementation and can only be instantiated using the
         <A HREF="../../../javax/microedition/lcdui/Font.html#createFont(java.io.InputStream)"><CODE>Font.createFont</CODE></A> method.
         Applications are responsible for the management of all custom fonts not
         declared with this attribute.
     </p>
     <p>
         Implementations MUST ensure that the availability and use of fonts packaged
         with a MIDlet suite in a JAR, packaged with any dependency LIBlets,
         or downloaded at runtime and created using <code>createFont</code>
         method are limited to the MIDlet's
         <a href="javax/microedition/midlet/package.html#execution">
         runtime execution environment</a>.
         If a font packaged with a MIDlet or downloaded
         at runtime has the same font name as a system font available on a device, the
         downloaded or packaged font overrides the system font and MUST be used for text
         rendering purposes whenever a font is selected by name by a MIDlet that created it.
    </p>

<a name="concurrency"></a>
<h2 class="section">Threading Model</h2>
    <p>
        The UI API has been designed to be thread-safe. The methods may be
        called from callbacks, <code>TimerTasks</code>, or other threads
        created by the application. Also, the implementation generally does not
        hold any locks on objects visible to the application. This means that
        the applications' threads can synchronize with themselves and with the
        event callbacks by locking any object according to a synchronization
        policy defined by the application. One exception to this rule occurs
        with the <A HREF="../../../javax/microedition/lcdui/Canvas.html#serviceRepaints()"><CODE>Canvas.serviceRepaints</CODE></A> method. This method calls and awaits completion
        of the <code>paint</code> method. Strictly speaking, <code>serviceRepaints</code>
        might not call <code>paint</code> directly, but instead it might cause
        another thread to call <code>paint</code>. In either case, <code>serviceRepaints</code>
        blocks until <code>paint</code> has returned. This is a significant
        point because of the following case. Suppose the caller of <code>serviceRepaints</code>
        holds a lock that is also needed by the <code>paint</code> method.
        Since <code>paint</code> might be called from another thread, that
        thread will block trying to acquire the lock. However, this lock is
        held by the caller of <code>serviceRepaints</code>, which is blocked
        waiting for <code>paint</code> to return. The result is deadlock. In
        order to avoid deadlock, the caller of <code>serviceRepaints</code> <em>must
        not</em> hold any locks needed by the <code>paint</code> method.</p>
        <p> The UI API includes also a mechanism similar to other UI toolkits
        for serializing actions with the event stream. The method <A HREF="../../../javax/microedition/lcdui/Display.html#callSerially(java.lang.Runnable)"><CODE>Display.callSerially</CODE></A>
        requests that the <code>run</code> method of a <code>Runnable</code>
        object be called, serialized with the event stream. Code that uses <code>serviceRepaints()</code>
        can usually be rewritten to use <code>callSerially()</code>. The
        following code illustrates this technique:
    </p>
    <p>
    <table border="2" bgcolor="silver">
        <tr>
            <td rowspan="1" colspan="1">
            <pre><code>
class MyCanvas extends Canvas {
    void doStuff() {
        // &lt;code fragment 1&gt;
        serviceRepaints();
        // &lt;code fragment 2&gt;
        }
}
            </code> </pre>
            </td>
        </tr>
    </table>
    </p>
    <p> The following code is an alternative way of implementing the same
    functionality :</p>
    <p>
    <table border="2" bgcolor="silver">
    <tr>
        <td rowspan="1" colspan="1">
        <pre><code>
class MyClass extends Canvas implements Runnable {
        void doStuff() {
        // &lt;code fragment 1&gt;
        callSerially(this);
        }

        // called only after all pending repaints served
        public void run() {
        // &lt;code fragment 2&gt;;
        }
}
        </code></pre>
        </td>
    </tr>
    </table>
    </p>

<h2 class="section">Text Truncation in UI Components</h2>
    <p>
        Many MIDP LCDUI graphical components can contain text (that is, an
        alphanumeric string) that is shown to the user. Examples of such
        components are List,TextBox, Alert, StringItem, Form, and Item. An
        implementation often needs to truncate such visible text because it
        does not fit in the designated space of a given UI component. In this
        case, an implementation MUST use an appropriate visual indication (for
        example an ellipsis symbol) to signal the user that the text is
        truncated. The actual symbol or symbols used to represent the truncated
        text depends on the locale that is currently selected in the device.
        However, the visual indication SHOULD be consistent with the visual
        indication used in the device&#8217;s native UI.
    </p>


<h2 class="section">Activation of Idle Screen MIDlets</h2>
    <p>
        The application context of an
        <a href="javadoc/javax/microedition/midlet/package-summary.html#IdleScreenMIDlets">idle screen MIDlet</a>
        is the normal MIDlet.
        The <code>IdleItem</code> is an additional user interface for the MIDlet.
        The MIDlet can use the available Displays on the device in addition to the
        <code>IdleItem</code> on the idle screen of each Display that supports idle.
    </p>
    <p>
        When an idle screen MIDlet is installed to the device, the platform SHOULD
        add it to the list of idle screen applications. This makes it possible for
        the user to select an idle screen MIDlet to be added to the idle screen.
        The MIDlet name and icon information SHOULD be used to identify the
        MIDlet in the list of idle screen applications.
        The system MAY restrict the number of idle screen MIDlets added to the
        idle screen.
    </p>
    <p>
        When an idle screen MIDlet is added to the idle screen, the system MUST
        start the idle screen MIDlet if it is not already running.
        When the idle screen MIDlet is started it should call
        <A HREF="../../../javax/microedition/lcdui/Display.html#setIdleItem(javax.microedition.lcdui.IdleItem)"><CODE>Display.setIdleItem</CODE></A>
        to set the <code>IdleItem</code> for one or more Displays and be
        prepared to render content to it.
        The system MUST call the
        <A HREF="../../../javax/microedition/lcdui/IdleItem.html#addedToDisplay(javax.microedition.lcdui.Display)"><CODE>addedToDisplay</CODE></A>
        method, announcing that the MIDlet's IdleItem
        has been added to the idle screen.
        The following list illustrates the steps that SHOULD be taken
        by the idle screen MIDlet when it is started.
    </p>

        <ol>
            <li>Add <code>IdleItem</code> object to the idle screen with
                    <code>Display.setIdleItem</code> method</li>
            <li>If the MIDlet will use the normal Display then it should
                    set a <code>DisplayListener</code> to be notified when
                    the Displayable needs to be set</li>
            <li>Handle the callback method <code>IdleItem.addedToDisplay</code> and
                    render content to the idle screen when its paint method is called</li>
            <li>When the idle screen MIDlet has been removed from the idle screen handle
                    callback method <code>IdleItem.removedFromDisplay</code></li>
        </ol>

        <p>
            If an idle screen MIDlet has been added to the idle screen and it does not
            add any content to the idle screen, the system MAY remove the idle screen
            MIDlet from the idle screen. The MIDlet may be terminated.
        </p>

        <p>
            If a MIDlet that has not announced itself as an idle screen MIDlet with the
            JAD or JAR Manifest attribute tries to add content to the idle screen, the system
            MUST ignore this request.
        </p>


<h2 class="section">Implementation Notes</h2>
    <p>
        The implementation of a <code>List</code> or <code>ChoiceGroup</code>
        may include keyboard shortcuts for focusing and selecting the choice
        elements, but the use of these shortcuts is not visible to the
        application program.
    </p>
    <p>
        In some implementations the UI components -- <code>Screens</code>
        and <code>Items</code> -- will be based on native components. It is up
        to the implementation to free the used resources when the Java objects
        are not needed anymore. One possible implementation scenario is a hook
        in the garbage collector of KVM.
    </p>
<p>@since MIDP 1.0</p>
<P>

<P>
<DL>
</DL>
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A>
<A HREF="#skip-navbar_bottom" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Package</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <FONT CLASS="NavBarFont1">Class</FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-use.html"><FONT CLASS="NavBarFont1"><B>Use</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<strong>MIDP3.0</strong></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../javax/microedition/io/package-summary.html"><B>PREV PACKAGE</B></A>&nbsp;
&nbsp;<A HREF="../../../javax/microedition/lcdui/game/package-summary.html"><B>NEXT PACKAGE</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../index.html?javax/microedition/lcdui/package-summary.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="package-summary.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A>
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<HR>
<font size=-1><a href=mailto:jsr-271-comments@jcp.org>Send a comment or suggestion</a>Version 3.0 of Mobile Information Device Profile Specification<br>Java is a trademark or registered trademark of Sun Microsystems, Inc. in the US and other countries. Copyright 2002-2009 Motorola Inc. Portions copyright 1993-2002 Sun Microsystems, Inc. and Motorola, Inc. All Rights Reserved.</font>
</BODY>
</HTML>
