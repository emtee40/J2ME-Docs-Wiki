<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.5.0_20) on Mon Nov 02 17:27:39 PST 2009 -->
<TITLE>
Image (Mobile Information Device Profile 3.0)
</TITLE>

<META NAME="keywords" CONTENT="javax.microedition.lcdui.Image class">

<LINK REL ="stylesheet" TYPE="text/css" HREF="../../../stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    parent.document.title="Image (Mobile Information Device Profile 3.0)";
}
</SCRIPT>
<NOSCRIPT>
</NOSCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A>
<A HREF="#skip-navbar_top" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/Image.html"><FONT CLASS="NavBarFont1"><B>Use</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<strong>MIDP3.0</strong></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../javax/microedition/lcdui/IdleItem.html" title="class in javax.microedition.lcdui"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../../../javax/microedition/lcdui/ImageItem.html" title="class in javax.microedition.lcdui"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../index.html?javax/microedition/lcdui/Image.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="Image.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;FIELD&nbsp;|&nbsp;CONSTR&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;FIELD&nbsp;|&nbsp;CONSTR&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A>
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
javax.microedition.lcdui</FONT>
<BR>
Class Image</H2>
<PRE>
java.lang.Object
  <IMG SRC="../../../resources/inherit.gif" ALT="extended by "><B>javax.microedition.lcdui.Image</B>
</PRE>
<DL>
<DT><B>Direct Known Subclasses:</B> <DD><A HREF="../../../javax/microedition/lcdui/AnimatedImage.html" title="class in javax.microedition.lcdui">AnimatedImage</A>, <A HREF="../../../javax/microedition/lcdui/ScalableImage.html" title="class in javax.microedition.lcdui">ScalableImage</A></DD>
</DL>
<HR>
<DL>
<DT><PRE>public class <B>Image</B><DT>extends java.lang.Object</DL>
</PRE>

<P>
The <code>Image</code> class is used to hold graphical image data.
 <code>Image</code> objects exist independently of the display device. They
 exist only in off-screen memory and will not be painted on the display unless
 an explicit command is issued by the application (such as within the
 <code>paint()</code> method of a <code>Canvas</code>) or when an
 <code>Image</code> object is placed within a <code>Form</code> screen or
 an <code>Alert</code> screen and that screen is made current.

 <h3>Mutable vs. Immutable Images</h3>
 <p>
 Images are either <em>mutable</em> or <em>immutable</em> depending upon
 how they are created. Immutable images are generally created by loading image
 data from resource bundles, from files, or from the network. They may not be
 modified once created. Mutable images are created as blank images containing
 only white pixels. The application may render on a mutable image by calling
 <A HREF="../../../javax/microedition/lcdui/Image.html#getGraphics()"><CODE>getGraphics()</CODE></A> on the <code>Image</code> to obtain a
 <code>Graphics</code> object expressly for this purpose.
 </p>

 <p>
 <code>Images</code>, including <code>AnimatedImages</code> and <code>ScalableImages</code>,
 may be placed within <code>Alert</code>, <code>Choice</code>, <code>Form</code>,
 <code>ImageItem</code>, <code>Command</code>, <code>List</code>, <code>Menu</code>,
 <code>Notification</code>, or <code>TabbedPane</code> objects. The
 high-level user interface implementation may need to update the display at any time,
 without notifying the application. In order to provide predictable behavior, the
 high-level user interface objects provide snapshot semantics for the image. That is,
 when a mutable image is placed within an <code>Alert</code>, <code>Choice</code>,
 <code>Form</code>, <code>ImageItem</code> <code>Command</code>, <code>List</code>,
 <code>Menu</code>, <code>Notification</code>, or <code>TabbedPane</code> object,
 the effect is as if an immutable copy is taken of its current contents.
 This immutable copy is then used for all subsequent painting
 of the high-level user interface component. If the application modifies the
 contents of the image, the application must update the component containing
 the image (for example, by calling <code>ImageItem.setImage</code>) in
 order to make the modified contents visible.
 </p>

 <p>
 An immutable image may be created from a mutable image through the use of the
 <A HREF="../../../javax/microedition/lcdui/Image.html#createImage(javax.microedition.lcdui.Image)"><CODE>createImage</CODE></A> method. It is possible to create a
 mutable copy of an immutable image using a technique similar to the
 following:
 </p>

 <p>
 <pre>
  Image source; // the image to be copied
  source = Image.createImage(...);
  Image copy = Image.createImage(source.getWidth(), source.getHeight());
  Graphics g = copy.getGraphics();
  g.drawImage(source, 0, 0, TOP|LEFT);
 </pre>
 </p>

 <p>
 If the mutable image includes alpha channel information, the following code
 is used instead:
 </p>

 <p>
 <pre>
  Image sourceWithAlpha; // the image to be copied
  sourceWithAlpha = Image.createImage(...);
  fillColor = 0x5500FF00; //the color that the below mutable image is initially filled with
  Image copyWithAlpha = Image.createImage(source.getWidth(), source.getHeight(), true, fillColor);
  Graphics g = copyWithAlpha.getGraphics();
  g.setBlendingMode(Graphics.SRC);
  g.drawImage(sourceWithAlpha, 0, 0, TOP|LEFT);
 </pre>
 </p>

 <a name="alpha"/>
 <h3>Alpha Channels</h3>
 <p>
 An Image may include an alpha channel that specifies the opacity of each
 pixel. Pixels may be fully opaque, fully transparent, or semi-transparent.
 All implementations must store alpha information with at least 4 bits of
 accuracy (i.e. 16 distinct levels).
 </p>

 <p>
 An immutable Image will include an alpha channel if the resource used to
 create it contains an alpha channel or transparency information. A mutable
 Image will include an alpha channel if one was requested during
 instantiation.
 </p>

 <a name="PNG"/>
 <h3>PNG Image Format</h3>

 <p>
 Implementations are required to support images stored in the PNG format, as
 specified by the <em>PNG (Portable Network Graphics) Specification,
 Version 1.2.</em>
 All conforming MIDP implementations are also conformant to the minimum set of
 requirements given by the <em>PNG Specification</em>. MIDP implementations
 also must conform to additional requirements given here with respect to
 handling of PNG images. Note that the requirements listed here take
 precedence over any conflicting recommendations given in the
 <em>PNG Specification</em>.
 </p>

 <h4>Critical Chunks</h4>

 <p>
 All of the 'critical' chunks specified by PNG must be supported. The
 paragraphs below describe these critical chunks.
 </p>

 <p>
 The IHDR chunk. MIDP devices must handle the following values in the IHDR
 chunk:
 </p>

 <ul>
 <li>All positive values of width and height are supported; however, a very
 large image may not be readable because of memory constraints. The dimensions
 of the resulting <code>Image</code> object must match the dimensions of the
 PNG image. That is, the values returned by <A HREF="../../../javax/microedition/lcdui/Image.html#getWidth()"><CODE>getWidth()</CODE></A> and
 <A HREF="../../../javax/microedition/lcdui/Image.html#getHeight()"><CODE>getHeight()</CODE></A> and the rendered width and height must equal
 the width and height specified in the IHDR chunk.</li>

 <li>All color types are supported, although the appearance of the image will
 be dependent on the capabilities of the device's screen. Color types that
 include alpha channel data are supported, although the alpha values may be
 converted based on the number of alpha levels supported by the device.</li>

 <li> For color types <code>4</code> &amp; <code>6</code> (grayscale with
 alpha and RGB with alpha, respectively) the alpha channel must be decoded and
 stored in the resulting image.

 <li>All bit depth values for the given color type are supported.</li>

 <li>Compression method <code>0</code> (deflate) is the only supported
 compression method. This method utilizes the &quot;zlib&quot; compression
 scheme, which is also used for JARs; thus, the decompression (inflate)
 code may be shared between the jar decoding and PNG decoding implementations.
 As noted in the PNG specification, the compressed data stream may comprised
 internally of both compressed and uncompressed (raw) data. </li>

 <li>The filter method represents a series of encoding schemes that may be
 used to optimize compression. The PNG spec currently defines a single filter
 method (method <code>0</code>) that is an adaptive filtering scheme with
 five basic filter types. Filtering is essential for optimal compression since
 it allows the deflate algorithm to exploit spatial similarities within the
 image. Therefore, MIDP devices must support all five filter types defined by
 filter method <code>0</code>.</li>

 <li> MIDP devices are required to read PNG images that are encoded with
 either interlace method <code>0</code> (None) or interlace method
 <code>1</code> (Adam7). Image loading in MIDP is synchronous and cannot be
 overlapped with image rendering, and so there is no advantage for an
 application to use interlace method <code>1</code>. Support for decoding
 interlaced images is required for compatibility with PNG and for the
 convenience of developers who may already have interlaced images available.</li>

 </ul>

 <p>
 The PLTE chunk. Palette-based images must be supported.
 </p>

 <p>
 The IDAT chunk. Image data may be encoded using any of the <code>5</code>
 filter types defined by filter method <code>0</code> (None, Sub, Up,
 Average, Paeth).
 </p>

 <p>
 The IEND chunk. This chunk must be found in order for the image to be
 considered valid.
 </p>

 <h4>Ancillary Chunks</h4>

 <p>
 PNG defines several 'ancillary' chunks that may be present in a PNG image but
 are not critical for image decoding.
 </p>

 <p>
 The tRNS chunk. All implementations must support the tRNS chunk. This chunk
 is used to implement transparency without providing alpha channel data for
 each pixel. For color types <code>0</code> and <code>2</code>, a
 particular gray or RGB value is defined to be a transparent pixel. In this
 case, the implementation must treat pixels with this value as fully
 transparent (alpha = 0). Pixel value comparison must be based on the actual
 pixel values using the original sample depth; that is, this comparison must
 be performed before the pixel values are resampled to reflect the display
 capabilities of the device. For color type <code>3</code> (indexed color),
 <code>8</code>-bit alpha values are potentially provided for each entry in
 the color palette. In this case, any pixels with intermediate alpha values
 must be carried through to the resulting image.
 </p>

 <p>
 The implementation <em>may</em> (but is not required to) support any of the
 other ancillary chunks. The implementation <em>must</em> silently ignore
 any unsupported ancillary chunks that it encounters. The currently defined
 optional ancillary chunks are:
 </p>

 <PRE>

 cHRM gAMA hIST iCCP iTXt pHYs sBIT sPLT sRGB tEXt tIME zTXt

 </PRE>

 <a name="JPEG"/>
 <h3>JPEG Image Format</h3>
 <p>
 All conforming MIDP implementations MUST support
 <a href="#ISOIEC">ISO/IEC JPEG</a> together with <a href="#JFIF">JFIF</a>.
 The support for <a href="#ISOIEC">ISO/IEC JPEG</a> only applies to baseline DCT,
 non-differential, Huffman coding, as defined in table B.1, symbol 'SOF0' in
 [1].

 <a name="GIF"/>
 <h3>GIF Image Format</h3>

 <p>
 All conforming MIDP implementations MUST support the GIF89a image format
 including animated variants, in accordance to the <a href="#GIF89a">
 GIF89a Specification</a>.
 </p>

 <a name="SVG"/>
 <h3>SVG Image Format</h3>
 <p>All conforming MIDP implementations MUST support the SVG Tiny 1.1
 image format as defined in the <a href="#SVGTiny">Mobile SVG Profiles</a> specification.
 Support for animation is OPTIONAL, and interactive functionality MAY
 be disabled.</p>

 <p>Scalable images can be created using those static factory methods of
 the Image class which return immutable objects. Methods that return
 mutable images MUST rasterize the scalable image and return the
 result as a bitmap image, as described in the method documentation.</p>

 <p>Methods that return pixel-level information (getRGB, getRGB16, getARGB16)
 MUST first rasterize the scalable image to its current viewport size, and the
 returned image MUST be based on the result of the rasterization.</p>

 <h3>References</h3>
 <table class="Table" border="0" cellpadding="5">
   <tr>
       <td rowspan="1" colspan="1">
           <p class="TableText">[PNG]</p>
       </td>
       <td rowspan="1" colspan="1">
           <a name="PNG"/>
           <p class="TableText">
               T. Boutell, et. al., <em>Portable Network Graphics) Specification, Version 1.2.</em>, RFC2083.
               Available at : <a href="http://libpng.org/pub/png/spec/1.2">
               http://libpng.org/pub/png/spec/1.2</a> or
               <a href="http://www.faqs.org/rfcs/rfc2083.html">
               http://www.faqs.org/rfcs/rfc2083.html</a>
           </p>
       </td>
   </tr>
   <tr>
       <td rowspan="1" colspan="1">
           <p class="TableText">[ISOIECJPEG]</p>
       </td>
       <td rowspan="1" colspan="1">
           <a name="ISOIECJPEG"/>
           <p class="TableText">
              <em>ITU-T Recommendation T.81: "Information technology; Digital compression and coding of
              continuous-tone still images: Requirements and guidelines" 09/02.</em> Available at :
              <a href="http://www.w3.org/Graphics/JPEG/itu-t81">http://www.w3.org/Graphics/JPEG/itu-t81</a>
           </p>
       </td>
   </tr>
   <tr>
       <td rowspan="1" colspan="1">
           <p class="TableText">[JFIF]</p>
       </td>
       <td rowspan="1" colspan="1">
           <a name="JFIF"/>
           <p class="TableText">
              <em>"JPEG File Interchange Format", Version 1.02, September 1, 1992</em>. Available at :
              <a href="http://www.jpeg.org/public/jfif.pdf">http://www.jpeg.org/public/jfif.pdf</a>
           </p>
       </td>
   </tr>
   <tr>
       <td rowspan="1" colspan="1">
           <p class="TableText">[GIF89a]</p>
       </td>
       <td rowspan="1" colspan="1">
           <a name="GIF89a"/>
           <p class="TableText">
              CompuServe Inc, <em>Graphics Interchange Format Version 89a</em>. Available at :
              <a href="http://www.w3.org/Graphics/GIF/spec-gif89a.txt">http://www.w3.org/Graphics/GIF/spec-gif89a.txt</a>
           </p>
       </td>
   </tr>
   <tr>
       <td rowspan="1" colspan="1">
           <p class="TableText">[SVGTiny]</p>
       </td>
       <td rowspan="1" colspan="1">
           <a name="SVGTiny"/>
           <p class="TableText">
              W3C, <em>Mobile SVG Profiles: SVG Tiny and SVG Basic</em>. Available at :
              <a href="http://www.w3.org/TR/SVGMobile">http://www.w3.org/TR/SVGMobile</a>
           </p>
       </td>
   </tr>
 </table>
<P>

<P>
<DL>
<DT><B>Since:</B></DT>
  <DD>MIDP 1.0</DD>
</DL>
<HR>

<P>

<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Method Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../../javax/microedition/lcdui/Image.html" title="class in javax.microedition.lcdui">Image</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/microedition/lcdui/Image.html#createImage(byte[], int, int)">createImage</A></B>(byte[]&nbsp;imageData,
            int&nbsp;imageOffset,
            int&nbsp;imageLength)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Creates an immutable image which is decoded from the data stored in the
 specified byte array at the specified offset and length.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../../javax/microedition/lcdui/Image.html" title="class in javax.microedition.lcdui">Image</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/microedition/lcdui/Image.html#createImage(javax.microedition.lcdui.Image)">createImage</A></B>(<A HREF="../../../javax/microedition/lcdui/Image.html" title="class in javax.microedition.lcdui">Image</A>&nbsp;source)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Creates an immutable image from a source image.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../../javax/microedition/lcdui/Image.html" title="class in javax.microedition.lcdui">Image</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/microedition/lcdui/Image.html#createImage(javax.microedition.lcdui.Image, int, int, int, int, int)">createImage</A></B>(<A HREF="../../../javax/microedition/lcdui/Image.html" title="class in javax.microedition.lcdui">Image</A>&nbsp;image,
            int&nbsp;x,
            int&nbsp;y,
            int&nbsp;width,
            int&nbsp;height,
            int&nbsp;transform)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Creates an immutable image using pixel data from the specified region of
 a source image, transformed as specified.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../../javax/microedition/lcdui/Image.html" title="class in javax.microedition.lcdui">Image</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/microedition/lcdui/Image.html#createImage(javax.microedition.lcdui.Image, int, int, int, int, int, int, int)">createImage</A></B>(<A HREF="../../../javax/microedition/lcdui/Image.html" title="class in javax.microedition.lcdui">Image</A>&nbsp;image,
            int&nbsp;x,
            int&nbsp;y,
            int&nbsp;width,
            int&nbsp;height,
            int&nbsp;transform,
            int&nbsp;img_width,
            int&nbsp;img_height)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Creates an immutable image using pixel data from the specified region of
 a source image, transformed as specified and scaled to a specific
 size.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../../javax/microedition/lcdui/Image.html" title="class in javax.microedition.lcdui">Image</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/microedition/lcdui/Image.html#createImage(java.io.InputStream)">createImage</A></B>(java.io.InputStream&nbsp;stream)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 Creates an immutable image from decoded image data obtained from an
 <code>InputStream</code>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../../javax/microedition/lcdui/Image.html" title="class in javax.microedition.lcdui">Image</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/microedition/lcdui/Image.html#createImage(int, int)">createImage</A></B>(int&nbsp;width,
            int&nbsp;height)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 Creates a new, mutable image without an alpha channel for off-screen
 drawing.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../../javax/microedition/lcdui/Image.html" title="class in javax.microedition.lcdui">Image</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/microedition/lcdui/Image.html#createImage(int, int, boolean, int)">createImage</A></B>(int&nbsp;width,
            int&nbsp;height,
            boolean&nbsp;withAlpha,
            int&nbsp;fillColor)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 Creates a new mutable image with or without an alpha channel for
 off-screen drawing.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../../javax/microedition/lcdui/Image.html" title="class in javax.microedition.lcdui">Image</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/microedition/lcdui/Image.html#createImage(java.lang.String)">createImage</A></B>(java.lang.String&nbsp;name)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 Creates an immutable image from decoded image data obtained from the
 named resource.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../../javax/microedition/lcdui/Image.html" title="class in javax.microedition.lcdui">Image</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/microedition/lcdui/Image.html#createRGBImage(int[], int, int, boolean)">createRGBImage</A></B>(int[]&nbsp;rgb,
               int&nbsp;width,
               int&nbsp;height,
               boolean&nbsp;processAlpha)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Creates an immutable image from a sequence of ARGB values, specified
 using the <a href="Graphics.html#32ARGB">32-bit ARGB</a> format.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/microedition/lcdui/Image.html#getARGB16(short[], int, int, int, int, int, int)">getARGB16</A></B>(short[]&nbsp;argbData,
          int&nbsp;offset,
          int&nbsp;scanlength,
          int&nbsp;x,
          int&nbsp;y,
          int&nbsp;width,
          int&nbsp;height)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Obtains ARGB pixel data from the specified region of this image and
 stores it in the provided array of chars.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../javax/microedition/lcdui/Graphics.html" title="class in javax.microedition.lcdui">Graphics</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/microedition/lcdui/Image.html#getGraphics()">getGraphics</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Creates a new <code>Graphics</code> object that renders to this image.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/microedition/lcdui/Image.html#getHeight()">getHeight</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Gets the height of the image in pixels.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/microedition/lcdui/Image.html#getRGB(int[], int, int, int, int, int, int)">getRGB</A></B>(int[]&nbsp;rgbData,
       int&nbsp;offset,
       int&nbsp;scanlength,
       int&nbsp;x,
       int&nbsp;y,
       int&nbsp;width,
       int&nbsp;height)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Obtains ARGB pixel data from the specified region of this image and
 stores it in the provided array of integers.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/microedition/lcdui/Image.html#getRGB16(short[], int, int, int, int, int, int)">getRGB16</A></B>(short[]&nbsp;rgbData,
         int&nbsp;offset,
         int&nbsp;scanlength,
         int&nbsp;x,
         int&nbsp;y,
         int&nbsp;width,
         int&nbsp;height)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Obtains RGB pixel data from the specified region of this image and stores
 it in the provided array of shorts.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/microedition/lcdui/Image.html#getWidth()">getWidth</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Gets the width of the image in pixels.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/microedition/lcdui/Image.html#hasAlpha()">hasAlpha</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Checks if this image has alpha channel information.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/microedition/lcdui/Image.html#isAnimated()">isAnimated</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Checks if this Image is an AnimatedImage comprised of several frames.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/microedition/lcdui/Image.html#isMutable()">isMutable</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Check if this image is mutable.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/microedition/lcdui/Image.html#isScalable()">isScalable</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Checks if this Image is a ScalableImage that can be rasterized at a variety of
 different pixel sizes.</TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.lang.Object"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>Methods inherited from class java.lang.Object</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE>equals, getClass, hashCode, notify, notifyAll, toString, wait, wait, wait</CODE></TD>
</TR>
</TABLE>
&nbsp;
<P>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Method Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="createImage(int, int)"><!-- --></A><H3>
createImage</H3>
<PRE>
public static <A HREF="../../../javax/microedition/lcdui/Image.html" title="class in javax.microedition.lcdui">Image</A> <B>createImage</B>(int&nbsp;width,
                                int&nbsp;height)</PRE>
<DL>
<DD><p>
 Creates a new, mutable image without an alpha channel for off-screen
 drawing. Each pixel within the newly created image is initially white and
 fully opaque. The width and height of the image must both be greater than
 zero.
 </p>

 <p>
 This method is equivalent to calling
 <code>createImage(width, height, false, 0x00FFFFFF)</code>
 </p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>width</CODE> - the width of the new image, in pixels<DD><CODE>height</CODE> - the height of the new image, in pixels
<DT><B>Returns:</B><DD>the created image
<DT><B>Throws:</B>
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if either <code>width</code> or <code>height</code> is
             zero or less</DL>
</DD>
</DL>
<HR>

<A NAME="createImage(int, int, boolean, int)"><!-- --></A><H3>
createImage</H3>
<PRE>
public static <A HREF="../../../javax/microedition/lcdui/Image.html" title="class in javax.microedition.lcdui">Image</A> <B>createImage</B>(int&nbsp;width,
                                int&nbsp;height,
                                boolean&nbsp;withAlpha,
                                int&nbsp;fillColor)</PRE>
<DL>
<DD><p>
 Creates a new mutable image with or without an alpha channel for
 off-screen drawing. The width and height of the image must both be
 greater than zero.
 </p>

 <p>
 If <code>withAlpha</code> is true, the returned Image includes an alpha
 channel and the opacity of each pixel can be modified using a Graphics
 object with the <code>SRC</code> blending mode.
 </p>

 <p>
 The initial content of the pixels is determined by the
 <code>fillColor</code> parameter. If <code>withAlpha</code> is false,
 the <code>fillColor</code> value is interpreted as a 24-bit RGB color
 value (<code>0x00RRGGBB</code>); the value of the upper byte is
 ignored and the pixels are all fully opaque. If <code>withAlpha</code>
 is true, the <code>fillColor</code> value is interpreted as a 32-bit
 ARGB color value (<code>0xAARRGGBB</code>) and the pixels' alpha
 values are set according to the value of the upper byte.
 </p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>width</CODE> - the width of the new image, in pixels<DD><CODE>height</CODE> - the height of the new image, in pixels<DD><CODE>withAlpha</CODE> - true to create an image with an alpha channel, false to create
            a opaque image without an alpha channel<DD><CODE>fillColor</CODE> - the color (and alpha, if applicable) that the pixels are
            initially filled with
<DT><B>Returns:</B><DD>the new image
<DT><B>Throws:</B>
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if either <code>width</code> or <code>height</code> is
             zero or less<DT><B>Since:</B></DT>
  <DD>MIDP 3.0</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="createImage(javax.microedition.lcdui.Image)"><!-- --></A><H3>
createImage</H3>
<PRE>
public static <A HREF="../../../javax/microedition/lcdui/Image.html" title="class in javax.microedition.lcdui">Image</A> <B>createImage</B>(<A HREF="../../../javax/microedition/lcdui/Image.html" title="class in javax.microedition.lcdui">Image</A>&nbsp;source)</PRE>
<DL>
<DD>Creates an immutable image from a source image. If the source image is
 mutable, an immutable copy is created and returned. If the source image
 is immutable, the implementation may simply return it without creating a
 new image. If the source image contains alpha channel information, this
 information is copied to the new image unchanged.

 <p>
 This method is useful for placing the contents of mutable images into
 <code>Choice</code> objects. The application can create an off-screen
 image using the <A HREF="../../../javax/microedition/lcdui/Image.html#createImage(int, int)"><CODE>createImage(w, h)</CODE></A> method,
 draw into it using a <code>Graphics</code> object obtained with the
 <A HREF="../../../javax/microedition/lcdui/Image.html#getGraphics()"><CODE>getGraphics()</CODE></A> method, and then create an immutable
 copy of it with this method. The immutable copy may then be placed into
 <code>Choice</code> objects.
 </p>

 <p>
 This method can be used to create a pixel-based <code>Image</code> object using a
 <code>ScalableImage</code> as the source.  In this case, a new <code>Image</code> is
 returned that is a copy of the <code>ScalableImage</code> in its rasterized form.
 The dimensions of the new <code>Image</code> will equal the current pixel dimensions of the
 <code>ScalableImage</code> and cannot be changed.<p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>source</CODE> - the source image to be copied
<DT><B>Returns:</B><DD>the new, immutable image
<DT><B>Throws:</B>
<DD><CODE>java.lang.NullPointerException</CODE> - if <code>source</code> is <code>null</code></DL>
</DD>
</DL>
<HR>

<A NAME="createImage(java.lang.String)"><!-- --></A><H3>
createImage</H3>
<PRE>
public static <A HREF="../../../javax/microedition/lcdui/Image.html" title="class in javax.microedition.lcdui">Image</A> <B>createImage</B>(java.lang.String&nbsp;name)
                         throws java.io.IOException</PRE>
<DL>
<DD><p>
 Creates an immutable image from decoded image data obtained from the
 named resource. The name parameter is a resource name as defined by
 <CODE>Class.getResourceAsStream(name)</CODE>. The rules for resolving resource names
 are defined in the <a href="../../../../java/lang/package-summary.html#app_resource_files">
 Application Resource Files</a> section of the <code>java.lang</code>
 package documentation.<p>

 <p>This method returns a object of type Image for static, bitmapped image data.
 An AnimatedImage is returned if the image data contains an animated bitmap image.
 A <code>ScalableImage</code> is returned if the image data contains valid vector
 graphics content such as SVG Tiny 1.1.
 </p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>name</CODE> - the name of the resource containing the image data in one of
            the supported image formats
<DT><B>Returns:</B><DD>the created image
<DT><B>Throws:</B>
<DD><CODE>java.lang.NullPointerException</CODE> - if <code>name</code> is <code>null</code>
<DD><CODE>java.io.IOException</CODE> - if the resource does not exist, the data cannot be loaded, or
             the image data cannot be decoded</DL>
</DD>
</DL>
<HR>

<A NAME="createImage(byte[], int, int)"><!-- --></A><H3>
createImage</H3>
<PRE>
public static <A HREF="../../../javax/microedition/lcdui/Image.html" title="class in javax.microedition.lcdui">Image</A> <B>createImage</B>(byte[]&nbsp;imageData,
                                int&nbsp;imageOffset,
                                int&nbsp;imageLength)</PRE>
<DL>
<DD>Creates an immutable image which is decoded from the data stored in the
 specified byte array at the specified offset and length. The data must be
 in a self-identifying image file format supported by the implementation,
 such as the mandatory image formats.

 <p>
 The <code>imageoffset</code> and <code>imagelength</code> parameters
 specify a range of data within the <code>imageData</code> byte array.
 The <code>imageOffset</code> parameter specifies the offset into the
 array of the first data byte to be used. It must therefore lie within the
 range <code>[0..(imageData.length-1)]</code>. The
 <code>imageLength</code> parameter specifies the number of data bytes
 to be used. It must be a positive integer and it must not cause the range
 to extend beyond the end of the array. That is, it must be true that
 <code>imageOffset + imageLength &lt; imageData.length</code>.
 </p>

 <p>
 This method is intended for use when loading an image from a variety of
 sources, such as from persistent storage or from the network.
 </p>

 <p>This method returns a object of type Image for static, bitmapped image data.
 An AnimatedImage is returned if the image data contains an animated bitmap image.
 A ScalableImage is returned if the image data contains valid vector graphics content
 such as SVG Tiny 1.1.
 </p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>imageData</CODE> - the array of image data in a supported image format<DD><CODE>imageOffset</CODE> - the offset of the start of the data in the array<DD><CODE>imageLength</CODE> - the length of the data in the array
<DT><B>Returns:</B><DD>the created image
<DT><B>Throws:</B>
<DD><CODE>java.lang.ArrayIndexOutOfBoundsException</CODE> - if <code>imageOffset</code> and <code>imageLength</code>
             specify an invalid range
<DD><CODE>java.lang.NullPointerException</CODE> - if <code>imageData</code> is <code>null</code>
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if <code>imageData</code> is incorrectly formatted or
             otherwise cannot be decoded</DL>
</DD>
</DL>
<HR>

<A NAME="createImage(javax.microedition.lcdui.Image, int, int, int, int, int)"><!-- --></A><H3>
createImage</H3>
<PRE>
public static <A HREF="../../../javax/microedition/lcdui/Image.html" title="class in javax.microedition.lcdui">Image</A> <B>createImage</B>(<A HREF="../../../javax/microedition/lcdui/Image.html" title="class in javax.microedition.lcdui">Image</A>&nbsp;image,
                                int&nbsp;x,
                                int&nbsp;y,
                                int&nbsp;width,
                                int&nbsp;height,
                                int&nbsp;transform)</PRE>
<DL>
<DD>Creates an immutable image using pixel data from the specified region of
 a source image, transformed as specified.

 <p>
 The source image may be mutable or immutable. Alpha channel information,
 if any, is copied to the new image unchanged.
 </p>

 <p>
 On some devices, pre-transformed images may render more quickly than
 images that are transformed on the fly using <code>drawRegion</code>.
 However, creating such images does consume additional heap space, so this
 technique should be applied only to images whose rendering speed is
 critical.
 </p>

 <p>
 The transform function used must be one of the following, as defined in
 the <A HREF="../../../javax/microedition/lcdui/game/Sprite.html" title="class in javax.microedition.lcdui.game"><CODE>Sprite</CODE></A> class:<br>

 <code>Sprite.TRANS_NONE</code> - causes the specified image region to
 be copied unchanged<br>
 <code>Sprite.TRANS_ROT90</code> - causes the specified image region to
 be rotated clockwise by 90 degrees.<br>
 <code>Sprite.TRANS_ROT180</code> - causes the specified image region to
 be rotated clockwise by 180 degrees.<br>
 <code>Sprite.TRANS_ROT270</code> - causes the specified image region to
 be rotated clockwise by 270 degrees.<br>
 <code>Sprite.TRANS_MIRROR</code> - causes the specified image region to
 be reflected about its vertical center.<br>
 <code>Sprite.TRANS_MIRROR_ROT90</code> - causes the specified image
 region to be reflected about its vertical center and then rotated
 clockwise by 90 degrees.<br>
 <code>Sprite.TRANS_MIRROR_ROT180</code> - causes the specified image
 region to be reflected about its vertical center and then rotated
 clockwise by 180 degrees.<br>
 <code>Sprite.TRANS_MIRROR_ROT270</code> - causes the specified image
 region to be reflected about its vertical center and then rotated
 clockwise by 270 degrees.<br>
 </p>

 <p>
 The size of the returned image will be the size of the specified region
 with the transform applied. For example, if the region is
 <code>100&nbsp;x&nbsp;50</code> pixels and the transform is
 <code>TRANS_ROT90</code>, the returned image will be
 <code>50&nbsp;x&nbsp;100</code> pixels.
 </p>

 <p>If the source image is a ScalableImage, the returned <code>Image</code>
 will contain a rasterized version of the vector graphics content.  The specified
 region is interpreted in terms of the ScalableImage's current pixel dimensions.
 The specified transform is applied to the resulting bitmap data.</p>

 <p>
 <strong>Note:</strong> If all of the following conditions are met, this
 method may simply return the source <code>Image</code> without creating
 a new one:
 </p>
 <ul>
 <li>the source image is immutable;</li>
 <li>the source image is not a ScalableImage or AnimatedImage;</li>
 <li>the region represents the entire source image; and</li>
 <li>the transform is <code>TRANS_NONE</code>.</li>
 </ul>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>image</CODE> - the source image to be copied from<DD><CODE>x</CODE> - the horizontal location of the region to be copied<DD><CODE>y</CODE> - the vertical location of the region to be copied<DD><CODE>width</CODE> - the width of the region to be copied<DD><CODE>height</CODE> - the height of the region to be copied<DD><CODE>transform</CODE> - the transform to be applied to the region
<DT><B>Returns:</B><DD>the new, immutable image
<DT><B>Throws:</B>
<DD><CODE>java.lang.NullPointerException</CODE> - if <code>image</code> is <code>null</code>
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if the region to be copied exceeds the bounds of the source
             image
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if either <code>width</code> or <code>height</code> is
             zero or less
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if the <code>transform</code> is not valid<DT><B>Since:</B></DT>
  <DD>MIDP 2.0</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="createImage(javax.microedition.lcdui.Image, int, int, int, int, int, int, int)"><!-- --></A><H3>
createImage</H3>
<PRE>
public static <A HREF="../../../javax/microedition/lcdui/Image.html" title="class in javax.microedition.lcdui">Image</A> <B>createImage</B>(<A HREF="../../../javax/microedition/lcdui/Image.html" title="class in javax.microedition.lcdui">Image</A>&nbsp;image,
                                int&nbsp;x,
                                int&nbsp;y,
                                int&nbsp;width,
                                int&nbsp;height,
                                int&nbsp;transform,
                                int&nbsp;img_width,
                                int&nbsp;img_height)</PRE>
<DL>
<DD>Creates an immutable image using pixel data from the specified region of
 a source image, transformed as specified and scaled to a specific
 size.

 <p>
 The source image may be mutable or immutable. If it is mutable, the new
 Image will represent a snapshot of the source image's contents;
 subsequent changes to the source image are not reflected in the new
 image.Alpha channel information, if any, is copied to the new image
 unchanged.
 </p>

 <p>
 On some devices, pre-transformed images may render more quickly than
 images that are transformed on the fly using <code>drawRegion</code>.
 However, creating such images does consume additional heap space, so this
 technique should be applied only to images whose rendering speed is
 critical.
 </p>

 <p>
 The transform function used must be one of the following, as defined in
 the <A HREF="../../../javax/microedition/lcdui/game/Sprite.html" title="class in javax.microedition.lcdui.game"><CODE>Sprite</CODE></A> class:<br>

 <code>Sprite.TRANS_NONE</code> - causes the specified image region to
 be copied unchanged<br>
 <code>Sprite.TRANS_ROT90</code> - causes the specified image region to
 be rotated clockwise by 90 degrees.<br>
 <code>Sprite.TRANS_ROT180</code> - causes the specified image region to
 be rotated clockwise by 180 degrees.<br>
 <code>Sprite.TRANS_ROT270</code> - causes the specified image region to
 be rotated clockwise by 270 degrees.<br>
 <code>Sprite.TRANS_MIRROR</code> - causes the specified image region to
 be reflected about its vertical center.<br>
 <code>Sprite.TRANS_MIRROR_ROT90</code> - causes the specified image
 region to be reflected about its vertical center and then rotated
 clockwise by 90 degrees.<br>
 <code>Sprite.TRANS_MIRROR_ROT180</code> - causes the specified image
 region to be reflected about its vertical center and then rotated
 clockwise by 180 degrees.<br>
 <code>Sprite.TRANS_MIRROR_ROT270</code> - causes the specified image
 region to be reflected about its vertical center and then rotated
 clockwise by 270 degrees.<br>
 </p>

 <p>If the source image is a ScalableImage, the returned <code>Image</code>
 will contain a rasterized version of the vector graphics content. The specified
 region is interpreted in terms of the ScalableImage's current pixel dimensions,
 and the vector graphics content is rasterized directly into an image of the requested
 dimensions to avoid scaling artifacts. The specified transform is applied to the
 resulting bitmap data.
 <p>

 <strong>Note:</strong> If all of the following conditions are met, this
 method may simply return the source <code>Image</code> without creating
 a new one:
 </p>
 <ul>
 <li>the source image is immutable;</li>
 <li>the source image is not a ScalableImage or AnimatedImage;</li>
 <li>the region represents the entire source image;</li>
 <li>the requested image dimensions match that of the source image; and</li>
 <li>the transform is <code>TRANS_NONE</code>.</li>
 </ul>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>image</CODE> - the source image to be copied from<DD><CODE>x</CODE> - the horizontal location of the region to be copied<DD><CODE>y</CODE> - the vertical location of the region to be copied<DD><CODE>width</CODE> - the width of the region to be copied<DD><CODE>height</CODE> - the height of the region to be copied<DD><CODE>transform</CODE> - the transform to be applied to the region<DD><CODE>img_width</CODE> - the width of the new Image<DD><CODE>img_height</CODE> - the height of the new Image
<DT><B>Returns:</B><DD>the new, immutable image
<DT><B>Throws:</B>
<DD><CODE>java.lang.NullPointerException</CODE> - if <code>image</code> is <code>null</code>
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if the region to be copied exceeds the bounds of the source
             image
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if either <code>width</code> or <code>height</code> is
             zero or less
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if the <code>transform</code> is not valid
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if either <code>img_width</code> or <code>img_height</code>
             is less than 1<DT><B>Since:</B></DT>
  <DD>MIDP 3.0</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="createImage(java.io.InputStream)"><!-- --></A><H3>
createImage</H3>
<PRE>
public static <A HREF="../../../javax/microedition/lcdui/Image.html" title="class in javax.microedition.lcdui">Image</A> <B>createImage</B>(java.io.InputStream&nbsp;stream)
                         throws java.io.IOException</PRE>
<DL>
<DD><p>
 Creates an immutable image from decoded image data obtained from an
 <code>InputStream</code>. This method blocks until all image data has
 been read and decoded. After this method completes (whether by returning
 or by throwing an exception) the stream is left open and its current
 position is undefined.
 </p>

          <p>This method returns a object of type Image for static, bitmapped image data.
 An AnimatedImage is returned if the image data contains an animated bitmap image.
 A ScalableImage is returned if the image data contains valid vector graphics content
 such as SVG Tiny 1.1.
 </p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>stream</CODE> - the name of the resource containing the image data in one of
            the supported image formats
<DT><B>Returns:</B><DD>the created image
<DT><B>Throws:</B>
<DD><CODE>java.lang.NullPointerException</CODE> - if <code>stream</code> is <code>null</code>
<DD><CODE>java.io.IOException</CODE> - if an I/O error occurs, if the image data cannot be loaded,
             or if the image data cannot be decoded<DT><B>Since:</B></DT>
  <DD>MIDP 2.0</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="getGraphics()"><!-- --></A><H3>
getGraphics</H3>
<PRE>
public <A HREF="../../../javax/microedition/lcdui/Graphics.html" title="class in javax.microedition.lcdui">Graphics</A> <B>getGraphics</B>()</PRE>
<DL>
<DD>Creates a new <code>Graphics</code> object that renders to this image.
 This image must be mutable; it is illegal to call this method on an
 immutable image. The mutability of an image may be tested with the
 <code>isMutable()</code> method.

 <P>
 The newly created <code>Graphics</code> object has the following
 properties:
 </P>
 <UL>
 <LI>the destination is this <code>Image</code> object;</LI>
 <LI>the clip region encompasses the entire <code>Image</code>;</LI>
 <LI>the current color is black;</LI>
 <LI>the current alpha level is fully opaque;</LI>
 <LI>the current blending mode is <code>SRC_OVER</code>;</LI>
 <LI>the font is the same as the font returned by
 <A HREF="../../../javax/microedition/lcdui/Font.html#getDefaultFont()"><CODE>Font.getDefaultFont()</CODE></A>;</LI>
 <LI>the stroke style is <A HREF="../../../javax/microedition/lcdui/Graphics.html#SOLID"><CODE>SOLID</CODE></A>; and </LI>
 <LI>the origin of the coordinate system is located at the upper-left
 corner of the Image.</LI>
 </UL>

 <p>
 The blending mode may be changed to <code>SRC</code> only if the Image
 includes an alpha channel.
 </p>

 <P>
 The lifetime of <code>Graphics</code> objects created using this method
 is indefinite. They may be used at any time, by any thread.
 </P>
<P>
<DD><DL>

<DT><B>Returns:</B><DD>a <code>Graphics</code> object with this image as its
         destination
<DT><B>Throws:</B>
<DD><CODE>java.lang.IllegalStateException</CODE> - if the image is immutable</DL>
</DD>
</DL>
<HR>

<A NAME="getWidth()"><!-- --></A><H3>
getWidth</H3>
<PRE>
public int <B>getWidth</B>()</PRE>
<DL>
<DD>Gets the width of the image in pixels. The value returned must reflect
 the actual width of the image when rendered.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>width of the image</DL>
</DD>
</DL>
<HR>

<A NAME="getHeight()"><!-- --></A><H3>
getHeight</H3>
<PRE>
public int <B>getHeight</B>()</PRE>
<DL>
<DD>Gets the height of the image in pixels. The value returned must reflect
 the actual height of the image when rendered.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>height of the image</DL>
</DD>
</DL>
<HR>

<A NAME="isMutable()"><!-- --></A><H3>
isMutable</H3>
<PRE>
public boolean <B>isMutable</B>()</PRE>
<DL>
<DD>Check if this image is mutable. Mutable images can be modified by
 rendering to them through a <code>Graphics</code> object obtained from
 the <code>getGraphics()</code> method of this object.
<P>
<DD><DL>

<DT><B>Returns:</B><DD><code>true</code> if the image is mutable, <code>false</code>
         otherwise</DL>
</DD>
</DL>
<HR>

<A NAME="hasAlpha()"><!-- --></A><H3>
hasAlpha</H3>
<PRE>
public boolean <B>hasAlpha</B>()</PRE>
<DL>
<DD>Checks if this image has alpha channel information. All of the pixels are
 fully opaque in an Image without an alpha channel. If an alpha channel is
 present, pixels within the Image may be opaque, or partially or fully
 transparent.

 <p>
 An immutable Image will have an alpha channel if it was created with an
 image resource having an transparent pixels. That is, the image resource
 contain at least one non-opaque pixel present in the image data. A
 mutable Image will have an alpha channel if it was explicitly
 created to have one; an alpha channel is required in order to use the
 <code>SRC</code> blending mode when rendering to a mutable image.
 </p>
<P>
<DD><DL>

<DT><B>Returns:</B><DD><code>true</code> if the image has an alpha channel
         <code>false</code> otherwise<DT><B>Since:</B></DT>
  <DD>MIDP 3.0</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="isAnimated()"><!-- --></A><H3>
isAnimated</H3>
<PRE>
public boolean <B>isAnimated</B>()</PRE>
<DL>
<DD>Checks if this Image is an AnimatedImage comprised of several frames. If
 this method returns true, the Image is an instance of AnimatedImage and
 it may be cast to an AnimatedImage as needed.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>true if this Image is an instance of an AnimatedImage<DT><B>Since:</B></DT>
  <DD>MIDP 3.0</DD>
<DT><B>See Also:</B><DD><A HREF="../../../javax/microedition/lcdui/AnimatedImage.html" title="class in javax.microedition.lcdui"><CODE>AnimatedImage</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="isScalable()"><!-- --></A><H3>
isScalable</H3>
<PRE>
public boolean <B>isScalable</B>()</PRE>
<DL>
<DD>Checks if this Image is a ScalableImage that can be rasterized at a variety of
 different pixel sizes.  If this method returns true, the Image is an instance of
 ScalableImage and it may be cast to a ScalableImage as needed.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>true if this Image is an instance of a ScalableImage<DT><B>Since:</B></DT>
  <DD>MIDP 3.0</DD>
<DT><B>See Also:</B><DD><A HREF="../../../javax/microedition/lcdui/ScalableImage.html" title="class in javax.microedition.lcdui"><CODE>ScalableImage</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="createRGBImage(int[], int, int, boolean)"><!-- --></A><H3>
createRGBImage</H3>
<PRE>
public static <A HREF="../../../javax/microedition/lcdui/Image.html" title="class in javax.microedition.lcdui">Image</A> <B>createRGBImage</B>(int[]&nbsp;rgb,
                                   int&nbsp;width,
                                   int&nbsp;height,
                                   boolean&nbsp;processAlpha)</PRE>
<DL>
<DD>Creates an immutable image from a sequence of ARGB values, specified
 using the <a href="Graphics.html#32ARGB">32-bit ARGB</a> format. The
 ARGB data within the <code>rgb</code> array is arranged horizontally
 from left to right within each row, row by row from top to bottom.

 <p>
 If <code>processAlpha</code> is <code>true</code>, the high-order
 byte specifies opacity and the resulting image will have an alpha
 channel. That is, <code>0x00RRGGBB</code> specifies a fully transparent
 pixel, <code>0xFFRRGGBB</code> specifies a fully opaque pixel, and
 intermediate alpha values specify semi-transparency.
 </p>

 <p>
 If <code>processAlpha</code> is <code>false</code>, the high-order
 byte is ignored and the resulting image will not have an alpha channel.
 All pixels will be fully opaque.
 </p>

 <p>
 Consider <code>P(a,b)</code> to be the value of the pixel located at
 column <code>a</code> and row <code>b</code> of the Image, where rows
 and columns are numbered downward from the top starting at zero, and
 columns are numbered rightward from the left starting at zero. This
 operation can then be defined as:
 </p>

 <pre>
 P(a, b) = rgb[a + b * width];
 </pre>

 <p>
 for
 </p>

 <pre>
  0 &lt;= a &lt; width
  0 &lt;= b &lt; height
 </pre>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>rgb</CODE> - an array of ARGB values that composes the image<DD><CODE>width</CODE> - the width of the image<DD><CODE>height</CODE> - the height of the image<DD><CODE>processAlpha</CODE> - <code>true</code> if the image should include alpha channel
            information contained in <code>rgb</code>,
            <code>false</code> if the image and all of its pixels should
            be fully opaque
<DT><B>Returns:</B><DD>the created image
<DT><B>Throws:</B>
<DD><CODE>java.lang.NullPointerException</CODE> - if <code>rgb</code> is <code>null</code>.
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if either <code>width</code> or <code>height</code> is
             zero or less
<DD><CODE>java.lang.ArrayIndexOutOfBoundsException</CODE> - if the length of <code>rgb</code> is less than<code> width&nbsp;*&nbsp;height</code>.<DT><B>Since:</B></DT>
  <DD>MIDP 2.0</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="getRGB(int[], int, int, int, int, int, int)"><!-- --></A><H3>
getRGB</H3>
<PRE>
public void <B>getRGB</B>(int[]&nbsp;rgbData,
                   int&nbsp;offset,
                   int&nbsp;scanlength,
                   int&nbsp;x,
                   int&nbsp;y,
                   int&nbsp;width,
                   int&nbsp;height)</PRE>
<DL>
<DD>Obtains ARGB pixel data from the specified region of this image and
 stores it in the provided array of integers. Each pixel value is stored
 using the <a href="Graphics.html#32ARGB">32-bit ARGB</a> format.

 <p>
 The alpha channel specifies the opacity of the pixel, where a value of
 <code>0x00</code> represents a pixel that is fully transparent and a
 value of <code>0xFF</code> represents a fully opaque pixel. The alpha
 values are returned regardless of the image type, but they will all be
 0xFF if the image does not include an alpha channel.

 <p>
 The returned values are not guaranteed to be identical to values from the
 original source, such as from <code>createRGBImage</code> or from an
 image of the mandatory image format. Color values may be resampled to
 reflect the display capabilities of the device (for example, red,
 green or blue pixels may all be  represented by the same gray value on
 a grayscale device). Alpha channel values may be resampled to reflect
 the number of levels alpha supported by the device.
 </p>

 <p>
 The <code>scanlength</code> specifies the relative offset within the
 array between the corresponding pixels of consecutive rows. In order to
 prevent rows of stored pixels from overlapping, the absolute value of
 <code>scanlength</code> must be greater than or equal to
 <code>width</code>. Negative values of <code>scanlength</code> are
 allowed. In all cases, this must result in every reference being within
 the bounds of the <code>rgbData</code> array.
 </p>

 <p>
 Consider <code>P(a,b)</code> to be the value of the pixel located at
 column <code>a</code> and row <code>b</code> of the Image, where rows
 and columns are numbered downward from the top starting at zero, and
 columns are numbered rightward from the left starting at zero. This
 operation can then be defined as:
 </p>

 <pre>
 rgbData[offset + (a - x) + (b - y) * scanlength] = P(a, b);
 </pre>

 <p>
 for
 </p>

 <pre>
  x &lt;= a &lt; x + width
  y &lt;= b &lt; y + height
 </pre>

 <p>
 The source rectangle is required to not exceed the bounds of the image.
 This means:
 </p>

 <pre>
  x &gt;= 0
  y &gt;= 0
  x + width &lt;= image width
  y + height &lt;= image height
 </pre>

 <p>
 If any of these conditions is not met an
 <code>IllegalArgumentException</code> is thrown. Otherwise, in cases
 where <code>width &lt;= 0</code> or <code>height &lt;= 0</code>, no
 exception is thrown, and no pixel data is copied to <code>rgbData</code>.
 </p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>rgbData</CODE> - an array of integers in which the ARGB pixel data is stored<DD><CODE>offset</CODE> - the index into the array where the first ARGB value is stored<DD><CODE>scanlength</CODE> - the relative offset in the array between corresponding pixels
            in consecutive rows of the region<DD><CODE>x</CODE> - the x-coordinate of the upper left corner of the region<DD><CODE>y</CODE> - the y-coordinate of the upper left corner of the region<DD><CODE>width</CODE> - the width of the region<DD><CODE>height</CODE> - the height of the region
<DT><B>Throws:</B>
<DD><CODE>java.lang.ArrayIndexOutOfBoundsException</CODE> - if the requested operation would attempt to access an element
             in the <code>rgbData</code> array whose index is either
             negative or beyond its length (the contents of the array are
             unchanged)
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if the area being retrieved exceeds the bounds of the source
             image
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if the absolute value of <code>scanlength</code> is less
             than <code>width</code>
<DD><CODE>java.lang.NullPointerException</CODE> - if <code>rgbData</code> is <code>null</code><DT><B>Since:</B></DT>
  <DD>MIDP 2.0</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="getRGB16(short[], int, int, int, int, int, int)"><!-- --></A><H3>
getRGB16</H3>
<PRE>
public void <B>getRGB16</B>(short[]&nbsp;rgbData,
                     int&nbsp;offset,
                     int&nbsp;scanlength,
                     int&nbsp;x,
                     int&nbsp;y,
                     int&nbsp;width,
                     int&nbsp;height)</PRE>
<DL>
<DD>Obtains RGB pixel data from the specified region of this image and stores
 it in the provided array of shorts. Each pixel value is stored in a <a
 href="Graphics.html#16RGB">16-bit RGB</a> format. The alpha values of
 the pixels are not reflected in the data returned.

 <p>
 The returned values are not guaranteed to be identical to values from the
 original source, such as from <code>createRGBImage</code> or from an
 image of the mandatory image format. Color values may be resampled to
 reflect the display capabilities of the device and the limitations of
 the 16-bit format.
 </p>

 <p>
 The <code>scanlength</code> specifies the relative offset within the
 array between the corresponding pixels of consecutive rows. In order to
 prevent rows of stored pixels from overlapping, the absolute value of
 <code>scanlength</code> must be greater than or equal to
 <code>width</code>. Negative values of <code>scanlength</code> are
 allowed. In all cases, this must result in every reference being within
 the bounds of the <code>rgbData</code> array.
 </p>

 <p>
 Consider <code>P(a,b)</code> to be the value of the pixel located at
 column <code>a</code> and row <code>b</code> of the Image, where rows
 and columns are numbered downward from the top starting at zero, and
 columns are numbered rightward from the left starting at zero. This
 operation can then be defined as:
 </p>

 <pre>
 rgbData[offset + (a - x) + (b - y) * scanlength] = P(a, b);
 </pre>

 <p>
 for
 </p>

 <pre>
  x &lt;= a &lt; x + width
  y &lt;= b &lt; y + height
 </pre>

 <p>
 The source rectangle is required to not exceed the bounds of the image.
 This means:
 </p>

 <pre>
  x &gt;= 0
  y &gt;= 0
  x + width &lt;= image width
  y + height &lt;= image height
 </pre>

 <p>
 If any of these conditions is not met an
 <code>IllegalArgumentException</code> is thrown. Otherwise, in cases
 where <code>width &lt;= 0</code> or <code>height &lt;= 0</code>, no
 exception is thrown, and no pixel data is copied to <code>rgbData</code>.
 </p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>rgbData</CODE> - an array of shorts in which the RGB pixel data is stored<DD><CODE>offset</CODE> - the index into the array where the first RGB value is stored<DD><CODE>scanlength</CODE> - the relative offset in the array between corresponding pixels
            in consecutive rows of the region<DD><CODE>x</CODE> - the x-coordinate of the upper left corner of the region<DD><CODE>y</CODE> - the y-coordinate of the upper left corner of the region<DD><CODE>width</CODE> - the width of the region<DD><CODE>height</CODE> - the height of the region
<DT><B>Throws:</B>
<DD><CODE>java.lang.ArrayIndexOutOfBoundsException</CODE> - if the requested operation would attempt to access an element
             in the <code>rgbData</code> array whose index is either
             negative or beyond its length (the contents of the array are
             unchanged)
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if the area being retrieved exceeds the bounds of the source
             image
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if the absolute value of <code>scanlength</code> is less
             than <code>width</code>
<DD><CODE>java.lang.NullPointerException</CODE> - if <code>rgbData</code> is <code>null</code><DT><B>Since:</B></DT>
  <DD>MIDP 3.0</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="getARGB16(short[], int, int, int, int, int, int)"><!-- --></A><H3>
getARGB16</H3>
<PRE>
public void <B>getARGB16</B>(short[]&nbsp;argbData,
                      int&nbsp;offset,
                      int&nbsp;scanlength,
                      int&nbsp;x,
                      int&nbsp;y,
                      int&nbsp;width,
                      int&nbsp;height)</PRE>
<DL>
<DD>Obtains ARGB pixel data from the specified region of this image and
 stores it in the provided array of chars. Each pixel value is stored in a
 <a href="Graphics.html#16ARGB">16-bit ARGB</a> format that includes both
 the color and alpha values of the pixels.

 <p>
 The returned values are not guaranteed to be identical to values from the
 original source, such as from <code>createRGBImage</code> or from an
 image of the mandatory image format. Color values may be resampled to
 reflect the display capabilities of the device, number of alpha levels,
 and the limitations of the 16-bit format.
 </p>

 <p>
 The <code>scanlength</code> specifies the relative offset within the
 array between the corresponding pixels of consecutive rows. In order to
 prevent rows of stored pixels from overlapping, the absolute value of
 <code>scanlength</code> must be greater than or equal to
 <code>width</code>. Negative values of <code>scanlength</code> are
 allowed. In all cases, this must result in every reference being within
 the bounds of the <code>argbData</code> array.
 </p>

 <p>
 Consider <code>P(a,b)</code> to be the value of the pixel located at
 column <code>a</code> and row <code>b</code> of the Image, where rows
 and columns are numbered downward from the top starting at zero, and
 columns are numbered rightward from the left starting at zero. This
 operation can then be defined as:
 </p>

 <pre>
 argbData[offset + (a - x) + (b - y) * scanlength] = P(a, b);
 </pre>

 <p>
 for
 </p>

 <pre>
  x &lt;= a &lt; x + width
  y &lt;= b &lt; y + height
 </pre>

 <p>
 The source rectangle is required to not exceed the bounds of the image.
 This means:
 </p>

 <pre>
  x &gt;= 0
  y &gt;= 0
  x + width &lt;= image width
  y + height &lt;= image height
 </pre>

 <p>
 If any of these conditions is not met an
 <code>IllegalArgumentException</code> is thrown. Otherwise, in cases
 where <code>width &lt;= 0</code> or <code>height &lt;= 0</code>, no
 exception is thrown, and no pixel data is copied to <code>argbData</code>.
 </p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>argbData</CODE> - an array of shorts in which the ARGB pixel data is stored<DD><CODE>offset</CODE> - the index into the array where the first ARGB value is to be
            stored<DD><CODE>scanlength</CODE> - the relative offset in the array between corresponding pixels
            in consecutive rows of the region<DD><CODE>x</CODE> - the x-coordinate of the upper left corner of the region<DD><CODE>y</CODE> - the y-coordinate of the upper left corner of the region<DD><CODE>width</CODE> - the width of the region<DD><CODE>height</CODE> - the height of the region
<DT><B>Throws:</B>
<DD><CODE>java.lang.ArrayIndexOutOfBoundsException</CODE> - if the requested operation would attempt to access an element
             in the <code>argbData</code> array whose index is either
             negative or beyond its length (the contents of the array are
             unchanged)
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if the area being retrieved exceeds the bounds of the source
             image
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if the absolute value of <code>scanlength</code> is less
             than <code>width</code>
<DD><CODE>java.lang.NullPointerException</CODE> - if <code>argbData</code> is <code>null</code><DT><B>Since:</B></DT>
  <DD>MIDP 3.0</DD>
</DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A>
<A HREF="#skip-navbar_bottom" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/Image.html"><FONT CLASS="NavBarFont1"><B>Use</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<strong>MIDP3.0</strong></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../javax/microedition/lcdui/IdleItem.html" title="class in javax.microedition.lcdui"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../../../javax/microedition/lcdui/ImageItem.html" title="class in javax.microedition.lcdui"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../index.html?javax/microedition/lcdui/Image.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="Image.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;FIELD&nbsp;|&nbsp;CONSTR&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;FIELD&nbsp;|&nbsp;CONSTR&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A>
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<HR>
<font size=-1><a href=mailto:jsr-271-comments@jcp.org>Send a comment or suggestion</a>Version 3.0 of Mobile Information Device Profile Specification<br>Java is a trademark or registered trademark of Sun Microsystems, Inc. in the US and other countries. Copyright 2002-2009 Motorola Inc. Portions copyright 1993-2002 Sun Microsystems, Inc. and Motorola, Inc. All Rights Reserved.</font>
</BODY>
</HTML>
