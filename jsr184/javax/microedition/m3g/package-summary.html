<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.4.2_08) on Thu Jun 30 13:21:20 EEST 2005 -->
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<TITLE>
javax.microedition.m3g (Mobile 3D Graphics API (M3G))
</TITLE>

<META NAME="keywords" CONTENT="javax.microedition.m3g package">

<LINK REL ="stylesheet" TYPE="text/css" HREF="../../../stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    parent.document.title="javax.microedition.m3g (Mobile 3D Graphics API (M3G))";
}
</SCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A>
<A HREF="#skip-navbar_top" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=3 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Package</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <FONT CLASS="NavBarFont1">Class</FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-use.html"><FONT CLASS="NavBarFont1"><B>Use</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<EM><B>M3G 1.1 -- Jun 22, 2005</B></EM></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;PREV PACKAGE&nbsp;
&nbsp;NEXT PACKAGE</FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../index.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="package-summary.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>

</FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A>
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<H2>
Package javax.microedition.m3g
</H2>
Defines an API for rendering three-dimensional (3D) graphics at
interactive frame rates, including a scene graph structure and a
corresponding file format for efficient management and deployment of
3D content.
<P>
<B>See:</B>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="#package_description"><B>Description</B></A>
<P>

<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=2><FONT SIZE="+2">
<B>Class Summary</B></FONT></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../javax/microedition/m3g/AnimationController.html" title="class in javax.microedition.m3g">AnimationController</A></B></TD>
<TD>Controls the position, speed and weight of an animation sequence.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../javax/microedition/m3g/AnimationTrack.html" title="class in javax.microedition.m3g">AnimationTrack</A></B></TD>
<TD>Associates a KeyframeSequence with an AnimationController and an
animatable property.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../javax/microedition/m3g/Appearance.html" title="class in javax.microedition.m3g">Appearance</A></B></TD>
<TD>A set of component objects that define the rendering attributes of
a Mesh or Sprite3D.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../javax/microedition/m3g/Background.html" title="class in javax.microedition.m3g">Background</A></B></TD>
<TD>Defines whether and how to clear the viewport.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../javax/microedition/m3g/Camera.html" title="class in javax.microedition.m3g">Camera</A></B></TD>
<TD>A scene graph node that defines the position of the viewer in the scene
and the projection from 3D to 2D.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../javax/microedition/m3g/CompositingMode.html" title="class in javax.microedition.m3g">CompositingMode</A></B></TD>
<TD>An Appearance component encapsulating per-pixel compositing attributes.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../javax/microedition/m3g/Fog.html" title="class in javax.microedition.m3g">Fog</A></B></TD>
<TD>An Appearance component encapsulating attributes for fogging.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../javax/microedition/m3g/Graphics3D.html" title="class in javax.microedition.m3g">Graphics3D</A></B></TD>
<TD>A singleton 3D graphics context that can be bound to a rendering target.
</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../javax/microedition/m3g/Group.html" title="class in javax.microedition.m3g">Group</A></B></TD>
<TD>A scene graph node that stores an unordered set of nodes as its
children.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../javax/microedition/m3g/Image2D.html" title="class in javax.microedition.m3g">Image2D</A></B></TD>
<TD>A two-dimensional image that can be used as a texture, background or sprite
image.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../javax/microedition/m3g/IndexBuffer.html" title="class in javax.microedition.m3g">IndexBuffer</A></B></TD>
<TD><span class="new">An abstract class defining how to connect vertices to
form a geometric object.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../javax/microedition/m3g/KeyframeSequence.html" title="class in javax.microedition.m3g">KeyframeSequence</A></B></TD>
<TD>Encapsulates animation data as a sequence of time-stamped, vector-valued
keyframes. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../javax/microedition/m3g/Light.html" title="class in javax.microedition.m3g">Light</A></B></TD>
<TD>A scene graph node that represents different kinds of light sources.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../javax/microedition/m3g/Loader.html" title="class in javax.microedition.m3g">Loader</A></B></TD>
<TD>Downloads and deserializes scene graph nodes and node components, as well
as entire scene graphs. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../javax/microedition/m3g/Material.html" title="class in javax.microedition.m3g">Material</A></B></TD>
<TD>An Appearance component encapsulating material attributes for
lighting computations. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../javax/microedition/m3g/Mesh.html" title="class in javax.microedition.m3g">Mesh</A></B></TD>
<TD>A scene graph node that represents a 3D object defined as a
polygonal surface.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../javax/microedition/m3g/MorphingMesh.html" title="class in javax.microedition.m3g">MorphingMesh</A></B></TD>
<TD>A scene graph node that represents a vertex morphing polygon mesh.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../javax/microedition/m3g/Node.html" title="class in javax.microedition.m3g">Node</A></B></TD>
<TD>An abstract base class for all scene graph nodes.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../javax/microedition/m3g/Object3D.html" title="class in javax.microedition.m3g">Object3D</A></B></TD>
<TD>An abstract base class for all objects that can be part of a 3D
world. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../javax/microedition/m3g/PolygonMode.html" title="class in javax.microedition.m3g">PolygonMode</A></B></TD>
<TD>An Appearance component encapsulating polygon-level attributes. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../javax/microedition/m3g/RayIntersection.html" title="class in javax.microedition.m3g">RayIntersection</A></B></TD>
<TD>A RayIntersection object is filled in by the <code>pick</code> methods in
Group. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../javax/microedition/m3g/SkinnedMesh.html" title="class in javax.microedition.m3g">SkinnedMesh</A></B></TD>
<TD>A scene graph node that represents a skeletally animated polygon mesh.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../javax/microedition/m3g/Sprite3D.html" title="class in javax.microedition.m3g">Sprite3D</A></B></TD>
<TD>A scene graph node that represents a 2-dimensional image with a 3D
position.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../javax/microedition/m3g/Texture2D.html" title="class in javax.microedition.m3g">Texture2D</A></B></TD>
<TD>An Appearance component encapsulating a two-dimensional texture image and
a set of attributes specifying how the image is to be applied on submeshes.
</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../javax/microedition/m3g/Transform.html" title="class in javax.microedition.m3g">Transform</A></B></TD>
<TD>A generic 4x4 floating point matrix, representing a transformation.
</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../javax/microedition/m3g/Transformable.html" title="class in javax.microedition.m3g">Transformable</A></B></TD>
<TD>An abstract base class for Node and Texture2D, defining common
methods for manipulating node and texture transformations.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../javax/microedition/m3g/TriangleStripArray.html" title="class in javax.microedition.m3g">TriangleStripArray</A></B></TD>
<TD>TriangleStripArray defines an array of <i>triangle strips</i>. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../javax/microedition/m3g/VertexArray.html" title="class in javax.microedition.m3g">VertexArray</A></B></TD>
<TD>An array of integer vectors representing vertex positions, normals,
colors, or texture coordinates.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../javax/microedition/m3g/VertexBuffer.html" title="class in javax.microedition.m3g">VertexBuffer</A></B></TD>
<TD>VertexBuffer holds references to VertexArrays that contain the positions,
colors, normals, and texture coordinates for a set of vertices. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../javax/microedition/m3g/World.html" title="class in javax.microedition.m3g">World</A></B></TD>
<TD>A special Group node that is a top-level container for scene graphs.
</TD>
</TR>
</TABLE>
&nbsp;

<P>
<A NAME="package_description"><!-- --></A><H2>
Package javax.microedition.m3g Description
</H2>

<P>
<p>Defines an API for rendering three-dimensional (3D) graphics at
interactive frame rates, including a scene graph structure and a
corresponding file format for efficient management and deployment of
3D content.</p>

<p>The function of this API is to provide Java application programmers
with an efficient and flexible means to display animated 3D graphics
in real time on embedded devices. To cater for the needs of different
types of applications, both an easy-to-use scene graph structure and
an immediate mode interface are provided. All animation and rendering
features are available for scene graph objects and individually
rendered objects alike. The developer therefore does not need to
choose between the immediate mode and the scene graph, but rather can
mix and match both within the same application.</p>

<p>Besides the API itself, a corresponding <a
 href="../../../file-format.html">file format</a> for efficient
storage and transfer of all necessary data is also defined. This data
includes meshes, textures, scene hierarchies, material properties,
animation keyframes, and so on. Data is written into a file by content
creation tools on a PC, and loaded into the API through the Loader
class.</p>

<h3>Getting Started</h3>

<p>The <a href="#ExampleMidlets">example applications</a> at the end
of this page provide a good means to get a quick overview of this
API. Of the individual classes, <A HREF="../../../javax/microedition/m3g/Graphics3D.html" title="class in javax.microedition.m3g"><CODE>Graphics3D</CODE></A> is perhaps the most important,
because all rendering is done there. The <A HREF="../../../javax/microedition/m3g/World.html" title="class in javax.microedition.m3g"><CODE>World</CODE></A> class is crucial because it serves as
the root of the scene graph structure. <A HREF="../../../javax/microedition/m3g/Object3D.html" title="class in javax.microedition.m3g"><CODE>Object3D</CODE></A> is the base class of all objects that
can be rendered or loaded from a file, and also the place where
animations are applied. We also recommend you to read the rest of this
package description.</p>

<h3>Package Discovery</h3>

<p>Because of its optional nature, this API may not always be
available on every platform. Each profile and platform may have their
own methods for J2ME package discovery as there is no universal method
existing at this time. An additional method for package discovery of
the Mobile 3D Graphics API is by using a system properties query. To
discover this package, call <tt>System.getProperty</tt> with a key of
<tt>microedition.m3g.version</tt>.  If the API is present, the value
returned is the version of the API (<span class="new">this version is
"1.1", and the previous version was "1.0"</span>). If the API is not
present then the key is also not present and <tt>null</tt> will be
returned.</p>

<h3 class="orphan"><a name="Conventions"></a>Documentation Conventions</h3>

<p>The following general conventions are observed in the documentation
of this API.</p>

<ul>
  <li><p><b>Coordinate systems.</b> All 2D coordinate systems follow the
MIDP convention where the origin is in the upper left corner and
integer coordinates are at pixel boundaries. By default, 3D coordinate
systems are right-handed, and rotations obey the right-hand rule:
looking along the positive axis of rotation, positive angles are
clockwise. The camera coordinate system follows the OpenGL convention
where the view direction coincides with the negative z-axis, the
positive x-axis points right, and the positive y-axis points
up. However, the application is free to set up left-handed 3D
coordinate systems by use of transformation matrices.</p></li>

  <li><p><b>Matrix notation.</b> Matrices are denoted as upper case bold
letters, and vectors as lower case bold letters. For example, <b>M</b>
denotes a matrix and <b>v</b> a vector. Matrices have 4x4 and vectors
4 elements, unless stated otherwise. Vectors are always column
vectors, and are consequently on the right hand side when multiplied
with a matrix: <b>v'</b> = <b>M</b> <b>v</b>.</p></li>

  <li><p><b>Numeric intervals.</b> Closed intervals are denoted with
square brackets and open intervals with round brackets. For example,
[0, 10) denotes the values from zero to ten, including zero but not
including ten. Depending on the context, a numeric interval may
consist of real numbers or integers.</p></li>

  <li><p><b>OpenGL references.</b> All references to OpenGL in this
specification are to version 1.3. See Related Literature on the
overview page.</p></li>

  <li><p><b>Diagram notation.</b> The following common notation is used
in diagrams that involve scene graph nodes and node components.</p></li>

</ul>

<center><img src="./doc-files/Package-key.png"
width="376" height="221"/></center>

<h2><a name="Requirements"></a>General Implementation Requirements</h2>

<div class="new">

<h3><a name="Rasterization"></a>Rasterization</h3>

<p>By default, vertices, indices, triangles, and fragments are
processed as in OpenGL. In particular, triangle rasterization is done
as specified in section 3.5.1 of the OpenGL specification.</p>

<p>The reference geometry and fragment pipelines are shown below. A
rough mapping of Mesh components and other objects to the pipeline
stages is also shown. Note that the ordering of the stages is the same
as in OpenGL. Implementations may optimize their operation by doing
things in a different order, but only if the result is exactly the
same as it would be with the reference pipelines.</p>

<center><img src="./doc-files/Package-pipelines.png"
 title="Geometry and fragment processing pipelines"
 pdf="wide"></center>

<h3><a name="NumericRange"></a>Numeric Range and Accuracy</h3>

<p>The floating point format used for input and output is the standard
IEEE float, having an 8-bit exponent and a 24-bit mantissa normalized
to [1.0, 2.0). To facilitate efficient operation without floating
point hardware, implementations are allowed to substitute more
constrained representations internally. The internal format, and
conversion from the input format to the internal format, must satisfy
the following:</p>

<ul>

  <li>The <span style="font-style: italic;">numeric range</span> must
be at least R = [-2<font size="-1"><sup>63</sup></font>, 2<font
size="-1"><sup>63</sup></font>]. Values outside of R may produce
undefined results.</li>

  <li>The <span style="font-style: italic;">minimum absolute value</span>
must be at most d = 2<font size="-1"><sup>-63</sup></font>. Smaller
absolute values may be
flushed to zero.</li>

  <li>The <span style="font-style: italic;">precision</span> must be
at least p = 16 significant bits for all values x in R, abs(x) &gt;= d.</li>

</ul>

<p>These requirements also apply to elementary arithmetic operations,
which include addition, subtraction and multiplication. The operands
are then taken to be in the internal format rather than the input
format, and the value against which the precision is measured is taken
to be the mathematically correct result, rounded to the nearest
representable value. In addition, elementary arithmetic operations
must satisfy the following:</p>

<ul>
  <li>x &middot; 0 = 0 &middot; x = 0, for all values x in R.</li>
  <li>1 &middot; x = x &middot; 1 = x, for all values x in R.</li>
  <li>x + 0 = 0 + x = x, for all values x in R.</li>
  <li>0<sup>0</sup> = 1.</li>
</ul>

<p>These requirements apply to all operations in this API, except
rasterization and per-fragment operations, such as depth buffering,
blending, and interpolation of colors and texture coordinates. In
particular, the requirements do apply to node transformations in the
scene graph; vertex coordinate, texture coordinate and normal vector
transformations; picking; keyframe interpolation; mesh morphing;
skinning; and all methods in the Transform class.  <p>Blending,
interpolation, comparisons and other operations on color, alpha and
(screen-space) depth values must have a numeric range, minimum
absolute value, and precision at least equivalent to the corresponding
channel in the frame buffer. For example, an 8-bit color channel has R
= [0, 1], d = 1/255, and p = 8. Within that domain, the rules are as
specified above, with two additional requirements:</p>

<ul>
  <li>All operations must be done component-wise and clamped to [0, 1].</li>
  <li>a &middot; s + (1- a) &middot; s = s, for all values a and s in [0, 1].</li>
</ul>

<p>Loss of precision is allowed when converting the result of the
operation into the frame buffer format, which is commonly
fixed-point. The higher-precision internal value may be rounded to
either of the two closest representable values in the frame buffer
format. Note that the final precision will get progressively worse as
the intermediate result approaches zero. In the worst case, all
significant bits except the leading zero or one will be lost.</p>

</div>

<h3><a name="getters">Correspondence of Getters and Setters</a></h3>

<p>When querying the value of some property in the API, the returned
value does not need to be exactly the same that was set with the
corresponding <code>set</code> method. Instead, it may be any value
that <i>produces an equivalent result</i>. The returned values are
also not required to be in any "canonical" or "normalized" form. In
the case of node orientation, for example, there are a number of
different axis-angle combinations that specify the same orientation,
and any one of them may be returned.</p>

<p>The returned value may also be an approximation of the original
value, as long as the accuracy constraints for the particular type of
data are satisfied.</p>

<h3><a name="references">References to Objects</a></h3>

<p>Object3D instances are always held by reference rather than copied
in. Changes to an Object3D therefore have immediate effect in any
referring Object3D. For example, changes to an Image2D attached to a
Background take effect without having to call the
<code>Background.setImage</code> method again.</p>

<p class="new">Objects that are not instances of Object3D are copied
in by default. Any exceptions to this rule are clearly documented in
the individual method descriptions. Note that arrays are Objects in
Java, and are therefore copied in rather than held by reference. Also
note that the Transform class, although defined in this API, is not
derived from Object3D.</p>

<p class="new">To clarify the handling of arrays, consider a
hypothetical class X that takes in an Object3D array in its
constructor. The constructor copies in the array, but stores the <span
 style="font-style: italic;">elements </span>of the array by
reference. Thus, replacing one Object3D in the array with another will
have no effect on the instance of X that was just created. Indeed, the
application may freely reuse the array or leave it for garbage
collection. By contrast, any modifications to the actual Object3D
instances that were contained in the array will automatically be
reflected in the new instance of X.</p>

<h3>Deferred exceptions</h3>

<div class="new">

<p>The scene graph as well as individual objects are allowed to remain
in an incomplete or invalid state for as long as their contents are
not actually needed by the implementation (for rendering or some other
purpose). An IllegalStateException is thrown only when the objects
really must be valid. This kind of deferred error checking is
necessary for aggregate objects, whose validity depends on other
objects that the application can add, remove or change at any
time. There are four operations in this API that can throw these <span
style="font-style: italic;">deferred exceptions</span>: the
<tt>render</tt> methods in Graphics3D, the <tt>pick</tt> methods in
Group, the <tt>align</tt> method in Node, and the <tt>animate</tt>
method in Object3D.</p>

<p>The fact that deferred exceptions may or may not be thrown,
depending on whether the implementation actually needs the offending
data, can cause varying behavior between different
implementations. For example, some implementations may use visibility
culling to remove objects from further processing without having to
check their vertex arrays, while others may use a brute-force approach
and push all objects through the rendering pipeline. To reduce this
variability without restricting innovation, implementations must obey
the following rules when rendering or picking:</p>

<ol>

  <li>Objects that are out of <a href="Node.html#Scoping">scope</a> or
disabled <span style="font-weight: bold;">must not</span> be validated.</li>

  <li>Objects that are not rendered or picked, even though they are
enabled and within scope, <span style="font-weight: bold;">may</span>
be validated.</li>

  <li>Any data that are required in order for rendering or picking to
produce meaningful results <span style="font-weight: bold;">must</span>
be validated.</li>

</ol>

<p>A Node can be disabled by clearing its rendering and picking enable
flags. A submesh can be disabled by setting its Appearance to null. By
definition, all objects are disabled when rendering from a Camera that
has zero view volume.</p>

</div>

<h3>Thread Safety</h3>

<p>Implementations must not crash or throw an exception as a result of
being accessed from multiple threads at the same time. However, the
results of the requested operation in that case may be
unpredictable.</p>

<p>No method in this API is allowed to block waiting for a resource,
such as a rendering target, to be released. This is to guarantee that
no deadlock situations will occur. Also, any resources required by a
method must be released upon return. No method is allowed to leave its
host object or other resources locked.</p>

<h3><a name="PixelFormats"></a>Pixel Format Conversion</h3>

<div class="new">

<p>Several different pixel formats are supported in rendering targets,
textures, sprites, and background images. Depending on the case, a
mismatch between the source and destination pixel formats may require
a format conversion to be done. The general rules that are obeyed
throughout the API are as follows:</p>

<ul>

  <li>Luminance to RGB: The luminance value is replicated to each of
R, G and B.</li>

  <li>Luminance to Alpha: The luminance value is copied in as the
alpha value.</li>

  <li>RGBA to Alpha: The alpha value is copied in, and the RGB values
are discarded.</li>

  <li>RGB to Alpha: Unspecified, but must take all components into
account. For example, (R+G+B) / 3.</li>

  <li>RGB to Luminance: Unspecified, but must take all components into
account. For example, (R+G+B) / 3.</li>

  <li>Alpha to Luminance: The alpha value is copied in as the
luminance value.</li>

  <li>Any missing luminance, color or alpha components are set to 1.0,
unless explicitly stated otherwise.</li>

</ul>

<p>More specific rules related to pixel formats are specified on a
case-by-case basis in classes dealing with images and the frame
buffer. These include Graphics3D, Image2D, Texture2D, CompositingMode
and Background.</p>

</div>

<h2><a name="ExampleMidlets"></a>Example Applications</h2>

<p>Two example MIDlets using the API are presented below. The first
MIDlet is a pure immediate mode application that displays a rotating,
texture-mapped cube. It shows how to initialize a 3D graphics context,
bind it to a MIDP Canvas, and render some simple content with it. It
also illustrates how to create a Mesh object "manually", that is, how
to set up the coordinates, triangle connectivity, texture maps, and
materials. In practice, this is usually not done programmatically, but
with a 3D modeling tool. Loading a ready-made Mesh object with all the
necessary attributes is a simple matter of calling the <tt>load</tt>
method in Loader.</p>

<p>The other example MIDlet is a retained mode application that plays
back a ready-made animation that it downloads over http.</p>
<P>

<P>
<DL>
<DT><b>Examples:</b><DD><div class="example_title">(1) Immediate mode example MIDlet: Class MyCanvas.

</div><pre class="example"><span class="example_proclamation">import</span> javax.microedition.lcdui.*;
<span class="example_proclamation">import</span> javax.microedition.m3g.*;
 
<span class="example_modifier">public</span> <span class="example_proclamation">class</span> <span class="example_class">MyCanvas</span> <span class="example_proclamation">extends</span> <span class="example_class">Canvas</span> {
 
    <span class="example_modifier">private</span> <span class="example_class">Graphics</span>3D      iG3D;
    <span class="example_modifier">private</span> <span class="example_class">Camera</span>          iCamera;
    <span class="example_modifier">private</span> <span class="example_class">Light</span>           iLight;
    <span class="example_modifier">private</span> <span class="example_type">float</span>           iAngle = 0.0f;
    <span class="example_modifier">private</span> <span class="example_class">Transform</span>       iTransform = <span class="example_reserved">new</span> <span class="example_class">Transform</span>();
    <span class="example_modifier">private</span> <span class="example_class">Background</span>      iBackground = <span class="example_reserved">new</span> <span class="example_class">Background</span>();
    <span class="example_modifier">private</span> <span class="example_class">VertexBuffer</span>    iVb;    <span class="example_comment">// positions, normals, colors, texcoords</span>
    <span class="example_modifier">private</span> <span class="example_class">IndexBuffer</span>     iIb;    <span class="example_comment">// indices to iVB, forming triangle strips</span>
    <span class="example_modifier">private</span> <span class="example_class">Appearance</span>      iAppearance; <span class="example_comment">// material, texture, compositing, ...</span>
    <span class="example_modifier">private</span> <span class="example_class">Material</span>        iMaterial = <span class="example_reserved">new</span> <span class="example_class">Material</span>();
    <span class="example_modifier">private</span> <span class="example_class">Image</span>           iImage;
 
    <span class="example_comment">/**
     * Construct the Displayable.
     */</span>
    <span class="example_modifier">public</span> <span class="example_class">MyCanvas</span>() {
        <span class="example_comment">// set up this Displayable to listen to command events</span>
        setCommandListener(<span class="example_reserved">new</span> <span class="example_class">CommandListener</span>()  {
            <span class="example_modifier">public</span> <span class="example_type">void</span> commandAction(<span class="example_class">Command</span> c, <span class="example_class">Displayable</span> d) {
                <span class="example_control">if</span> (c.getCommandType() == <span class="example_class">Command</span>.<span class="example_constant">EXIT</span>) {
                    <span class="example_comment">// exit the MIDlet</span>
                    <span class="example_class">MIDletMain</span>.quitApp();
                }
            }
        });
        <span class="example_control">try</span> {
            init();
        }
        <span class="example_control">catch</span>(<span class="example_class">Exception</span> e) {
             e.printStackTrace();
        }
    }
 
    <span class="example_comment">/**
     * Component initialization.
     */</span>
    <span class="example_modifier">private</span> <span class="example_type">void</span> init() <span class="example_proclamation">throws</span> <span class="example_class">Exception</span>  {
        <span class="example_comment">// add the Exit command</span>
        addCommand(<span class="example_reserved">new</span> <span class="example_class">Command</span>(<span class="example_string">"Exit"</span>, <span class="example_class">Command</span>.<span class="example_constant">EXIT</span>, 1));
 
        <span class="example_comment">// get the singleton Graphics3D instance</span>
        iG3D = <span class="example_class">Graphics</span>3D.getInstance();
        
        <span class="example_comment">// create a camera</span>
        iCamera = <span class="example_reserved">new</span> <span class="example_class">Camera</span>();
        iCamera.setPerspective( 60.0f,              <span class="example_comment">// field of view</span>
            (<span class="example_type">float</span>)getWidth()/ (<span class="example_type">float</span>)getHeight(),  <span class="example_comment">// aspectRatio</span>
            1.0f,      <span class="example_comment">// near clipping plane</span>
            1000.0f ); <span class="example_comment">// far clipping plane</span>
 
        <span class="example_comment">// create a light</span>
        iLight = <span class="example_reserved">new</span> <span class="example_class">Light</span>();
        iLight.setColor(0xffffff);         <span class="example_comment">// white light</span>
        iLight.setIntensity(1.25f);          <span class="example_comment">// overbright</span>
 
        <span class="example_comment">// init some arrays for our object (cube)</span>
 
        <span class="example_comment">// Each line in this array declaration represents a triangle strip for</span>
        <span class="example_comment">// one side of a cube. The only primitive we can draw with is the</span>
        <span class="example_comment">// triangle strip so if we want to make a cube with hard edges we</span>
        <span class="example_comment">// need to construct one triangle strip per face of the cube.</span>
        <span class="example_comment">// 1 * * * * * 0</span>
        <span class="example_comment">//   * *     *</span>
        <span class="example_comment">//   *   *   *</span>
        <span class="example_comment">//   *     * *</span>
        <span class="example_comment">// 3 * * * * * 2</span>
        <span class="example_comment">// The ascii diagram above represents the vertices in the first line</span>
        <span class="example_comment">// (the first tri-strip)</span>
        <span class="example_type">short</span>[] vert = {
            10, 10, 10,  -10, 10, 10,   10,-10, 10,  -10,-10, 10,   <span class="example_comment">// front</span>
           -10, 10,-10,   10, 10,-10,  -10,-10,-10,   10,-10,-10,   <span class="example_comment">// back</span>
           -10, 10, 10,  -10, 10,-10,  -10,-10, 10,  -10,-10,-10,   <span class="example_comment">// left</span>
            10, 10,-10,   10, 10, 10,   10,-10,-10,   10,-10, 10,   <span class="example_comment">// right</span>
            10, 10,-10,  -10, 10,-10,   10, 10, 10,  -10, 10, 10,   <span class="example_comment">// top</span>
            10,-10, 10,  -10,-10, 10,   10,-10,-10,  -10,-10,-10 }; <span class="example_comment">// bottom</span>
 
        <span class="example_comment">// create a VertexArray to hold the vertices for the object</span>
        <span class="example_class">VertexArray</span> vertArray = <span class="example_reserved">new</span> <span class="example_class">VertexArray</span>(vert.length / 3, 3, 2);
        vertArray.set(0, vert.length/3, vert);
 
        <span class="example_comment">// The per-vertex normals for the cube; these match with the vertices</span>
        <span class="example_comment">// above. Each normal is perpendicular to the surface of the object at</span>
        <span class="example_comment">// the corresponding vertex.</span>
        <span class="example_type">byte</span>[] norm = {  
            0, 0, 127,    0, 0, 127,    0, 0, 127,    0, 0, 127,
            0, 0,-127,    0, 0,-127,    0, 0,-127,    0, 0,-127,
           -127, 0, 0,   -127, 0, 0,   -127, 0, 0,   -127, 0, 0,
            127, 0, 0,    127, 0, 0,    127, 0, 0,    127, 0, 0,
            0, 127, 0,    0, 127, 0,    0, 127, 0,    0, 127, 0,
            0,-127, 0,    0,-127, 0,    0,-127, 0,    0,-127, 0 };
 
        <span class="example_comment">// create a vertex array for the normals of the object</span>
        <span class="example_class">VertexArray</span> normArray = <span class="example_reserved">new</span> <span class="example_class">VertexArray</span>(norm.length / 3, 3, 1);
        normArray.set(0, norm.length/3, norm);
 
        <span class="example_comment">// per vertex texture coordinates</span>
        <span class="example_type">short</span>[] tex = {  
            1, 0,       0, 0,       1, 1,       0, 1,
            1, 0,       0, 0,       1, 1,       0, 1,
            1, 0,       0, 0,       1, 1,       0, 1,
            1, 0,       0, 0,       1, 1,       0, 1,
            1, 0,       0, 0,       1, 1,       0, 1,
            1, 0,       0, 0,       1, 1,       0, 1 };
 
        <span class="example_comment">// create a vertex array for the texture coordinates of the object</span>
        <span class="example_class">VertexArray</span> texArray = <span class="example_reserved">new</span> <span class="example_class">VertexArray</span>(tex.length / 2, 2, 2);
        texArray.set(0, tex.length/2, tex);
 
        <span class="example_comment">// the length of each triangle strip        </span>
        <span class="example_type">int</span>[] stripLen = { 4, 4, 4, 4, 4, 4 };
        
        <span class="example_comment">// create the VertexBuffer for our object</span>
        <span class="example_class">VertexBuffer</span> vb = iVb = <span class="example_reserved">new</span> <span class="example_class">VertexBuffer</span>();
        vb.setPositions(vertArray, 1.0f, <span class="example_literal">null</span>);      <span class="example_comment">// unit scale, zero bias</span>
        vb.setNormals(normArray);
        vb.setTexCoords(0, texArray, 1.0f, <span class="example_literal">null</span>);    <span class="example_comment">// unit scale, zero bias</span>
 
        <span class="example_comment">// create the index buffer for our object (this tells how to</span>
        <span class="example_comment">// create triangle strips from the contents of the vertex buffer).</span>
        iIb = <span class="example_reserved">new</span> <span class="example_class">TriangleStripArray</span>( 0, stripLen );
 
        <span class="example_comment">// load the image for the texture</span>
        iImage = <span class="example_class">Image</span>.createImage( <span class="example_string">"/texture.png"</span> );
 
        <span class="example_comment">// create the Image2D (we need this so we can make a Texture2D)</span>
        <span class="example_class">Image</span>2D image2D = <span class="example_reserved">new</span> <span class="example_class">Image</span>2D( <span class="example_class">Image</span>2D.<span class="example_constant">RGB</span>, iImage );
 
        <span class="example_comment">// create the Texture2D and enable mipmapping</span>
        <span class="example_comment">// texture color is to be modulated with the lit material color</span>
        <span class="example_class">Texture</span>2D texture = <span class="example_reserved">new</span> <span class="example_class">Texture</span>2D( image2D );
        texture.setFiltering(<span class="example_class">Texture</span>2D.<span class="example_constant">FILTER_NEAREST</span>,
                             <span class="example_class">Texture</span>2D.<span class="example_constant">FILTER_NEAREST</span>);
        texture.setWrapping(<span class="example_class">Texture</span>2D.<span class="example_constant">WRAP_CLAMP</span>,
                            <span class="example_class">Texture</span>2D.<span class="example_constant">WRAP_CLAMP</span>);
        texture.setBlending(<span class="example_class">Texture</span>2D.<span class="example_constant">FUNC_MODULATE</span>);
 
        <span class="example_comment">// create the appearance</span>
        iAppearance = <span class="example_reserved">new</span> <span class="example_class">Appearance</span>();
        iAppearance.setTexture(0, texture);
        iAppearance.setMaterial(iMaterial);
        iMaterial.setColor(<span class="example_class">Material</span>.<span class="example_constant">DIFFUSE</span>, 0xFFFFFFFF);   <span class="example_comment">// white</span>
        iMaterial.setColor(<span class="example_class">Material</span>.<span class="example_constant">SPECULAR</span>, 0xFFFFFFFF);  <span class="example_comment">// white</span>
        iMaterial.setShininess(100.0f);
 
        iBackground.setColor(0xf54588); <span class="example_comment">// set the background color</span>
    }
                   
    <span class="example_comment">/**
     * Paint the scene.
     */</span>
    <span class="example_modifier">protected</span> <span class="example_type">void</span> paint(<span class="example_class">Graphics</span> g) {
        
        <span class="example_comment">// Bind the Graphics of this Canvas to our Graphics3D. The</span>
        <span class="example_comment">// viewport is automatically set to cover the entire clipping</span>
        <span class="example_comment">// rectangle of the Graphics object. The parameters indicate</span>
        <span class="example_comment">// that z-buffering, dithering and true color rendering are</span>
        <span class="example_comment">// enabled, but antialiasing is disabled.</span>
        
        iG3D.bindTarget(g, <span class="example_literal">true</span>,
                        <span class="example_class">Graphics</span>3D.<span class="example_constant">DITHER</span> |
                        <span class="example_class">Graphics</span>3D.<span class="example_constant">TRUE_COLOR</span>);
        
        <span class="example_comment">// clear the color and depth buffers</span>
        iG3D.clear(iBackground);
 
        <span class="example_comment">// set up the camera in the desired position</span>
        <span class="example_class">Transform</span> transform = <span class="example_reserved">new</span> <span class="example_class">Transform</span>();
        transform.postTranslate(0.0f, 0.0f, 30.0f);
        iG3D.setCamera(iCamera, transform);
 
        <span class="example_comment">// set up a "headlight": a directional light shining</span>
        <span class="example_comment">// from the direction of the camera</span>
        iG3D.resetLights();
        iG3D.addLight(iLight, transform);
        
        <span class="example_comment">// update our transform (this will give us a rotating cube)</span>
        iAngle += 1.0f;
        iTransform.setIdentity();
        iTransform.postRotate(iAngle,       <span class="example_comment">// rotate 1 degree per frame</span>
                       1.0f, 1.0f, 1.0f);  <span class="example_comment">// rotate around this axis</span>
        
        <span class="example_comment">// Render our cube. We provide the vertex and index buffers</span>
        <span class="example_comment">// to specify the geometry; the appearance so we know what</span>
        <span class="example_comment">// material and texture to use; and the transform to tell</span>
        <span class="example_comment">// where to render the object</span>
        iG3D.render(iVb, iIb, iAppearance, iTransform);
        
        <span class="example_comment">// flush</span>
        iG3D.releaseTarget();
    }
}</pre><div class="example_title">(2) Immediate mode example MIDlet: Class MIDletMain.

</div><pre class="example"><span class="example_proclamation">import</span> javax.microedition.midlet.*;
<span class="example_proclamation">import</span> javax.microedition.lcdui.*;
<span class="example_proclamation">import</span> java.util.*;
 
<span class="example_modifier">public</span> <span class="example_proclamation">class</span> <span class="example_class">MIDletMain</span> <span class="example_proclamation">extends</span> <span class="example_class">MIDlet</span>
{
    <span class="example_modifier">static</span> <span class="example_class">MIDletMain</span> instance;
    <span class="example_class">MyCanvas</span> displayable = <span class="example_reserved">new</span> <span class="example_class">MyCanvas</span>();
    <span class="example_class">Timer</span> iTimer = <span class="example_reserved">new</span> <span class="example_class">Timer</span>();
 
    <span class="example_comment">/**
     * Construct the midlet.
     */</span>
    <span class="example_modifier">public</span> <span class="example_class">MIDletMain</span>() {
        <span class="example_reserved">this</span>.instance = <span class="example_reserved">this</span>;
    }
 
    <span class="example_comment">/**
     * Main method.
     */</span>
    <span class="example_modifier">public</span> <span class="example_type">void</span> startApp() {
        <span class="example_class">Display</span>.getDisplay(<span class="example_reserved">this</span>).setCurrent(displayable);
        iTimer.schedule( <span class="example_reserved">new</span> <span class="example_class">MyTimerTask</span>(), 0, 40 );
    }
 
    <span class="example_comment">/**
     * Handle pausing the MIDlet.
     */</span>
    <span class="example_modifier">public</span> <span class="example_type">void</span> pauseApp() {
    }
 
    <span class="example_comment">/**
     * Handle destroying the MIDlet.
     */</span>
    <span class="example_modifier">public</span> <span class="example_type">void</span> destroyApp(<span class="example_type">boolean</span> unconditional) {
    }
    
    <span class="example_comment">/**
     * Quit the MIDlet.
     */</span>
    <span class="example_modifier">public</span> <span class="example_modifier">static</span> <span class="example_type">void</span> quitApp() {
        instance.destroyApp(<span class="example_literal">true</span>);
        instance.notifyDestroyed();
        instance = <span class="example_literal">null</span>;
    }
 
    <span class="example_comment">/**
     * Our timer task for providing animation.
     */</span>
    <span class="example_proclamation">class</span> <span class="example_class">MyTimerTask</span> <span class="example_proclamation">extends</span> <span class="example_class">TimerTask</span> {
    	<span class="example_modifier">public</span> <span class="example_type">void</span> run() {
            <span class="example_control">if</span>( displayable != <span class="example_literal">null</span> ) {
                displayable.repaint();
            }
        }
    }
}</pre><div class="example_title">(3) Retained mode example MIDlet.

</div><pre class="example"><span class="example_proclamation">import</span> javax.microedition.midlet.<span class="example_class">MIDlet</span>;
<span class="example_proclamation">import</span> javax.microedition.midlet.<span class="example_class">MIDletStateChangeException</span>;
 
<span class="example_proclamation">import</span> javax.microedition.lcdui.<span class="example_class">Graphics</span>;
<span class="example_proclamation">import</span> javax.microedition.lcdui.<span class="example_class">Display</span>;
<span class="example_proclamation">import</span> javax.microedition.lcdui.<span class="example_class">Displayable</span>;
<span class="example_proclamation">import</span> javax.microedition.lcdui.<span class="example_class">Command</span>;
<span class="example_proclamation">import</span> javax.microedition.lcdui.<span class="example_class">Canvas</span>;
<span class="example_proclamation">import</span> javax.microedition.lcdui.<span class="example_class">CommandListener</span>;
 
<span class="example_proclamation">import</span> java.util.<span class="example_class">Timer</span>;
<span class="example_proclamation">import</span> java.util.<span class="example_class">TimerTask</span>;
 
<span class="example_proclamation">import</span> javax.microedition.m3g.*;
 
<span class="example_modifier">public</span> <span class="example_proclamation">class</span> <span class="example_class">JesterTestlet</span> <span class="example_proclamation">extends</span> <span class="example_class">MIDlet</span> <span class="example_proclamation">implements</span> <span class="example_class">CommandListener</span>
{
    <span class="example_modifier">private</span> <span class="example_class">Display</span> myDisplay = <span class="example_literal">null</span>;
    <span class="example_modifier">private</span> <span class="example_class">JesterCanvas</span> myCanvas = <span class="example_literal">null</span>;
 
    <span class="example_modifier">private</span> <span class="example_class">Timer</span> myRefreshTimer = <span class="example_reserved">new</span> <span class="example_class">Timer</span>();
    <span class="example_modifier">private</span> <span class="example_class">TimerTask</span> myRefreshTask = <span class="example_literal">null</span>;
 
    <span class="example_modifier">private</span> <span class="example_class">Command</span> exitCommand = <span class="example_reserved">new</span> <span class="example_class">Command</span>(<span class="example_string">"Exit"</span>, <span class="example_class">Command</span>.<span class="example_constant">ITEM</span>, 1);
 
    <span class="example_modifier">private</span> <span class="example_class">World</span> myWorld = <span class="example_literal">null</span>;
 
    <span class="example_comment">/**
     * JesterTestlet - default constructor.
     */</span>
    <span class="example_modifier">public</span> <span class="example_class">JesterTestlet</span>()
    {
        <span class="example_comment">// Set up the user interface.</span>
        myDisplay = <span class="example_class">Display</span>.getDisplay(<span class="example_reserved">this</span>);
        myCanvas = <span class="example_reserved">new</span> <span class="example_class">JesterCanvas</span>(<span class="example_reserved">this</span>);
        myCanvas.setCommandListener(<span class="example_reserved">this</span>);
        myCanvas.addCommand(exitCommand);
    }
 
    <span class="example_comment">/**
     * startApp()
     */</span>
    <span class="example_modifier">public</span> <span class="example_type">void</span> startApp() <span class="example_proclamation">throws</span> <span class="example_class">MIDletStateChangeException</span>
    {
        myDisplay.setCurrent(myCanvas);
 
        <span class="example_control">try</span>
        {
            <span class="example_comment">// Load a file.</span>
            <span class="example_class">Object</span>3D[] roots = 
                <span class="example_class">Loader</span>.load(<span class="example_string">"http://www.example.com/m3g/samples/simple.m3g"</span>);
                
            <span class="example_comment">// Assume the world is the first root node loaded.</span>
            myWorld = (<span class="example_class">World</span>)roots[0];
 
            <span class="example_comment">// Force a repaint so that we get the update loop started.</span>
            myCanvas.repaint();
        }
        <span class="example_control">catch</span>(<span class="example_class">Exception</span> e)
        {
            e.printStackTrace();
        }
    }
 
    <span class="example_comment">/**
     * pauseApp()
     */</span>
    <span class="example_modifier">public</span> <span class="example_type">void</span> pauseApp()
    {
        <span class="example_comment">// Release resources.</span>
        myWorld = <span class="example_literal">null</span>;
    }
 
    <span class="example_comment">/**
     * destroyApp()
     */</span>
    <span class="example_modifier">public</span> <span class="example_type">void</span> destroyApp(<span class="example_type">boolean</span> unconditional) <span class="example_proclamation">throws</span> <span class="example_class">MIDletStateChangeException</span>
    {
        myRefreshTimer.cancel();
        myRefreshTimer = <span class="example_literal">null</span>;
 
        <span class="example_comment">// Release resources.</span>
        myWorld = <span class="example_literal">null</span>;
    }
 
    <span class="example_comment">/**
     * MIDlet paint method.
     */</span>
    <span class="example_modifier">public</span> <span class="example_type">void</span> paint(<span class="example_class">Graphics</span> g)
    {
        <span class="example_comment">// We are not fully initialised yet; just return.</span>
        <span class="example_control">if</span>(myCanvas == <span class="example_literal">null</span> || myWorld == <span class="example_literal">null</span>)
            <span class="example_control">return</span>;
 
        <span class="example_comment">// Delete any pending refresh tasks.</span>
        <span class="example_control">if</span>(myRefreshTask != <span class="example_literal">null</span>)
        {
            myRefreshTask.cancel();
            myRefreshTask = <span class="example_literal">null</span>;
        }
 
        <span class="example_comment">// Get the current time.</span>
        <span class="example_type">long</span> currentTime = <span class="example_class">System</span>.currentTimeMillis();
        <span class="example_comment">// Update the world to the current time.</span>
        <span class="example_type">int</span> validity = myWorld.animate((<span class="example_type">int</span>)currentTime);
 
        <span class="example_comment">// Render to our Graphics.</span>
        <span class="example_class">Graphics</span>3D myGraphics3D = <span class="example_class">Graphics</span>3D.getInstance();
        myGraphics3D.bindTarget(g);
        myGraphics3D.render(myWorld);
        myGraphics3D.releaseTarget();
 
        <span class="example_comment">// Subtract time taken to do the update.</span>
        validity -= <span class="example_class">System</span>.currentTimeMillis() - currentTime;
 
        <span class="example_control">if</span>(validity &lt; 1)
        {    <span class="example_comment">// The validity is too small; allow a minimum of 1ms.</span>
            validity = 1;
        }
 
        <span class="example_comment">// If the validity is not infinite schedule a refresh task.</span>
        <span class="example_control">if</span>(validity &lt; 0x7fffffff)
        {
            <span class="example_comment">// Create a new refresh task.</span>
            myRefreshTask = <span class="example_reserved">new</span> <span class="example_class">RefreshTask</span>();
 
            <span class="example_comment">// Schedule an update.</span>
            myRefreshTimer.schedule(myRefreshTask, validity);
        }
    }
 
    <span class="example_comment">/**
     * Handle commands.
     */</span>
    <span class="example_modifier">public</span> <span class="example_type">void</span> commandAction(<span class="example_class">Command</span> cmd, <span class="example_class">Displayable</span> disp)
    {
        <span class="example_control">if</span> (cmd == exitCommand)
        {
            <span class="example_control">try</span>
            {
                destroyApp(<span class="example_literal">false</span>);
                notifyDestroyed();
            }
            <span class="example_control">catch</span>(<span class="example_class">Exception</span> e)
            {
                e.printStackTrace();
            }
        }
    }
 
    <span class="example_comment">/**
     * Inner class for refreshing the view.
     */</span>
    <span class="example_modifier">private</span> <span class="example_proclamation">class</span> <span class="example_class">RefreshTask</span> <span class="example_proclamation">extends</span> <span class="example_class">TimerTask</span>
    {
        <span class="example_modifier">public</span> <span class="example_type">void</span> run()
        {
            <span class="example_comment">// Get the canvas to repaint itself.</span>
            myCanvas.repaint();
        }
    }
 
    <span class="example_comment">/**
     * Inner class for handling the canvas.
     */</span>
    <span class="example_proclamation">class</span> <span class="example_class">JesterCanvas</span> <span class="example_proclamation">extends</span> <span class="example_class">Canvas</span>
    {
        <span class="example_class">JesterTestlet</span> myTestlet;
 
        <span class="example_comment">/**
         * Construct a new canvas
         */</span>
        <span class="example_class">JesterCanvas</span>(<span class="example_class">JesterTestlet</span> <span class="example_class">Testlet</span>) { myTestlet = <span class="example_class">Testlet</span>; }
 
        <span class="example_comment">/**
         * Initialize self.
         */</span>
        <span class="example_type">void</span> init() { }
 
        <span class="example_comment">/**
         * Cleanup and destroy.
         */</span>
        <span class="example_type">void</span> destroy() { }
 
        <span class="example_comment">/**
         * Ask myTestlet to paint itself
         */</span>
        <span class="example_modifier">protected</span> <span class="example_type">void</span> paint(<span class="example_class">Graphics</span> g) { myTestlet.paint(g); }
    }
}</pre></DD></DD></DL>
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A>
<A HREF="#skip-navbar_bottom" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=3 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Package</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <FONT CLASS="NavBarFont1">Class</FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-use.html"><FONT CLASS="NavBarFont1"><B>Use</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<EM><B>M3G 1.1 -- Jun 22, 2005</B></EM></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;PREV PACKAGE&nbsp;
&nbsp;NEXT PACKAGE</FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../index.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="package-summary.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>

</FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A>
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<HR>
<EM>Copyright &copy; 2005 Nokia Corporation. See the <a href="../../../overview-summary.html#Copyright">Copyright Notice</a> for details.</EM>
</BODY>
</HTML>
